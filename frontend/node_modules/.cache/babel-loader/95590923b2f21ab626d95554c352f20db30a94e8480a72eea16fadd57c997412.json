{"ast":null,"code":"import { encodeContextObject } from './context.js';\nimport { WalletStandardErrorMessages } from './messages.js';\nvar StateType;\n(function (StateType) {\n  StateType[StateType[\"EscapeSequence\"] = 0] = \"EscapeSequence\";\n  StateType[StateType[\"Text\"] = 1] = \"Text\";\n  StateType[StateType[\"Variable\"] = 2] = \"Variable\";\n})(StateType || (StateType = {}));\nconst START_INDEX = 'i';\nconst TYPE = 't';\nexport function getHumanReadableErrorMessage(code, context = {}) {\n  const messageFormatString = WalletStandardErrorMessages[code];\n  if (messageFormatString.length === 0) {\n    return '';\n  }\n  let state;\n  function commitStateUpTo(endIndex) {\n    if (state[TYPE] === StateType.Variable) {\n      const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n      fragments.push(variableName in context ? `${context[variableName]}` : `$${variableName}`);\n    } else if (state[TYPE] === StateType.Text) {\n      fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n    }\n  }\n  const fragments = [];\n  messageFormatString.split('').forEach((char, ii) => {\n    if (ii === 0) {\n      state = {\n        [START_INDEX]: 0,\n        [TYPE]: messageFormatString[0] === '\\\\' ? StateType.EscapeSequence : messageFormatString[0] === '$' ? StateType.Variable : StateType.Text\n      };\n      return;\n    }\n    let nextState;\n    switch (state[TYPE]) {\n      case StateType.EscapeSequence:\n        nextState = {\n          [START_INDEX]: ii,\n          [TYPE]: StateType.Text\n        };\n        break;\n      case StateType.Text:\n        if (char === '\\\\') {\n          nextState = {\n            [START_INDEX]: ii,\n            [TYPE]: StateType.EscapeSequence\n          };\n        } else if (char === '$') {\n          nextState = {\n            [START_INDEX]: ii,\n            [TYPE]: StateType.Variable\n          };\n        }\n        break;\n      case StateType.Variable:\n        if (char === '\\\\') {\n          nextState = {\n            [START_INDEX]: ii,\n            [TYPE]: StateType.EscapeSequence\n          };\n        } else if (char === '$') {\n          nextState = {\n            [START_INDEX]: ii,\n            [TYPE]: StateType.Variable\n          };\n        } else if (!char.match(/\\w/)) {\n          nextState = {\n            [START_INDEX]: ii,\n            [TYPE]: StateType.Text\n          };\n        }\n        break;\n    }\n    if (nextState) {\n      if (state !== nextState) {\n        commitStateUpTo(ii);\n      }\n      state = nextState;\n    }\n  });\n  commitStateUpTo();\n  return fragments.join('');\n}\nexport function getErrorMessage(code, context = {}) {\n  if (process.env.NODE_ENV !== 'production') {\n    return getHumanReadableErrorMessage(code, context);\n  } else {\n    let decodingAdviceMessage = `Wallet Standard error #${code}; Decode this error by running \\`npx @wallet-standard/errors decode -- ${code}`;\n    if (Object.keys(context).length) {\n      /**\n       * DANGER: Be sure that the shell command is escaped in such a way that makes it\n       *         impossible for someone to craft malicious context values that would result in\n       *         an exploit against anyone who bindly copy/pastes it into their terminal.\n       */\n      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n    }\n    return `${decodingAdviceMessage}\\``;\n  }\n}","map":{"version":3,"names":["encodeContextObject","WalletStandardErrorMessages","StateType","START_INDEX","TYPE","getHumanReadableErrorMessage","code","context","messageFormatString","length","state","commitStateUpTo","endIndex","Variable","variableName","slice","fragments","push","Text","split","forEach","char","ii","EscapeSequence","nextState","match","join","getErrorMessage","process","env","NODE_ENV","decodingAdviceMessage","Object","keys"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@wallet-standard\\errors\\src\\message-formatter.ts"],"sourcesContent":["import type { WalletStandardErrorCode } from './codes.js';\nimport { encodeContextObject } from './context.js';\nimport { WalletStandardErrorMessages } from './messages.js';\n\nconst enum StateType {\n    EscapeSequence,\n    Text,\n    Variable,\n}\ntype State = Readonly<{\n    [START_INDEX]: number;\n    [TYPE]: StateType;\n}>;\nconst START_INDEX = 'i';\nconst TYPE = 't';\n\nexport function getHumanReadableErrorMessage<TErrorCode extends WalletStandardErrorCode>(\n    code: TErrorCode,\n    context: object = {}\n): string {\n    const messageFormatString = WalletStandardErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state: State;\n    function commitStateUpTo(endIndex?: number) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n            fragments.push(\n                variableName in context ? `${context[variableName as keyof typeof context]}` : `$${variableName}`\n            );\n        } else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments: string[] = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]:\n                    messageFormatString[0] === '\\\\'\n                        ? StateType.EscapeSequence\n                        : messageFormatString[0] === '$'\n                          ? StateType.Variable\n                          : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                } else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\n\nexport function getErrorMessage<TErrorCode extends WalletStandardErrorCode>(\n    code: TErrorCode,\n    context: object = {}\n): string {\n    if (process.env.NODE_ENV !== 'production') {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Wallet Standard error #${code}; Decode this error by running \\`npx @wallet-standard/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}