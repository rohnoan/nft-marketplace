{"ast":null,"code":"import { a as k } from \"./chunk-YOZBVVKL.mjs\";\nimport { e as x, f as B } from \"./chunk-BXRBOMHW.mjs\";\nimport { b as f, d as A } from \"./chunk-GJ7STZEW.mjs\";\nimport { e as b } from \"./chunk-6Y6ZO7TS.mjs\";\nimport { a as d } from \"./chunk-YFFDF22R.mjs\";\nimport { d as C } from \"./chunk-RJ7F4JDV.mjs\";\nasync function H(o) {\n  let {\n    aptosConfig: n,\n    options: t\n  } = o;\n  return A({\n    aptosConfig: n,\n    originMethod: \"getTransactions\",\n    path: \"transactions\",\n    params: {\n      start: t?.offset,\n      limit: t?.limit\n    }\n  });\n}\nasync function W(o) {\n  let {\n    aptosConfig: n\n  } = o;\n  return k(async () => {\n    let {\n      data: t\n    } = await f({\n      aptosConfig: n,\n      originMethod: \"getGasPriceEstimation\",\n      path: \"estimate_gas_price\"\n    });\n    return t;\n  }, `gas-price-${n.network}`, 1e3 * 60 * 5)();\n}\nasync function O(o) {\n  let {\n      aptosConfig: n,\n      ledgerVersion: t\n    } = o,\n    {\n      data: s\n    } = await f({\n      aptosConfig: n,\n      originMethod: \"getTransactionByVersion\",\n      path: `transactions/by_version/${t}`\n    });\n  return s;\n}\nasync function y(o) {\n  let {\n      aptosConfig: n,\n      transactionHash: t\n    } = o,\n    {\n      data: s\n    } = await f({\n      aptosConfig: n,\n      path: `transactions/by_hash/${t}`,\n      originMethod: \"getTransactionByHash\"\n    });\n  return s;\n}\nasync function q(o) {\n  let {\n    aptosConfig: n,\n    transactionHash: t\n  } = o;\n  try {\n    return (await y({\n      aptosConfig: n,\n      transactionHash: t\n    })).type === \"pending_transaction\";\n  } catch (s) {\n    if (s?.status === 404) return !0;\n    throw s;\n  }\n}\nasync function R(o) {\n  let {\n      aptosConfig: n,\n      transactionHash: t\n    } = o,\n    {\n      data: s\n    } = await f({\n      aptosConfig: n,\n      path: `transactions/wait_by_hash/${t}`,\n      originMethod: \"longWaitForTransaction\"\n    });\n  return s;\n}\nasync function z(o) {\n  let {\n      aptosConfig: n,\n      transactionHash: t,\n      options: s\n    } = o,\n    r = s?.timeoutSecs ?? 20,\n    u = s?.checkSuccess ?? !0,\n    e = !0,\n    p = 0,\n    i,\n    g,\n    l = 200,\n    h = 1.5;\n  function c(a) {\n    if (!(a instanceof b) || (g = a, a.status !== 404 && a.status >= 400 && a.status < 500)) throw a;\n  }\n  try {\n    i = await y({\n      aptosConfig: n,\n      transactionHash: t\n    }), e = i.type === \"pending_transaction\";\n  } catch (a) {\n    c(a);\n  }\n  if (e) {\n    let a = Date.now();\n    try {\n      i = await R({\n        aptosConfig: n,\n        transactionHash: t\n      }), e = i.type === \"pending_transaction\";\n    } catch (w) {\n      c(w);\n    }\n    p = (Date.now() - a) / 1e3;\n  }\n  for (; e && !(p >= r);) {\n    try {\n      if (i = await y({\n        aptosConfig: n,\n        transactionHash: t\n      }), e = i.type === \"pending_transaction\", !e) break;\n    } catch (a) {\n      c(a);\n    }\n    await d(l), p += l / 1e3, l *= h;\n  }\n  if (i === void 0) throw g || new m(`Fetching transaction ${t} failed and timed out after ${r} seconds`, i);\n  if (i.type === \"pending_transaction\") throw new m(`Transaction ${t} timed out in pending state after ${r} seconds`, i);\n  if (!u) return i;\n  if (!i.success) throw new T(`Transaction ${t} failed with an error: ${i.vm_status}`, i);\n  return i;\n}\nasync function U(o) {\n  let {\n      aptosConfig: n,\n      processorType: t\n    } = o,\n    s = BigInt(o.minimumLedgerVersion),\n    r = 3e3,\n    u = new Date().getTime(),\n    e = BigInt(-1);\n  for (; e < s;) {\n    if (new Date().getTime() - u > r) throw new Error(\"waitForLastSuccessIndexerVersionSync timeout\");\n    if (t === void 0 ? e = await x({\n      aptosConfig: n\n    }) : e = (await B({\n      aptosConfig: n,\n      processorType: t\n    })).last_success_version, e >= s) break;\n    await d(200);\n  }\n}\nvar m = class extends Error {\n    constructor(n, t) {\n      super(n), this.lastSubmittedTransaction = t;\n    }\n  },\n  T = class extends Error {\n    constructor(n, t) {\n      super(n), this.transaction = t;\n    }\n  };\nasync function X(o) {\n  let {\n      aptosConfig: n,\n      ledgerVersion: t,\n      options: s\n    } = o,\n    {\n      data: r\n    } = await f({\n      aptosConfig: n,\n      originMethod: \"getBlockByVersion\",\n      path: `blocks/by_version/${t}`,\n      params: {\n        with_transactions: s?.withTransactions\n      }\n    });\n  return P({\n    block: r,\n    ...o\n  });\n}\nasync function j(o) {\n  let {\n      aptosConfig: n,\n      blockHeight: t,\n      options: s\n    } = o,\n    {\n      data: r\n    } = await f({\n      aptosConfig: n,\n      originMethod: \"getBlockByHeight\",\n      path: `blocks/by_height/${t}`,\n      params: {\n        with_transactions: s?.withTransactions\n      }\n    });\n  return P({\n    block: r,\n    ...o\n  });\n}\nasync function P(o) {\n  let {\n    aptosConfig: n,\n    block: t,\n    options: s\n  } = o;\n  if (s?.withTransactions) {\n    t.transactions = t.transactions ?? [];\n    let r = t.transactions[t.transactions.length - 1],\n      u = BigInt(t.first_version),\n      e = BigInt(t.last_version),\n      p = r?.version,\n      i;\n    if (p === void 0 ? i = u - 1n : i = BigInt(p), i === e) return t;\n    let g = [],\n      l = 100n;\n    for (let c = i + 1n; c < e; c += BigInt(100)) g.push(H({\n      aptosConfig: n,\n      options: {\n        offset: c,\n        limit: Math.min(Number(l), Number(e - c + 1n))\n      }\n    }));\n    let h = await Promise.all(g);\n    for (let c of h) t.transactions.push(...c);\n  }\n  return t;\n}\nexport { H as a, W as b, O as c, y as d, q as e, R as f, z as g, U as h, m as i, T as j, X as k, j as l };","map":{"version":3,"names":["H","o","aptosConfig","n","options","t","A","originMethod","path","params","start","offset","limit","W","k","data","f","network","O","ledgerVersion","s","y","transactionHash","q","type","status","R","z","r","timeoutSecs","u","checkSuccess","e","p","i","g","l","h","c","a","b","Date","now","w","d","m","success","T","vm_status","U","processorType","BigInt","minimumLedgerVersion","getTime","Error","x","B","last_success_version","constructor","lastSubmittedTransaction","transaction","X","with_transactions","withTransactions","P","block","j","blockHeight","transactions","length","first_version","last_version","version","push","Math","min","Number","Promise","all"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-standard\\node_modules\\@aptos-labs\\ts-sdk\\src\\internal\\transaction.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/transaction}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * transaction namespace and without having a dependency cycle error.\n * @group Implementation\n */\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { getAptosFullNode, paginateWithCursor } from \"../client\";\nimport { AptosApiError } from \"../errors\";\nimport {\n  TransactionResponseType,\n  type AnyNumber,\n  type GasEstimation,\n  type HexInput,\n  type PaginationArgs,\n  type TransactionResponse,\n  WaitForTransactionOptions,\n  CommittedTransactionResponse,\n  Block,\n} from \"../types\";\nimport { DEFAULT_TXN_TIMEOUT_SEC, ProcessorType } from \"../utils/const\";\nimport { sleep } from \"../utils/helpers\";\nimport { memoizeAsync } from \"../utils/memoize\";\nimport { getIndexerLastSuccessVersion, getProcessorStatus } from \"./general\";\n\n/**\n * Retrieve a list of transactions based on the specified options.\n *\n * @param {Object} args - The parameters for retrieving transactions.\n * @param {Object} args.aptosConfig - The configuration object for Aptos.\n * @param {Object} args.options - The options for pagination.\n * @param {number} args.options.offset - The number of transactions to skip before starting to collect the result set.\n * @param {number} args.options.limit - The maximum number of transactions to return.\n * @group Implementation\n */\nexport async function getTransactions(args: {\n  aptosConfig: AptosConfig;\n  options?: PaginationArgs;\n}): Promise<TransactionResponse[]> {\n  const { aptosConfig, options } = args;\n  return paginateWithCursor<{}, TransactionResponse[]>({\n    aptosConfig,\n    originMethod: \"getTransactions\",\n    path: \"transactions\",\n    params: { start: options?.offset, limit: options?.limit },\n  });\n}\n\n/**\n * Retrieves the estimated gas price for transactions on the Aptos network.\n * This function helps users understand the current gas price, which is essential for transaction planning and cost estimation.\n *\n * @param args - The configuration parameters for the Aptos network.\n * @param args.aptosConfig - The configuration object containing network details.\n * @group Implementation\n */\nexport async function getGasPriceEstimation(args: { aptosConfig: AptosConfig }) {\n  const { aptosConfig } = args;\n\n  return memoizeAsync(\n    async () => {\n      const { data } = await getAptosFullNode<{}, GasEstimation>({\n        aptosConfig,\n        originMethod: \"getGasPriceEstimation\",\n        path: \"estimate_gas_price\",\n      });\n      return data;\n    },\n    `gas-price-${aptosConfig.network}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n\n/**\n * Retrieves the transaction details associated with a specific ledger version.\n *\n * @param args - The arguments for the transaction retrieval.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.ledgerVersion - The ledger version for which to retrieve the transaction.\n * @returns The transaction details for the specified ledger version.\n * @group Implementation\n */\nexport async function getTransactionByVersion(args: {\n  aptosConfig: AptosConfig;\n  ledgerVersion: AnyNumber;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, ledgerVersion } = args;\n  const { data } = await getAptosFullNode<{}, TransactionResponse>({\n    aptosConfig,\n    originMethod: \"getTransactionByVersion\",\n    path: `transactions/by_version/${ledgerVersion}`,\n  });\n  return data;\n}\n\n/**\n * Retrieves transaction details using the specified transaction hash.\n *\n * @param args - The arguments for retrieving the transaction.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.transactionHash - The hash of the transaction to retrieve.\n * @returns A promise that resolves to the transaction details.\n * @group Implementation\n */\nexport async function getTransactionByHash(args: {\n  aptosConfig: AptosConfig;\n  transactionHash: HexInput;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, transactionHash } = args;\n  const { data } = await getAptosFullNode<{}, TransactionResponse>({\n    aptosConfig,\n    path: `transactions/by_hash/${transactionHash}`,\n    originMethod: \"getTransactionByHash\",\n  });\n  return data;\n}\n\n/**\n * Checks if a transaction is currently pending based on its hash.\n * This function helps determine the status of a transaction in the Aptos network.\n *\n * @param args - The arguments for checking the transaction status.\n * @param args.aptosConfig - The configuration settings for connecting to the Aptos network.\n * @param args.transactionHash - The hash of the transaction to check.\n * @returns A boolean indicating whether the transaction is pending.\n * @throws An error if the transaction cannot be retrieved due to reasons other than a 404 status.\n * @group Implementation\n */\nexport async function isTransactionPending(args: {\n  aptosConfig: AptosConfig;\n  transactionHash: HexInput;\n}): Promise<boolean> {\n  const { aptosConfig, transactionHash } = args;\n  try {\n    const transaction = await getTransactionByHash({ aptosConfig, transactionHash });\n    return transaction.type === TransactionResponseType.Pending;\n  } catch (e: any) {\n    if (e?.status === 404) {\n      return true;\n    }\n    throw e;\n  }\n}\n\n/**\n * Waits for a transaction to be confirmed by its hash.\n * This function allows you to monitor the status of a transaction until it is finalized.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration settings for the Aptos client.\n * @param args.transactionHash - The hash of the transaction to wait for.\n * @group Implementation\n */\nexport async function longWaitForTransaction(args: {\n  aptosConfig: AptosConfig;\n  transactionHash: HexInput;\n}): Promise<TransactionResponse> {\n  const { aptosConfig, transactionHash } = args;\n  const { data } = await getAptosFullNode<{}, TransactionResponse>({\n    aptosConfig,\n    path: `transactions/wait_by_hash/${transactionHash}`,\n    originMethod: \"longWaitForTransaction\",\n  });\n  return data;\n}\n\n/**\n * Waits for a transaction to be confirmed on the blockchain and handles potential errors during the process.\n * This function allows you to monitor the status of a transaction until it is either confirmed or fails.\n *\n * @param args - The arguments for waiting for a transaction.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.transactionHash - The hash of the transaction to wait for.\n * @param args.options - Optional settings for waiting, including timeout and success check.\n * @param args.options.timeoutSecs - The maximum time to wait for the transaction in seconds. Defaults to a predefined value.\n * @param args.options.checkSuccess - A flag indicating whether to check the success status of the transaction. Defaults to true.\n * @returns A promise that resolves to the transaction response once the transaction is confirmed.\n * @throws WaitForTransactionError if the transaction times out or remains pending.\n * @throws FailedTransactionError if the transaction fails.\n * @group Implementation\n */\nexport async function waitForTransaction(args: {\n  aptosConfig: AptosConfig;\n  transactionHash: HexInput;\n  options?: WaitForTransactionOptions;\n}): Promise<CommittedTransactionResponse> {\n  const { aptosConfig, transactionHash, options } = args;\n  const timeoutSecs = options?.timeoutSecs ?? DEFAULT_TXN_TIMEOUT_SEC;\n  const checkSuccess = options?.checkSuccess ?? true;\n\n  let isPending = true;\n  let timeElapsed = 0;\n  let lastTxn: TransactionResponse | undefined;\n  let lastError: AptosApiError | undefined;\n  let backoffIntervalMs = 200;\n  const backoffMultiplier = 1.5;\n\n  /**\n   * Handles API errors by throwing the last error or a timeout error for a failed transaction.\n   *\n   * @param e - The error object that occurred during the API call.\n   * @throws {Error} Throws the last error if it exists; otherwise, throws a WaitForTransactionError indicating a timeout.\n   * @group Implementation\n   */\n  function handleAPIError(e: any) {\n    // In short, this means we will retry if it was an AptosApiError and the code was 404 or 5xx.\n    const isAptosApiError = e instanceof AptosApiError;\n    if (!isAptosApiError) {\n      throw e; // This would be unexpected\n    }\n    lastError = e;\n    const isRequestError = e.status !== 404 && e.status >= 400 && e.status < 500;\n    if (isRequestError) {\n      throw e;\n    }\n  }\n\n  // check to see if the txn is already on the blockchain\n  try {\n    lastTxn = await getTransactionByHash({ aptosConfig, transactionHash });\n    isPending = lastTxn.type === TransactionResponseType.Pending;\n  } catch (e) {\n    handleAPIError(e);\n  }\n\n  // If the transaction is pending, we do a long wait once to avoid polling\n  if (isPending) {\n    const startTime = Date.now();\n    try {\n      lastTxn = await longWaitForTransaction({ aptosConfig, transactionHash });\n      isPending = lastTxn.type === TransactionResponseType.Pending;\n    } catch (e) {\n      handleAPIError(e);\n    }\n    timeElapsed = (Date.now() - startTime) / 1000;\n  }\n\n  // Now we do polling to see if the transaction is still pending\n  while (isPending) {\n    if (timeElapsed >= timeoutSecs) {\n      break;\n    }\n    try {\n      // eslint-disable-next-line no-await-in-loop\n      lastTxn = await getTransactionByHash({ aptosConfig, transactionHash });\n\n      isPending = lastTxn.type === TransactionResponseType.Pending;\n\n      if (!isPending) {\n        break;\n      }\n    } catch (e) {\n      handleAPIError(e);\n    }\n    // eslint-disable-next-line no-await-in-loop\n    await sleep(backoffIntervalMs);\n    timeElapsed += backoffIntervalMs / 1000; // Convert to seconds\n    backoffIntervalMs *= backoffMultiplier;\n  }\n\n  // There is a chance that lastTxn is still undefined. Let's throw the last error otherwise a WaitForTransactionError\n  if (lastTxn === undefined) {\n    if (lastError) {\n      throw lastError;\n    } else {\n      throw new WaitForTransactionError(\n        `Fetching transaction ${transactionHash} failed and timed out after ${timeoutSecs} seconds`,\n        lastTxn,\n      );\n    }\n  }\n\n  if (lastTxn.type === TransactionResponseType.Pending) {\n    throw new WaitForTransactionError(\n      `Transaction ${transactionHash} timed out in pending state after ${timeoutSecs} seconds`,\n      lastTxn,\n    );\n  }\n  if (!checkSuccess) {\n    return lastTxn;\n  }\n  if (!lastTxn.success) {\n    throw new FailedTransactionError(\n      `Transaction ${transactionHash} failed with an error: ${lastTxn.vm_status}`,\n      lastTxn,\n    );\n  }\n\n  return lastTxn;\n}\n\n/**\n * Waits for the indexer to sync up to the specified ledger version. The timeout is 3 seconds.\n *\n * @param args - The arguments for the function.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.minimumLedgerVersion - The minimum ledger version that the indexer should sync to.\n * @param args.processorType - (Optional) The type of processor to check the last success version from.\n * @group Implementation\n */\nexport async function waitForIndexer(args: {\n  aptosConfig: AptosConfig;\n  minimumLedgerVersion: AnyNumber;\n  processorType?: ProcessorType;\n}): Promise<void> {\n  const { aptosConfig, processorType } = args;\n  const minimumLedgerVersion = BigInt(args.minimumLedgerVersion);\n  const timeoutMilliseconds = 3000; // 3 seconds\n  const startTime = new Date().getTime();\n  let indexerVersion = BigInt(-1);\n\n  while (indexerVersion < minimumLedgerVersion) {\n    // check for timeout\n    if (new Date().getTime() - startTime > timeoutMilliseconds) {\n      throw new Error(\"waitForLastSuccessIndexerVersionSync timeout\");\n    }\n\n    if (processorType === undefined) {\n      // Get the last success version from all processor\n      // eslint-disable-next-line no-await-in-loop\n      indexerVersion = await getIndexerLastSuccessVersion({ aptosConfig });\n    } else {\n      // Get the last success version from the specific processor\n      // eslint-disable-next-line no-await-in-loop\n      const processor = await getProcessorStatus({ aptosConfig, processorType });\n      indexerVersion = processor.last_success_version;\n    }\n\n    if (indexerVersion >= minimumLedgerVersion) {\n      // break out immediately if we are synced\n      break;\n    }\n\n    // eslint-disable-next-line no-await-in-loop\n    await sleep(200);\n  }\n}\n\n/**\n * Represents an error that occurs when waiting for a transaction to complete.\n * This error is thrown by the `waitForTransaction` function when a transaction\n * times out or when the transaction response is undefined.\n *\n * @param message - A descriptive message for the error.\n * @param lastSubmittedTransaction - The last submitted transaction response, if available.\n * @group Implementation\n */\nexport class WaitForTransactionError extends Error {\n  public readonly lastSubmittedTransaction: TransactionResponse | undefined;\n\n  /**\n   * Constructs an instance of the class with a specified message and transaction response.\n   *\n   * @param message - The message associated with the transaction.\n   * @param lastSubmittedTransaction - The transaction response object containing details about the transaction.\n   * @group Implementation\n   */\n  constructor(message: string, lastSubmittedTransaction: TransactionResponse | undefined) {\n    super(message);\n    this.lastSubmittedTransaction = lastSubmittedTransaction;\n  }\n}\n\n/**\n * Represents an error that occurs when a transaction fails.\n * This error is thrown by the `waitForTransaction` function when the `checkSuccess` parameter is set to true.\n *\n * @param message - A description of the error.\n * @param transaction - The transaction response associated with the failure.\n * @group Implementation\n */\nexport class FailedTransactionError extends Error {\n  public readonly transaction: TransactionResponse;\n\n  constructor(message: string, transaction: TransactionResponse) {\n    super(message);\n    this.transaction = transaction;\n  }\n}\n\n/**\n * Retrieves a block from the Aptos blockchain by its ledger version.\n * This function allows you to obtain detailed information about a specific block, including its transactions if requested.\n *\n * @param args - The arguments for retrieving the block.\n * @param args.aptosConfig - The configuration object for connecting to the Aptos node.\n * @param args.ledgerVersion - The ledger version of the block to retrieve.\n * @param args.options - Optional parameters for the request.\n * @param args.options.withTransactions - Indicates whether to include transactions in the block data.\n * @group Implementation\n */\nexport async function getBlockByVersion(args: {\n  aptosConfig: AptosConfig;\n  ledgerVersion: AnyNumber;\n  options?: { withTransactions?: boolean };\n}): Promise<Block> {\n  const { aptosConfig, ledgerVersion, options } = args;\n  const { data: block } = await getAptosFullNode<{}, Block>({\n    aptosConfig,\n    originMethod: \"getBlockByVersion\",\n    path: `blocks/by_version/${ledgerVersion}`,\n    params: { with_transactions: options?.withTransactions },\n  });\n\n  return fillBlockTransactions({ block, ...args });\n}\n\n/**\n * Retrieves a block from the Aptos blockchain by its height.\n *\n * @param args - The parameters for retrieving the block.\n * @param args.aptosConfig - The configuration object for connecting to the Aptos network.\n * @param args.blockHeight - The height of the block to retrieve.\n * @param args.options - Optional parameters for the request.\n * @param args.options.withTransactions - Indicates whether to include transactions in the block data.\n * @returns A promise that resolves to the block data, potentially including its transactions.\n * @group Implementation\n */\nexport async function getBlockByHeight(args: {\n  aptosConfig: AptosConfig;\n  blockHeight: AnyNumber;\n  options?: { withTransactions?: boolean };\n}): Promise<Block> {\n  const { aptosConfig, blockHeight, options } = args;\n  const { data: block } = await getAptosFullNode<{}, Block>({\n    aptosConfig,\n    originMethod: \"getBlockByHeight\",\n    path: `blocks/by_height/${blockHeight}`,\n    params: { with_transactions: options?.withTransactions },\n  });\n  return fillBlockTransactions({ block, ...args });\n}\n\n/**\n * Fills in the block with transactions if not enough were returned. This function ensures that the block contains all relevant\n * transactions by fetching any missing ones based on the specified options.\n * @param args - The arguments for filling the block transactions.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.block - The block object that will be filled with transactions.\n * @param args.options - Optional settings for fetching transactions.\n * @param args.options.withTransactions - Indicates whether to include transactions in the block.\n * @group Implementation\n */\nasync function fillBlockTransactions(args: {\n  aptosConfig: AptosConfig;\n  block: Block;\n  options?: { withTransactions?: boolean };\n}) {\n  const { aptosConfig, block, options } = args;\n  if (options?.withTransactions) {\n    // Transactions should be filled, but this ensures it\n    block.transactions = block.transactions ?? [];\n\n    const lastTxn = block.transactions[block.transactions.length - 1];\n    const firstVersion = BigInt(block.first_version);\n    const lastVersion = BigInt(block.last_version);\n\n    // Convert the transaction to the type\n    const curVersion: string | undefined = (lastTxn as any)?.version;\n    let latestVersion;\n\n    // This time, if we don't have any transactions, we will try once with the start of the block\n    if (curVersion === undefined) {\n      latestVersion = firstVersion - 1n;\n    } else {\n      latestVersion = BigInt(curVersion);\n    }\n\n    // If we have all the transactions in the block, we can skip out, otherwise we need to fill the transactions\n    if (latestVersion === lastVersion) {\n      return block;\n    }\n\n    // For now, we will grab all the transactions in groups of 100, but we can make this more efficient by trying larger\n    // amounts\n    const fetchFutures = [];\n    const pageSize = 100n;\n    for (let i = latestVersion + 1n; i < lastVersion; i += BigInt(100)) {\n      fetchFutures.push(\n        getTransactions({\n          aptosConfig,\n          options: {\n            offset: i,\n            limit: Math.min(Number(pageSize), Number(lastVersion - i + 1n)),\n          },\n        }),\n      );\n    }\n\n    // Combine all the futures\n    const responses = await Promise.all(fetchFutures);\n    for (const txns of responses) {\n      block.transactions.push(...txns);\n    }\n  }\n\n  return block;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}