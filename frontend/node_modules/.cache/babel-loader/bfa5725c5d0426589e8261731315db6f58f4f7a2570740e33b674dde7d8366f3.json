{"ast":null,"code":"/**\n * bn254, previously known as alt_bn_128, when it had 128-bit security.\n\nBarbulescu-Duquesne 2017 shown it's weaker: just about 100 bits,\nso the naming has been adjusted to its prime bit count:\nhttps://hal.science/hal-01534101/file/main.pdf.\nCompatible with EIP-196 and EIP-197.\n\nThere are huge compatibility issues in the ecosystem:\n\n1. Different libraries call it in different ways: \"bn254\", \"bn256\", \"alt_bn128\", \"bn128\".\n2. libff has bn128, but it's a different curve with different G2:\n   https://github.com/scipr-lab/libff/blob/a44f482e18b8ac04d034c193bd9d7df7817ad73f/libff/algebra/curves/bn128/bn128_init.cpp#L166-L169\n3. halo2curves bn256 is also incompatible and returns different outputs\n\nWe don't implement Point methods toHex / toBytes.\nTo work around this limitation, has to initialize points on their own from BigInts.\nReason it's not implemented is because [there is no standard](https://github.com/privacy-scaling-explorations/halo2curves/issues/109).\nPoints of divergence:\n\n- Endianness: LE vs BE (byte-swapped)\n- Flags as first hex bits (similar to BLS) vs no-flags\n- Imaginary part last in G2 vs first (c0, c1 vs c1, c0)\n\nThe goal of our implementation is to support \"Ethereum\" variant of the curve,\nbecause it at least has specs:\n\n- EIP196 (https://eips.ethereum.org/EIPS/eip-196) describes bn254 ECADD and ECMUL opcodes for EVM\n- EIP197 (https://eips.ethereum.org/EIPS/eip-197) describes bn254 pairings\n- It's hard: EIPs don't have proper tests. EIP-197 returns boolean output instead of Fp12\n- The existing implementations are bad. Some are deprecated:\n    - https://github.com/paritytech/bn (old version)\n    - https://github.com/ewasm/ethereum-bn128.rs (uses paritytech/bn)\n    - https://github.com/zcash-hackworks/bn\n    - https://github.com/arkworks-rs/curves/blob/master/bn254/src/lib.rs\n- Python implementations use different towers and produce different Fp12 outputs:\n    - https://github.com/ethereum/py_pairing\n    - https://github.com/ethereum/execution-specs/blob/master/src/ethereum/crypto/alt_bn128.py\n- Points are encoded differently in different implementations\n\n### Params\nSeed (X): 4965661367192848881\nFr: (36x⁴+36x³+18x²+6x+1)\nFp: (36x⁴+36x³+24x²+6x+1)\n(E  / Fp ): Y² = X³+3\n(Et / Fp²): Y² = X³+3/(u+9) (D-type twist)\nAte loop size: 6x+2\n\n### Towers\n- Fp²[u] = Fp/u²+1\n- Fp⁶[v] = Fp²/v³-9-u\n- Fp¹²[w] = Fp⁶/w²-v\n\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { bls } from \"./abstract/bls.js\";\nimport { Field } from \"./abstract/modular.js\";\nimport { psiFrobenius, tower12 } from \"./abstract/tower.js\";\nimport { weierstrass } from \"./abstract/weierstrass.js\";\nimport { bitLen, notImplemented } from \"./utils.js\";\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _3n = BigInt(3);\nconst _6n = BigInt(6);\nconst BN_X = BigInt('4965661367192848881');\nconst BN_X_LEN = bitLen(BN_X);\nconst SIX_X_SQUARED = _6n * BN_X ** _2n;\nconst bn254_G1_CURVE = {\n  p: BigInt('0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47'),\n  n: BigInt('0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001'),\n  h: _1n,\n  a: _0n,\n  b: _3n,\n  Gx: _1n,\n  Gy: BigInt(2)\n};\n// r == n\n// Finite field over r. It's for convenience and is not used in the code below.\nexport const bn254_Fr = Field(bn254_G1_CURVE.n);\n// Fp2.div(Fp2.mul(Fp2.ONE, _3n), Fp2.NONRESIDUE)\nconst Fp2B = {\n  c0: BigInt('19485874751759354771024239261021720505790618469301721065564631296452457478373'),\n  c1: BigInt('266929791119991161246907387137283842545076965332900288569378510910307636690')\n};\nconst {\n  Fp,\n  Fp2,\n  Fp6,\n  Fp12\n} = tower12({\n  ORDER: bn254_G1_CURVE.p,\n  X_LEN: BN_X_LEN,\n  FP2_NONRESIDUE: [BigInt(9), _1n],\n  Fp2mulByB: num => Fp2.mul(num, Fp2B),\n  Fp12finalExponentiate: num => {\n    const powMinusX = num => Fp12.conjugate(Fp12._cyclotomicExp(num, BN_X));\n    const r0 = Fp12.mul(Fp12.conjugate(num), Fp12.inv(num));\n    const r = Fp12.mul(Fp12.frobeniusMap(r0, 2), r0);\n    const y1 = Fp12._cyclotomicSquare(powMinusX(r));\n    const y2 = Fp12.mul(Fp12._cyclotomicSquare(y1), y1);\n    const y4 = powMinusX(y2);\n    const y6 = powMinusX(Fp12._cyclotomicSquare(y4));\n    const y8 = Fp12.mul(Fp12.mul(Fp12.conjugate(y6), y4), Fp12.conjugate(y2));\n    const y9 = Fp12.mul(y8, y1);\n    return Fp12.mul(Fp12.frobeniusMap(Fp12.mul(Fp12.conjugate(r), y9), 3), Fp12.mul(Fp12.frobeniusMap(y8, 2), Fp12.mul(Fp12.frobeniusMap(y9, 1), Fp12.mul(Fp12.mul(y8, y4), r))));\n  }\n});\n// END OF CURVE FIELDS\nconst {\n  G2psi,\n  psi\n} = psiFrobenius(Fp, Fp2, Fp2.NONRESIDUE);\n/*\nNo hashToCurve for now (and signatures):\n\n- RFC 9380 doesn't mention bn254 and doesn't provide test vectors\n- Overall seems like nobody is using BLS signatures on top of bn254\n- Seems like it can utilize SVDW, which is not implemented yet\n*/\nconst htfDefaults = Object.freeze({\n  // DST: a domain separation tag defined in section 2.2.5\n  DST: 'BN254G2_XMD:SHA-256_SVDW_RO_',\n  encodeDST: 'BN254G2_XMD:SHA-256_SVDW_RO_',\n  p: Fp.ORDER,\n  m: 2,\n  k: 128,\n  expand: 'xmd',\n  hash: sha256\n});\nexport const _postPrecompute = (Rx, Ry, Rz, Qx, Qy, pointAdd) => {\n  const q = psi(Qx, Qy);\n  ({\n    Rx,\n    Ry,\n    Rz\n  } = pointAdd(Rx, Ry, Rz, q[0], q[1]));\n  const q2 = psi(q[0], q[1]);\n  pointAdd(Rx, Ry, Rz, q2[0], Fp2.neg(q2[1]));\n};\n// cofactor: (36 * X^4) + (36 * X^3) + (30 * X^2) + 6*X + 1\nconst bn254_G2_CURVE = {\n  p: Fp2.ORDER,\n  n: bn254_G1_CURVE.n,\n  h: BigInt('0x30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d'),\n  a: Fp2.ZERO,\n  b: Fp2B,\n  Gx: Fp2.fromBigTuple([BigInt('10857046999023057135944570762232829481370756359578518086990519993285655852781'), BigInt('11559732032986387107991004021392285783925812861821192530917403151452391805634')]),\n  Gy: Fp2.fromBigTuple([BigInt('8495653923123431417604973247489272438418190587263600148770280649306958101930'), BigInt('4082367875863433681332203403145435568316851327593401208105741076214120093531')])\n};\n/**\n * bn254 (a.k.a. alt_bn128) pairing-friendly curve.\n * Contains G1 / G2 operations and pairings.\n */\nexport const bn254 = bls({\n  // Fields\n  fields: {\n    Fp,\n    Fp2,\n    Fp6,\n    Fp12,\n    Fr: bn254_Fr\n  },\n  G1: {\n    ...bn254_G1_CURVE,\n    Fp,\n    htfDefaults: {\n      ...htfDefaults,\n      m: 1,\n      DST: 'BN254G2_XMD:SHA-256_SVDW_RO_'\n    },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    mapToCurve: notImplemented,\n    fromBytes: notImplemented,\n    toBytes: notImplemented,\n    ShortSignature: {\n      fromBytes: notImplemented,\n      fromHex: notImplemented,\n      toBytes: notImplemented,\n      toRawBytes: notImplemented,\n      toHex: notImplemented\n    }\n  },\n  G2: {\n    ...bn254_G2_CURVE,\n    Fp: Fp2,\n    hEff: BigInt('21888242871839275222246405745257275088844257914179612981679871602714643921549'),\n    htfDefaults: {\n      ...htfDefaults\n    },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    isTorsionFree: (c, P) => P.multiplyUnsafe(SIX_X_SQUARED).equals(G2psi(c, P)),\n    // [p]P = [6X^2]P\n    mapToCurve: notImplemented,\n    fromBytes: notImplemented,\n    toBytes: notImplemented,\n    Signature: {\n      fromBytes: notImplemented,\n      fromHex: notImplemented,\n      toBytes: notImplemented,\n      toRawBytes: notImplemented,\n      toHex: notImplemented\n    }\n  },\n  params: {\n    ateLoopSize: BN_X * _6n + _2n,\n    r: bn254_Fr.ORDER,\n    xNegative: false,\n    twistType: 'divisive'\n  },\n  htfDefaults,\n  hash: sha256,\n  postPrecompute: _postPrecompute\n});\n/**\n * bn254 weierstrass curve with ECDSA.\n * This is very rare and probably not used anywhere.\n * Instead, you should use G1 / G2, defined above.\n * @deprecated\n */\nexport const bn254_weierstrass = weierstrass({\n  a: BigInt(0),\n  b: BigInt(3),\n  Fp,\n  n: BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617'),\n  Gx: BigInt(1),\n  Gy: BigInt(2),\n  h: BigInt(1),\n  hash: sha256\n});","map":{"version":3,"names":["sha256","bls","Field","psiFrobenius","tower12","weierstrass","bitLen","notImplemented","_0n","BigInt","_1n","_2n","_3n","_6n","BN_X","BN_X_LEN","SIX_X_SQUARED","bn254_G1_CURVE","p","n","h","a","b","Gx","Gy","bn254_Fr","Fp2B","c0","c1","Fp","Fp2","Fp6","Fp12","ORDER","X_LEN","FP2_NONRESIDUE","Fp2mulByB","num","mul","Fp12finalExponentiate","powMinusX","conjugate","_cyclotomicExp","r0","inv","r","frobeniusMap","y1","_cyclotomicSquare","y2","y4","y6","y8","y9","G2psi","psi","NONRESIDUE","htfDefaults","Object","freeze","DST","encodeDST","m","k","expand","hash","_postPrecompute","Rx","Ry","Rz","Qx","Qy","pointAdd","q","q2","neg","bn254_G2_CURVE","ZERO","fromBigTuple","bn254","fields","Fr","G1","wrapPrivateKey","allowInfinityPoint","mapToCurve","fromBytes","toBytes","ShortSignature","fromHex","toRawBytes","toHex","G2","hEff","isTorsionFree","c","P","multiplyUnsafe","equals","Signature","params","ateLoopSize","xNegative","twistType","postPrecompute","bn254_weierstrass"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@noble\\curves\\src\\bn254.ts"],"sourcesContent":["/**\n * bn254, previously known as alt_bn_128, when it had 128-bit security.\n\nBarbulescu-Duquesne 2017 shown it's weaker: just about 100 bits,\nso the naming has been adjusted to its prime bit count:\nhttps://hal.science/hal-01534101/file/main.pdf.\nCompatible with EIP-196 and EIP-197.\n\nThere are huge compatibility issues in the ecosystem:\n\n1. Different libraries call it in different ways: \"bn254\", \"bn256\", \"alt_bn128\", \"bn128\".\n2. libff has bn128, but it's a different curve with different G2:\n   https://github.com/scipr-lab/libff/blob/a44f482e18b8ac04d034c193bd9d7df7817ad73f/libff/algebra/curves/bn128/bn128_init.cpp#L166-L169\n3. halo2curves bn256 is also incompatible and returns different outputs\n\nWe don't implement Point methods toHex / toBytes.\nTo work around this limitation, has to initialize points on their own from BigInts.\nReason it's not implemented is because [there is no standard](https://github.com/privacy-scaling-explorations/halo2curves/issues/109).\nPoints of divergence:\n\n- Endianness: LE vs BE (byte-swapped)\n- Flags as first hex bits (similar to BLS) vs no-flags\n- Imaginary part last in G2 vs first (c0, c1 vs c1, c0)\n\nThe goal of our implementation is to support \"Ethereum\" variant of the curve,\nbecause it at least has specs:\n\n- EIP196 (https://eips.ethereum.org/EIPS/eip-196) describes bn254 ECADD and ECMUL opcodes for EVM\n- EIP197 (https://eips.ethereum.org/EIPS/eip-197) describes bn254 pairings\n- It's hard: EIPs don't have proper tests. EIP-197 returns boolean output instead of Fp12\n- The existing implementations are bad. Some are deprecated:\n    - https://github.com/paritytech/bn (old version)\n    - https://github.com/ewasm/ethereum-bn128.rs (uses paritytech/bn)\n    - https://github.com/zcash-hackworks/bn\n    - https://github.com/arkworks-rs/curves/blob/master/bn254/src/lib.rs\n- Python implementations use different towers and produce different Fp12 outputs:\n    - https://github.com/ethereum/py_pairing\n    - https://github.com/ethereum/execution-specs/blob/master/src/ethereum/crypto/alt_bn128.py\n- Points are encoded differently in different implementations\n\n### Params\nSeed (X): 4965661367192848881\nFr: (36x⁴+36x³+18x²+6x+1)\nFp: (36x⁴+36x³+24x²+6x+1)\n(E  / Fp ): Y² = X³+3\n(Et / Fp²): Y² = X³+3/(u+9) (D-type twist)\nAte loop size: 6x+2\n\n### Towers\n- Fp²[u] = Fp/u²+1\n- Fp⁶[v] = Fp²/v³-9-u\n- Fp¹²[w] = Fp⁶/w²-v\n\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport {\n  bls,\n  type CurveFn as BLSCurveFn,\n  type PostPrecomputeFn,\n  type PostPrecomputePointAddFn,\n} from './abstract/bls.ts';\nimport { Field, type IField } from './abstract/modular.ts';\nimport type { Fp, Fp12, Fp2, Fp6 } from './abstract/tower.ts';\nimport { psiFrobenius, tower12 } from './abstract/tower.ts';\nimport { type CurveFn, weierstrass, type WeierstrassOpts } from './abstract/weierstrass.ts';\nimport { bitLen, notImplemented } from './utils.ts';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\nconst _6n = BigInt(6);\n\nconst BN_X = BigInt('4965661367192848881');\nconst BN_X_LEN = bitLen(BN_X);\nconst SIX_X_SQUARED = _6n * BN_X ** _2n;\n\nconst bn254_G1_CURVE: WeierstrassOpts<bigint> = {\n  p: BigInt('0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47'),\n  n: BigInt('0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001'),\n  h: _1n,\n  a: _0n,\n  b: _3n,\n  Gx: _1n,\n  Gy: BigInt(2),\n};\n\n// r == n\n// Finite field over r. It's for convenience and is not used in the code below.\nexport const bn254_Fr: IField<bigint> = Field(bn254_G1_CURVE.n);\n\n// Fp2.div(Fp2.mul(Fp2.ONE, _3n), Fp2.NONRESIDUE)\nconst Fp2B = {\n  c0: BigInt('19485874751759354771024239261021720505790618469301721065564631296452457478373'),\n  c1: BigInt('266929791119991161246907387137283842545076965332900288569378510910307636690'),\n};\n\nconst { Fp, Fp2, Fp6, Fp12 } = tower12({\n  ORDER: bn254_G1_CURVE.p,\n  X_LEN: BN_X_LEN,\n  FP2_NONRESIDUE: [BigInt(9), _1n],\n  Fp2mulByB: (num) => Fp2.mul(num, Fp2B),\n  Fp12finalExponentiate: (num) => {\n    const powMinusX = (num: Fp12) => Fp12.conjugate(Fp12._cyclotomicExp(num, BN_X));\n    const r0 = Fp12.mul(Fp12.conjugate(num), Fp12.inv(num));\n    const r = Fp12.mul(Fp12.frobeniusMap(r0, 2), r0);\n    const y1 = Fp12._cyclotomicSquare(powMinusX(r));\n    const y2 = Fp12.mul(Fp12._cyclotomicSquare(y1), y1);\n    const y4 = powMinusX(y2);\n    const y6 = powMinusX(Fp12._cyclotomicSquare(y4));\n    const y8 = Fp12.mul(Fp12.mul(Fp12.conjugate(y6), y4), Fp12.conjugate(y2));\n    const y9 = Fp12.mul(y8, y1);\n    return Fp12.mul(\n      Fp12.frobeniusMap(Fp12.mul(Fp12.conjugate(r), y9), 3),\n      Fp12.mul(\n        Fp12.frobeniusMap(y8, 2),\n        Fp12.mul(Fp12.frobeniusMap(y9, 1), Fp12.mul(Fp12.mul(y8, y4), r))\n      )\n    );\n  },\n});\n\n// END OF CURVE FIELDS\nconst { G2psi, psi } = psiFrobenius(Fp, Fp2, Fp2.NONRESIDUE);\n\n/*\nNo hashToCurve for now (and signatures):\n\n- RFC 9380 doesn't mention bn254 and doesn't provide test vectors\n- Overall seems like nobody is using BLS signatures on top of bn254\n- Seems like it can utilize SVDW, which is not implemented yet\n*/\nconst htfDefaults = Object.freeze({\n  // DST: a domain separation tag defined in section 2.2.5\n  DST: 'BN254G2_XMD:SHA-256_SVDW_RO_',\n  encodeDST: 'BN254G2_XMD:SHA-256_SVDW_RO_',\n  p: Fp.ORDER,\n  m: 2,\n  k: 128,\n  expand: 'xmd',\n  hash: sha256,\n});\n\nexport const _postPrecompute: PostPrecomputeFn = (\n  Rx: Fp2,\n  Ry: Fp2,\n  Rz: Fp2,\n  Qx: Fp2,\n  Qy: Fp2,\n  pointAdd: PostPrecomputePointAddFn\n) => {\n  const q = psi(Qx, Qy);\n  ({ Rx, Ry, Rz } = pointAdd(Rx, Ry, Rz, q[0], q[1]));\n  const q2 = psi(q[0], q[1]);\n  pointAdd(Rx, Ry, Rz, q2[0], Fp2.neg(q2[1]));\n};\n\n// cofactor: (36 * X^4) + (36 * X^3) + (30 * X^2) + 6*X + 1\nconst bn254_G2_CURVE: WeierstrassOpts<Fp2> = {\n  p: Fp2.ORDER,\n  n: bn254_G1_CURVE.n,\n  h: BigInt('0x30644e72e131a029b85045b68181585e06ceecda572a2489345f2299c0f9fa8d'),\n  a: Fp2.ZERO,\n  b: Fp2B,\n  Gx: Fp2.fromBigTuple([\n    BigInt('10857046999023057135944570762232829481370756359578518086990519993285655852781'),\n    BigInt('11559732032986387107991004021392285783925812861821192530917403151452391805634'),\n  ]),\n  Gy: Fp2.fromBigTuple([\n    BigInt('8495653923123431417604973247489272438418190587263600148770280649306958101930'),\n    BigInt('4082367875863433681332203403145435568316851327593401208105741076214120093531'),\n  ]),\n};\n\n/**\n * bn254 (a.k.a. alt_bn128) pairing-friendly curve.\n * Contains G1 / G2 operations and pairings.\n */\nexport const bn254: BLSCurveFn = bls({\n  // Fields\n  fields: { Fp, Fp2, Fp6, Fp12, Fr: bn254_Fr },\n  G1: {\n    ...bn254_G1_CURVE,\n    Fp,\n    htfDefaults: { ...htfDefaults, m: 1, DST: 'BN254G2_XMD:SHA-256_SVDW_RO_' },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    mapToCurve: notImplemented,\n    fromBytes: notImplemented,\n    toBytes: notImplemented,\n    ShortSignature: {\n      fromBytes: notImplemented,\n      fromHex: notImplemented,\n      toBytes: notImplemented,\n      toRawBytes: notImplemented,\n      toHex: notImplemented,\n    },\n  },\n  G2: {\n    ...bn254_G2_CURVE,\n    Fp: Fp2,\n    hEff: BigInt('21888242871839275222246405745257275088844257914179612981679871602714643921549'),\n    htfDefaults: { ...htfDefaults },\n    wrapPrivateKey: true,\n    allowInfinityPoint: true,\n    isTorsionFree: (c, P) => P.multiplyUnsafe(SIX_X_SQUARED).equals(G2psi(c, P)), // [p]P = [6X^2]P\n    mapToCurve: notImplemented,\n    fromBytes: notImplemented,\n    toBytes: notImplemented,\n    Signature: {\n      fromBytes: notImplemented,\n      fromHex: notImplemented,\n      toBytes: notImplemented,\n      toRawBytes: notImplemented,\n      toHex: notImplemented,\n    },\n  },\n  params: {\n    ateLoopSize: BN_X * _6n + _2n,\n    r: bn254_Fr.ORDER,\n    xNegative: false,\n    twistType: 'divisive',\n  },\n  htfDefaults,\n  hash: sha256,\n  postPrecompute: _postPrecompute,\n});\n\n/**\n * bn254 weierstrass curve with ECDSA.\n * This is very rare and probably not used anywhere.\n * Instead, you should use G1 / G2, defined above.\n * @deprecated\n */\nexport const bn254_weierstrass: CurveFn = weierstrass({\n  a: BigInt(0),\n  b: BigInt(3),\n  Fp,\n  n: BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617'),\n  Gx: BigInt(1),\n  Gy: BigInt(2),\n  h: BigInt(1),\n  hash: sha256,\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}