{"ast":null,"code":"import { b as c } from \"./chunk-GYVSI3TS.mjs\";\nimport { a as o } from \"./chunk-NJN3EAOM.mjs\";\nimport { b as n } from \"./chunk-STY74NUA.mjs\";\nimport { sha3_256 as d } from \"@noble/hashes/sha3\";\nvar r = class r extends o {\n  constructor(t) {\n    super();\n    let {\n        data: e\n      } = t,\n      i = n.fromHexInput(e);\n    if (i.toUint8Array().length !== r.LENGTH) throw new Error(`Authentication Key length should be ${r.LENGTH}`);\n    this.data = i;\n  }\n  serialize(t) {\n    t.serializeFixedBytes(this.data.toUint8Array());\n  }\n  static deserialize(t) {\n    let e = t.deserializeFixedBytes(r.LENGTH);\n    return new r({\n      data: e\n    });\n  }\n  toUint8Array() {\n    return this.data.toUint8Array();\n  }\n  static fromSchemeAndBytes(t) {\n    let {\n        scheme: e,\n        input: i\n      } = t,\n      u = n.fromHexInput(i).toUint8Array(),\n      h = new Uint8Array([...u, e]),\n      a = d.create();\n    a.update(h);\n    let y = a.digest();\n    return new r({\n      data: y\n    });\n  }\n  static fromPublicKeyAndScheme(t) {\n    let {\n      publicKey: e\n    } = t;\n    return e.authKey();\n  }\n  static fromPublicKey(t) {\n    let {\n      publicKey: e\n    } = t;\n    return e.authKey();\n  }\n  derivedAddress() {\n    return new c(this.data.toUint8Array());\n  }\n};\nr.LENGTH = 32;\nvar s = r;\nexport { s as a };","map":{"version":3,"names":["sha3_256","d","r","o","constructor","t","data","e","i","n","fromHexInput","toUint8Array","length","LENGTH","Error","serialize","serializeFixedBytes","deserialize","deserializeFixedBytes","fromSchemeAndBytes","scheme","input","u","h","Uint8Array","a","create","update","y","digest","fromPublicKeyAndScheme","publicKey","authKey","fromPublicKey","derivedAddress","c","s"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-standard\\node_modules\\@aptos-labs\\ts-sdk\\src\\core\\authenticationKey.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { sha3_256 as sha3Hash } from \"@noble/hashes/sha3\";\nimport { AccountAddress } from \"./accountAddress\";\nimport type { AccountPublicKey } from \"./crypto\";\nimport { Hex } from \"./hex\";\nimport { AuthenticationKeyScheme, HexInput } from \"../types\";\nimport { Serializable, Serializer } from \"../bcs/serializer\";\nimport { Deserializer } from \"../bcs/deserializer\";\n\n/**\n * Represents an authentication key used for account management. Each account stores an authentication key that enables account\n * owners to rotate their private key(s) without changing the address that hosts their account. The authentication key is a\n * SHA3-256 hash of data and is always 32 bytes in length.\n *\n * @see {@link https://aptos.dev/concepts/accounts | Account Basics}\n *\n * Account addresses can be derived from the AuthenticationKey.\n * @group Implementation\n * @category Serialization\n */\nexport class AuthenticationKey extends Serializable {\n  /**\n   * An authentication key is always a SHA3-256 hash of data, and is always 32 bytes.\n   *\n   * The data to hash depends on the underlying public key type and the derivation scheme.\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The raw bytes of the authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly data: Hex;\n\n  /**\n   * Creates an instance of the AuthenticationKey using the provided hex input.\n   * This ensures that the hex input is valid and conforms to the required length for an Authentication Key.\n   *\n   * @param args - The arguments for constructing the AuthenticationKey.\n   * @param args.data - The hex input data to be used for the Authentication Key.\n   * @throws {Error} Throws an error if the length of the provided hex input is not equal to the required Authentication Key\n   * length.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(args: { data: HexInput }) {\n    super();\n    const { data } = args;\n    const hex = Hex.fromHexInput(data);\n    if (hex.toUint8Array().length !== AuthenticationKey.LENGTH) {\n      throw new Error(`Authentication Key length should be ${AuthenticationKey.LENGTH}`);\n    }\n    this.data = hex;\n  }\n\n  /**\n   * Serializes the fixed bytes data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data.toUint8Array());\n  }\n\n  /**\n   * Deserialize an AuthenticationKey from the byte buffer in a Deserializer instance.\n   * @param deserializer - The deserializer to deserialize the AuthenticationKey from.\n   * @returns An instance of AuthenticationKey.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): AuthenticationKey {\n    const bytes = deserializer.deserializeFixedBytes(AuthenticationKey.LENGTH);\n    return new AuthenticationKey({ data: bytes });\n  }\n\n  /**\n   * Convert the internal data representation to a Uint8Array.\n   *\n   * This function is useful for obtaining a byte representation of the data, which can be utilized for serialization or transmission.\n   *\n   * @returns Uint8Array representation of the internal data.\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  /**\n   * Generates an AuthenticationKey from the specified scheme and input bytes.\n   * This function is essential for creating a valid authentication key based on a given scheme.\n   *\n   * @param args - The arguments for generating the AuthenticationKey.\n   * @param args.scheme - The authentication key scheme to use.\n   * @param args.input - The input data in hexadecimal format to derive the key.\n   * @returns An instance of AuthenticationKey containing the generated key data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromSchemeAndBytes(args: { scheme: AuthenticationKeyScheme; input: HexInput }): AuthenticationKey {\n    const { scheme, input } = args;\n    const inputBytes = Hex.fromHexInput(input).toUint8Array();\n    const hashInput = new Uint8Array([...inputBytes, scheme]);\n    const hash = sha3Hash.create();\n    hash.update(hashInput);\n    const hashDigest = hash.digest();\n    return new AuthenticationKey({ data: hashDigest });\n  }\n\n  /**\n   * Derives an AuthenticationKey from the provided public key using a specified derivation scheme.\n   *\n   * @deprecated Use `fromPublicKey` instead.\n   * @param args - The arguments for deriving the authentication key.\n   * @param args.publicKey - The public key used for the derivation.\n   * @param args.scheme - The scheme to use for deriving the authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  public static fromPublicKeyAndScheme(args: { publicKey: AccountPublicKey; scheme: AuthenticationKeyScheme }) {\n    const { publicKey } = args;\n    return publicKey.authKey();\n  }\n\n  /**\n   * Converts a PublicKey to an AuthenticationKey using the derivation scheme inferred from the provided PublicKey instance.\n   *\n   * @param args - The arguments for the function.\n   * @param args.publicKey - The PublicKey to be converted.\n   * @returns AuthenticationKey - The derived AuthenticationKey.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromPublicKey(args: { publicKey: AccountPublicKey }): AuthenticationKey {\n    const { publicKey } = args;\n    return publicKey.authKey();\n  }\n\n  /**\n   * Derives an account address from an AuthenticationKey by translating the AuthenticationKey bytes directly to an AccountAddress.\n   *\n   * @returns AccountAddress - The derived account address.\n   * @group Implementation\n   * @category Serialization\n   */\n  derivedAddress(): AccountAddress {\n    return new AccountAddress(this.data.toUint8Array());\n  }\n}\n"],"mappings":";;;AAGA,SAASA,QAAA,IAAYC,CAAA,QAAgB;AAmB9B,IAAMC,CAAA,GAAN,MAAMA,CAAA,SAA0BC,CAAa;EA4BlDC,YAAYC,CAAA,EAA0B;IACpC,MAAM;IACN,IAAM;QAAEC,IAAA,EAAAC;MAAK,IAAIF,CAAA;MACXG,CAAA,GAAMC,CAAA,CAAIC,YAAA,CAAaH,CAAI;IACjC,IAAIC,CAAA,CAAIG,YAAA,CAAa,EAAEC,MAAA,KAAWV,CAAA,CAAkBW,MAAA,EAClD,MAAM,IAAIC,KAAA,CAAM,uCAAuCZ,CAAA,CAAkBW,MAAM,EAAE;IAEnF,KAAKP,IAAA,GAAOE,CACd;EAAA;EASAO,UAAUV,CAAA,EAA8B;IACtCA,CAAA,CAAWW,mBAAA,CAAoB,KAAKV,IAAA,CAAKK,YAAA,CAAa,CAAC,CACzD;EAAA;EASA,OAAOM,YAAYZ,CAAA,EAA+C;IAChE,IAAME,CAAA,GAAQF,CAAA,CAAaa,qBAAA,CAAsBhB,CAAA,CAAkBW,MAAM;IACzE,OAAO,IAAIX,CAAA,CAAkB;MAAEI,IAAA,EAAMC;IAAM,CAAC,CAC9C;EAAA;EAWAI,aAAA,EAA2B;IACzB,OAAO,KAAKL,IAAA,CAAKK,YAAA,CAAa,CAChC;EAAA;EAaA,OAAOQ,mBAAmBd,CAAA,EAA+E;IACvG,IAAM;QAAEe,MAAA,EAAAb,CAAA;QAAQc,KAAA,EAAAb;MAAM,IAAIH,CAAA;MACpBiB,CAAA,GAAab,CAAA,CAAIC,YAAA,CAAaF,CAAK,EAAEG,YAAA,CAAa;MAClDY,CAAA,GAAY,IAAIC,UAAA,CAAW,CAAC,GAAGF,CAAA,EAAYf,CAAM,CAAC;MAClDkB,CAAA,GAAOxB,CAAA,CAASyB,MAAA,CAAO;IAC7BD,CAAA,CAAKE,MAAA,CAAOJ,CAAS;IACrB,IAAMK,CAAA,GAAaH,CAAA,CAAKI,MAAA,CAAO;IAC/B,OAAO,IAAI3B,CAAA,CAAkB;MAAEI,IAAA,EAAMsB;IAAW,CAAC,CACnD;EAAA;EAYA,OAAcE,uBAAuBzB,CAAA,EAAwE;IAC3G,IAAM;MAAE0B,SAAA,EAAAxB;IAAU,IAAIF,CAAA;IACtB,OAAOE,CAAA,CAAUyB,OAAA,CAAQ,CAC3B;EAAA;EAWA,OAAOC,cAAc5B,CAAA,EAA0D;IAC7E,IAAM;MAAE0B,SAAA,EAAAxB;IAAU,IAAIF,CAAA;IACtB,OAAOE,CAAA,CAAUyB,OAAA,CAAQ,CAC3B;EAAA;EASAE,eAAA,EAAiC;IAC/B,OAAO,IAAIC,CAAA,CAAe,KAAK7B,IAAA,CAAKK,YAAA,CAAa,CAAC,CACpD;EAAA;AACF;AAtIaT,CAAA,CAQKW,MAAA,GAAiB;AAR5B,IAAMuB,CAAA,GAANlC,CAAA;AAAA,SAAAkC,CAAA,IAAAX,CAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}