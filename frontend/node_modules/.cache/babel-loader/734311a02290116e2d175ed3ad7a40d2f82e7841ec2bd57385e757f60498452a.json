{"ast":null,"code":"import { a as i } from \"./chunk-IF4UU2MT.mjs\";\nimport { bytesToHex as o, hexToBytes as s } from \"@noble/hashes/utils\";\nvar u = (n => (n.TOO_SHORT = \"too_short\", n.INVALID_LENGTH = \"invalid_length\", n.INVALID_HEX_CHARS = \"invalid_hex_chars\", n))(u || {}),\n  a = class e {\n    constructor(t) {\n      this.data = t;\n    }\n    toUint8Array() {\n      return this.data;\n    }\n    toStringWithoutPrefix() {\n      return o(this.data);\n    }\n    toString() {\n      return `0x${this.toStringWithoutPrefix()}`;\n    }\n    static fromHexString(t) {\n      let r = t;\n      if (r.startsWith(\"0x\") && (r = r.slice(2)), r.length === 0) throw new i(\"Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.\", \"too_short\");\n      if (r.length % 2 !== 0) throw new i(\"Hex string must be an even number of hex characters.\", \"invalid_length\");\n      try {\n        return new e(s(r));\n      } catch (n) {\n        throw new i(`Hex string contains invalid hex characters: ${n?.message}`, \"invalid_hex_chars\");\n      }\n    }\n    static fromHexInput(t) {\n      return t instanceof Uint8Array ? new e(t) : e.fromHexString(t);\n    }\n    static hexInputToUint8Array(t) {\n      return t instanceof Uint8Array ? t : e.fromHexString(t).toUint8Array();\n    }\n    static hexInputToString(t) {\n      return e.fromHexInput(t).toString();\n    }\n    static hexInputToStringWithoutPrefix(t) {\n      return e.fromHexInput(t).toStringWithoutPrefix();\n    }\n    static isValid(t) {\n      try {\n        return e.fromHexString(t), {\n          valid: !0\n        };\n      } catch (r) {\n        return {\n          valid: !1,\n          invalidReason: r?.invalidReason,\n          invalidReasonMessage: r?.message\n        };\n      }\n    }\n    equals(t) {\n      return this.data.length !== t.data.length ? !1 : this.data.every((r, n) => r === t.data[n]);\n    }\n  },\n  l = e => new TextDecoder().decode(a.fromHexInput(e).toUint8Array());\nexport { u as a, a as b, l as c };","map":{"version":3,"names":["bytesToHex","o","hexToBytes","s","u","n","TOO_SHORT","INVALID_LENGTH","INVALID_HEX_CHARS","a","e","constructor","t","data","toUint8Array","toStringWithoutPrefix","toString","fromHexString","r","startsWith","slice","length","i","message","fromHexInput","Uint8Array","hexInputToUint8Array","hexInputToString","hexInputToStringWithoutPrefix","isValid","valid","invalidReason","invalidReasonMessage","equals","every","l","TextDecoder","decode","b","c"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-standard\\node_modules\\@aptos-labs\\ts-sdk\\src\\core\\hex.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\nimport { ParsingError, ParsingResult } from \"./common\";\nimport { HexInput } from \"../types\";\n\n/**\n * Provides reasons for parsing failures related to hexadecimal values.\n * @group Implementation\n * @category Serialization\n */\nexport enum HexInvalidReason {\n  TOO_SHORT = \"too_short\",\n  INVALID_LENGTH = \"invalid_length\",\n  INVALID_HEX_CHARS = \"invalid_hex_chars\",\n}\n\n/**\n * NOTE: Do not use this class when working with account addresses; use AccountAddress instead.\n * When accepting hex data as input to a function, prefer to accept HexInput and\n *\n * A helper class for working with hex data. Hex data, when represented as a string,\n * generally looks like this, for example: 0xaabbcc, 45cd32, etc.\n *\n * then use the static helper methods of this class to convert it into the desired\n * format. This enables the greatest flexibility for the developer.\n *\n * Example usage:\n * ```typescript\n * getTransactionByHash(txnHash: HexInput): Promise<Transaction> {\n *   const txnHashString = Hex.fromHexInput(txnHash).toString();\n *   return await getTransactionByHashInner(txnHashString);\n * }\n * ```\n * This call to `Hex.fromHexInput().toString()` converts the HexInput to a hex string\n * with a leading 0x prefix, regardless of what the input format was.\n *\n * Other ways to chain the functions together:\n * - `Hex.fromHexString({ hexInput: \"0x1f\" }).toUint8Array()`\n * - `new Hex([1, 3]).toStringWithoutPrefix()`\n * @group Implementation\n * @category Serialization\n */\nexport class Hex {\n  private readonly data: Uint8Array;\n\n  /**\n   * Create a new Hex instance from a Uint8Array.\n   *\n   * @param data - The Uint8Array containing the data to initialize the Hex instance.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(data: Uint8Array) {\n    this.data = data;\n  }\n\n  // ===\n  // Methods for representing an instance of Hex as other types.\n  // ===\n\n  /**\n   * Get the inner hex data as a Uint8Array. The inner data is already a Uint8Array, so no conversion takes place.\n   *\n   * @returns Hex data as Uint8Array\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.data;\n  }\n\n  /**\n   * Get the hex data as a string without the 0x prefix.\n   *\n   * @returns Hex string without 0x prefix\n   * @group Implementation\n   * @category Serialization\n   */\n  toStringWithoutPrefix(): string {\n    return bytesToHex(this.data);\n  }\n\n  /**\n   * Get the hex data as a string with the 0x prefix.\n   *\n   * @returns Hex string with 0x prefix\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): string {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n\n  // ===\n  // Methods for creating an instance of Hex from other types.\n  // ===\n\n  /**\n   * Converts a hex string into a Hex instance, allowing for both prefixed and non-prefixed formats.\n   *\n   * @param str - A hex string, with or without the 0x prefix.\n   *\n   * @throws ParsingError - If the hex string is too short, has an odd number of characters, or contains invalid hex characters.\n   *\n   * @returns Hex - The resulting Hex instance created from the provided string.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromHexString(str: string): Hex {\n    let input = str;\n\n    if (input.startsWith(\"0x\")) {\n      input = input.slice(2);\n    }\n\n    if (input.length === 0) {\n      throw new ParsingError(\n        \"Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.\",\n        HexInvalidReason.TOO_SHORT,\n      );\n    }\n\n    if (input.length % 2 !== 0) {\n      throw new ParsingError(\"Hex string must be an even number of hex characters.\", HexInvalidReason.INVALID_LENGTH);\n    }\n\n    try {\n      return new Hex(hexToBytes(input));\n    } catch (error: any) {\n      throw new ParsingError(\n        `Hex string contains invalid hex characters: ${error?.message}`,\n        HexInvalidReason.INVALID_HEX_CHARS,\n      );\n    }\n  }\n\n  /**\n   * Converts an instance of HexInput, which can be a string or a Uint8Array, into a Hex instance.\n   * This function is useful for transforming hexadecimal representations into a structured Hex object for further manipulation.\n   *\n   * @param hexInput - A HexInput which can be a string or Uint8Array.\n   * @returns A Hex instance created from the provided hexInput.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromHexInput(hexInput: HexInput): Hex {\n    if (hexInput instanceof Uint8Array) return new Hex(hexInput);\n    return Hex.fromHexString(hexInput);\n  }\n\n  /**\n   * Converts an instance of HexInput, which can be a string or a Uint8Array, into a Uint8Array.\n   *\n   * @param hexInput - A HexInput which can be a string or Uint8Array.\n   * @returns A Uint8Array created from the provided hexInput.\n   */\n  static hexInputToUint8Array(hexInput: HexInput): Uint8Array {\n    if (hexInput instanceof Uint8Array) return hexInput;\n    return Hex.fromHexString(hexInput).toUint8Array();\n  }\n\n  /**\n   * Converts a HexInput (string or Uint8Array) to a hex string with '0x' prefix.\n   *\n   * @param hexInput - The input to convert, either a hex string (with/without '0x' prefix) or Uint8Array\n   * @returns A hex string with '0x' prefix (e.g., \"0x1234\")\n   *\n   * @example\n   * ```typescript\n   * Hex.hexInputToString(\"1234\")        // returns \"0x1234\"\n   * Hex.hexInputToString(\"0x1234\")      // returns \"0x1234\"\n   * Hex.hexInputToString(new Uint8Array([0x12, 0x34])) // returns \"0x1234\"\n   * ```\n   */\n  static hexInputToString(hexInput: HexInput): string {\n    return Hex.fromHexInput(hexInput).toString();\n  }\n\n  /**\n   * Converts a HexInput (string or Uint8Array) to a hex string without '0x' prefix.\n   *\n   * @param hexInput - The input to convert, either a hex string (with/without '0x' prefix) or Uint8Array\n   * @returns A hex string without '0x' prefix (e.g., \"1234\")\n   *\n   * @example\n   * ```typescript\n   * Hex.hexInputToStringWithoutPrefix(\"1234\")        // returns \"1234\"\n   * Hex.hexInputToStringWithoutPrefix(\"0x1234\")      // returns \"1234\"\n   * Hex.hexInputToStringWithoutPrefix(new Uint8Array([0x12, 0x34])) // returns \"1234\"\n   * ```\n   */\n  static hexInputToStringWithoutPrefix(hexInput: HexInput): string {\n    return Hex.fromHexInput(hexInput).toStringWithoutPrefix();\n  }\n\n  // ===\n  // Methods for checking validity.\n  // ===\n\n  /**\n   * Check if the provided string is a valid hexadecimal representation.\n   *\n   * @param str - A hex string representing byte data.\n   *\n   * @returns An object containing:\n   *  - valid: A boolean indicating whether the string is valid.\n   *  - invalidReason: The reason for invalidity if the string is not valid.\n   *  - invalidReasonMessage: A message explaining why the string is invalid.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isValid(str: string): ParsingResult<HexInvalidReason> {\n    try {\n      Hex.fromHexString(str);\n      return { valid: true };\n    } catch (error: any) {\n      return {\n        valid: false,\n        invalidReason: error?.invalidReason,\n        invalidReasonMessage: error?.message,\n      };\n    }\n  }\n\n  /**\n   * Determine if two Hex instances are equal by comparing their underlying byte data.\n   *\n   * @param other The Hex instance to compare to.\n   * @returns true if the Hex instances are equal, false if not.\n   * @group Implementation\n   * @category Serialization\n   */\n  equals(other: Hex): boolean {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n}\n\nexport const hexToAsciiString = (hex: string) => new TextDecoder().decode(Hex.fromHexInput(hex).toUint8Array());\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}