{"ast":null,"code":"import { a as c } from \"./chunk-EBMEXURY.mjs\";\nimport { a as i } from \"./chunk-IF4UU2MT.mjs\";\nimport { bytesToHex as a, hexToBytes as g } from \"@noble/hashes/utils\";\nvar u = (s => (s.INCORRECT_NUMBER_OF_BYTES = \"incorrect_number_of_bytes\", s.INVALID_HEX_CHARS = \"invalid_hex_chars\", s.TOO_SHORT = \"too_short\", s.TOO_LONG = \"too_long\", s.LEADING_ZERO_X_REQUIRED = \"leading_zero_x_required\", s.LONG_FORM_REQUIRED_UNLESS_SPECIAL = \"long_form_required_unless_special\", s.INVALID_PADDING_ZEROES = \"INVALID_PADDING_ZEROES\", s.INVALID_PADDING_STRICTNESS = \"INVALID_PADDING_STRICTNESS\", s))(u || {}),\n  e = class e extends c {\n    constructor(t) {\n      if (super(), t.length !== e.LENGTH) throw new i(\"AccountAddress data should be exactly 32 bytes long\", \"incorrect_number_of_bytes\");\n      this.data = t;\n    }\n    isSpecial() {\n      return this.data.slice(0, this.data.length - 1).every(t => t === 0) && this.data[this.data.length - 1] < 16;\n    }\n    toString() {\n      return `0x${this.toStringWithoutPrefix()}`;\n    }\n    toStringWithoutPrefix() {\n      let t = a(this.data);\n      return this.isSpecial() && (t = t[t.length - 1]), t;\n    }\n    toStringLong() {\n      return `0x${this.toStringLongWithoutPrefix()}`;\n    }\n    toStringLongWithoutPrefix() {\n      return a(this.data);\n    }\n    toStringShort() {\n      return `0x${this.toStringShortWithoutPrefix()}`;\n    }\n    toStringShortWithoutPrefix() {\n      let t = a(this.data).replace(/^0+/, \"\");\n      return t === \"\" ? \"0\" : t;\n    }\n    toUint8Array() {\n      return this.data;\n    }\n    serialize(t) {\n      t.serializeFixedBytes(this.data);\n    }\n    serializeForEntryFunction(t) {\n      let r = this.bcsToBytes();\n      t.serializeBytes(r);\n    }\n    serializeForScriptFunction(t) {\n      t.serializeU32AsUleb128(3), t.serialize(this);\n    }\n    static deserialize(t) {\n      let r = t.deserializeFixedBytes(e.LENGTH);\n      return new e(r);\n    }\n    static fromStringStrict(t) {\n      if (!t.startsWith(\"0x\")) throw new i(\"Hex string must start with a leading 0x.\", \"leading_zero_x_required\");\n      let r = e.fromString(t);\n      if (t.length !== e.LONG_STRING_LENGTH + 2) if (r.isSpecial()) {\n        if (t.length !== 3) throw new i(`The given hex string ${t} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`, \"INVALID_PADDING_ZEROES\");\n      } else throw new i(`The given hex string ${t} is not a special address, it must be represented as 0x + 64 chars.`, \"long_form_required_unless_special\");\n      return r;\n    }\n    static fromString(t, {\n      maxMissingChars: r = 4\n    } = {}) {\n      let n = t;\n      if (t.startsWith(\"0x\") && (n = t.slice(2)), n.length === 0) throw new i(\"Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.\", \"too_short\");\n      if (n.length > 64) throw new i(\"Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.\", \"too_long\");\n      if (r > 63 || r < 0) throw new i(`maxMissingChars must be between or equal to 0 and 63. Received ${r}`, \"INVALID_PADDING_STRICTNESS\");\n      let o;\n      try {\n        o = g(n.padStart(64, \"0\"));\n      } catch (h) {\n        throw new i(`Hex characters are invalid: ${h?.message}`, \"invalid_hex_chars\");\n      }\n      let d = new e(o);\n      if (n.length < 64 - r && !d.isSpecial()) throw new i(`Hex string is too short, must be ${64 - r} to 64 chars long, excluding the leading 0x. You may need to fix \nthe addresss by padding it with 0s before passing it to \\`fromString\\` (e.g. <addressString>.padStart(64, '0')). \nReceived ${t}`, \"too_short\");\n      return d;\n    }\n    static from(t, {\n      maxMissingChars: r = 4\n    } = {}) {\n      return typeof t == \"string\" ? e.fromString(t, {\n        maxMissingChars: r\n      }) : t instanceof Uint8Array ? new e(t) : t;\n    }\n    static fromStrict(t) {\n      return typeof t == \"string\" ? e.fromStringStrict(t) : t instanceof Uint8Array ? new e(t) : t;\n    }\n    static isValid(t) {\n      try {\n        return t.strict ? e.fromStrict(t.input) : e.from(t.input), {\n          valid: !0\n        };\n      } catch (r) {\n        return {\n          valid: !1,\n          invalidReason: r?.invalidReason,\n          invalidReasonMessage: r?.message\n        };\n      }\n    }\n    equals(t) {\n      return this.data.length !== t.data.length ? !1 : this.data.every((r, n) => r === t.data[n]);\n    }\n  };\ne.LENGTH = 32, e.LONG_STRING_LENGTH = 64, e.ZERO = e.from(\"0x0\"), e.ONE = e.from(\"0x1\"), e.TWO = e.from(\"0x2\"), e.THREE = e.from(\"0x3\"), e.FOUR = e.from(\"0x4\"), e.A = e.from(\"0xA\");\nvar l = e;\nexport { u as a, l as b };","map":{"version":3,"names":["bytesToHex","a","hexToBytes","g","u","s","INCORRECT_NUMBER_OF_BYTES","INVALID_HEX_CHARS","TOO_SHORT","TOO_LONG","LEADING_ZERO_X_REQUIRED","LONG_FORM_REQUIRED_UNLESS_SPECIAL","INVALID_PADDING_ZEROES","INVALID_PADDING_STRICTNESS","e","c","constructor","t","length","LENGTH","i","data","isSpecial","slice","every","toString","toStringWithoutPrefix","toStringLong","toStringLongWithoutPrefix","toStringShort","toStringShortWithoutPrefix","replace","toUint8Array","serialize","serializeFixedBytes","serializeForEntryFunction","r","bcsToBytes","serializeBytes","serializeForScriptFunction","serializeU32AsUleb128","deserialize","deserializeFixedBytes","fromStringStrict","startsWith","fromString","LONG_STRING_LENGTH","maxMissingChars","n","o","padStart","h","message","d","from","Uint8Array","fromStrict","isValid","strict","input","valid","invalidReason","invalidReasonMessage","equals","ZERO","ONE","TWO","THREE","FOUR","A","l","b"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\ts-sdk\\src\\core\\accountAddress.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { bytesToHex, hexToBytes } from \"@noble/hashes/utils\";\nimport { Serializable, Serializer } from \"../bcs/serializer\";\nimport { Deserializer } from \"../bcs/deserializer\";\nimport { ParsingError, ParsingResult } from \"./common\";\nimport { TransactionArgument } from \"../transactions/instances/transactionArgument\";\nimport { HexInput, ScriptTransactionArgumentVariants } from \"../types\";\n\n/**\n * Provides reasons for an address was invalid.\n * @group Implementation\n * @category Serialization\n */\nexport enum AddressInvalidReason {\n  INCORRECT_NUMBER_OF_BYTES = \"incorrect_number_of_bytes\",\n  INVALID_HEX_CHARS = \"invalid_hex_chars\",\n  TOO_SHORT = \"too_short\",\n  TOO_LONG = \"too_long\",\n  LEADING_ZERO_X_REQUIRED = \"leading_zero_x_required\",\n  LONG_FORM_REQUIRED_UNLESS_SPECIAL = \"long_form_required_unless_special\",\n  INVALID_PADDING_ZEROES = \"INVALID_PADDING_ZEROES\",\n  INVALID_PADDING_STRICTNESS = \"INVALID_PADDING_STRICTNESS\",\n}\n\n/**\n * The input for an account address, which can be either a hexadecimal string or a standard account address.\n * @group Implementation\n * @category Serialization\n */\nexport type AccountAddressInput = HexInput | AccountAddress;\n\n/**\n * NOTE: Only use this class for account addresses. For other hex data, e.g. transaction\n * hashes, use the Hex class.\n *\n * AccountAddress is used for working with account addresses. Account addresses, when\n * represented as a string, generally look like these examples:\n * - 0x1\n * - 0xaa86fe99004361f747f91342ca13c426ca0cccb0c1217677180c9493bad6ef0c\n *\n * Proper formatting and parsing of account addresses is defined by AIP-40.\n * To learn more about the standard, read the AIP here:\n * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n *\n * The comments in this class make frequent reference to the LONG and SHORT formats,\n * as well as \"special\" addresses. To learn what these refer to see AIP-40.\n * @group Implementation\n * @category Serialization\n */\nexport class AccountAddress extends Serializable implements TransactionArgument {\n  /**\n   * This is the internal representation of an account address.\n   * @group Implementation\n   * @category Serialization\n   */\n  readonly data: Uint8Array;\n\n  /**\n   * The number of bytes that make up an account address.\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The length of an address string in LONG form without a leading 0x.\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LONG_STRING_LENGTH: number = 64;\n\n  static ZERO: AccountAddress = AccountAddress.from(\"0x0\");\n\n  static ONE: AccountAddress = AccountAddress.from(\"0x1\");\n\n  static TWO: AccountAddress = AccountAddress.from(\"0x2\");\n\n  static THREE: AccountAddress = AccountAddress.from(\"0x3\");\n\n  static FOUR: AccountAddress = AccountAddress.from(\"0x4\");\n\n  static A: AccountAddress = AccountAddress.from(\"0xA\");\n\n  /**\n   * Creates an instance of AccountAddress from a Uint8Array.\n   *\n   * This function ensures that the input data is exactly 32 bytes long, which is required for a valid account address.\n   *\n   * @param input A Uint8Array representing an account address.\n   * @throws ParsingError if the input length is not equal to 32 bytes.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(input: Uint8Array) {\n    super();\n    if (input.length !== AccountAddress.LENGTH) {\n      throw new ParsingError(\n        \"AccountAddress data should be exactly 32 bytes long\",\n        AddressInvalidReason.INCORRECT_NUMBER_OF_BYTES,\n      );\n    }\n    this.data = input;\n  }\n\n  /**\n   * Determines if the address is classified as special, which is defined as 0x0 to 0xf inclusive.\n   * In other words, the last byte of the address must be < 0b10000 (16)\n   * and every other byte must be zero.\n   *\n   * For more information on how special addresses are defined, see AIP-40:\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * @returns true if the address is special, false otherwise.\n   * @group Implementation\n   * @category Serialization\n   */\n  isSpecial(): boolean {\n    return (\n      this.data.slice(0, this.data.length - 1).every((byte) => byte === 0) && this.data[this.data.length - 1] < 0b10000\n    );\n  }\n  // ===\n  // Methods for representing an instance of AccountAddress as other types.\n  // ===\n\n  /**\n   * Return the AccountAddress as a string as per AIP-40.\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   * This representation returns special addresses in SHORT form (0xf)\n   * and other addresses in LONG form (0x + 64 characters).\n   *\n   * @returns AccountAddress as a string conforming to AIP-40.\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): `0x${string}` {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n\n  /**\n   * Return the AccountAddress as a string conforming to AIP-40 but without the leading 0x.\n   *\n   * NOTE: Prefer to use `toString` where possible.\n   *\n   * @returns AccountAddress as a string without the leading 0x.\n   * @group Implementation\n   * @category Serialization\n   */\n  toStringWithoutPrefix(): string {\n    let hex = bytesToHex(this.data);\n    if (this.isSpecial()) {\n      hex = hex[hex.length - 1];\n    }\n    return hex;\n  }\n\n  /**\n   * Convert the account address to a string in LONG format, which is always 0x followed by 64 hex characters.\n   *\n   * NOTE: Prefer to use `toString` where possible, as it formats special addresses using the SHORT form (no leading 0s).\n   *\n   * @returns AccountAddress as a string in LONG form.\n   * @group Implementation\n   * @category Serialization\n   */\n  toStringLong(): `0x${string}` {\n    return `0x${this.toStringLongWithoutPrefix()}`;\n  }\n\n  /**\n   * Returns the account address as a string in LONG form without a leading 0x.\n   * This function will include leading zeroes and will produce a string of 64 hex characters.\n   *\n   * NOTE: Prefer to use `toString` where possible, as it formats special addresses using the SHORT form (no leading 0s).\n   *\n   * @returns {string} The account address in LONG form.\n   * @group Implementation\n   * @category Serialization\n   */\n  toStringLongWithoutPrefix(): string {\n    return bytesToHex(this.data);\n  }\n\n  /**\n   * Convert the account address to a string in SHORT format, which is 0x followed by the shortest\n   * possible representation (no leading zeros).\n   *\n   * @returns AccountAddress as a string in SHORT form.\n   * @group Implementation\n   * @category Serialization\n   */\n  toStringShort(): `0x${string}` {\n    return `0x${this.toStringShortWithoutPrefix()}`;\n  }\n\n  /**\n   * Returns a lossless short string representation of the address by trimming leading zeros.\n   * If the address consists of all zeros, returns \"0\".\n   *\n   * @returns A string representation of the address without leading zeros\n   * @group Implementation\n   * @category Serialization\n   */\n  toStringShortWithoutPrefix(): string {\n    const hex = bytesToHex(this.data).replace(/^0+/, \"\");\n    return hex === \"\" ? \"0\" : hex;\n  }\n\n  /**\n   * Get the inner data as a Uint8Array.\n   * The inner data is already a Uint8Array, so no conversion takes place.\n   *\n   * @returns Hex data as Uint8Array\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.data;\n  }\n\n  /**\n   * Serialize the AccountAddress to a Serializer instance's data buffer.\n   * @param serializer The serializer to serialize the AccountAddress to.\n   * @returns void\n   * @example\n   * const serializer = new Serializer();\n   * const address = AccountAddress.fromString(\"0x1\");\n   * address.serialize(serializer);\n   * const bytes = serializer.toUint8Array();\n   * // `bytes` is now the BCS-serialized address.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data);\n  }\n\n  /**\n   * Serializes the current instance into a byte sequence suitable for entry functions.\n   * This allows for the proper encoding of data when interacting with entry functions in the blockchain.\n   *\n   * @param serializer - The serializer instance used to convert the data into bytes.\n   * @group Implementation\n   * @category Serialization\n   */\n  serializeForEntryFunction(serializer: Serializer): void {\n    const bcsBytes = this.bcsToBytes();\n    serializer.serializeBytes(bcsBytes);\n  }\n\n  /**\n   * Serializes the current instance for use in a script function by encoding it into a byte sequence.\n   * This process involves serializing the variant index and the instance data, making it suitable for transmission.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Serialization\n   */\n  serializeForScriptFunction(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(ScriptTransactionArgumentVariants.Address);\n    serializer.serialize(this);\n  }\n\n  /**\n   * Deserialize an AccountAddress from the byte buffer in a Deserializer instance.\n   * This function allows you to convert a byte representation of an AccountAddress into an instance of AccountAddress.\n   * @param deserializer The deserializer to deserialize the AccountAddress from.\n   * @returns An instance of AccountAddress.\n   * @example\n   * const bytes = hexToBytes(\"0x0102030405060708091011121314151617181920212223242526272829303132\");\n   * const deserializer = new Deserializer(bytes);\n   * const address = AccountAddress.deserialize(deserializer);\n   * // `address` is now an instance of AccountAddress.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): AccountAddress {\n    const bytes = deserializer.deserializeFixedBytes(AccountAddress.LENGTH);\n    return new AccountAddress(bytes);\n  }\n\n  // ===\n  // Methods for creating an instance of AccountAddress from other types.\n  // ===\n\n  /**\n   * NOTE: This function has strict parsing behavior. For relaxed behavior, please use\n   * the `fromString` function.\n   *\n   * Creates an instance of AccountAddress from a hex string.\n   *\n   * This function allows only the strictest formats defined by AIP-40. In short this\n   * means only the following formats are accepted:\n   *\n   * - LONG\n   * - SHORT for special addresses\n   *\n   * Where:\n   * - LONG is defined as 0x + 64 hex characters.\n   * - SHORT for special addresses is 0x0 to 0xf inclusive without padding zeroes.\n   *\n   * This means the following are not accepted:\n   * - SHORT for non-special addresses.\n   * - Any address without a leading 0x.\n   *\n   * @param input - A hex string representing an account address.\n   *\n   * @throws {ParsingError} If the hex string does not start with 0x or is not in a valid format.\n   *\n   * @remarks\n   *\n   * This function has strict parsing behavior. For relaxed behavior, please use the `fromString` function.\n   *\n   * @see AIP-40 documentation for more details on address formats:\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * @returns An instance of AccountAddress.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromStringStrict(input: string): AccountAddress {\n    // Assert the string starts with 0x.\n    if (!input.startsWith(\"0x\")) {\n      throw new ParsingError(\"Hex string must start with a leading 0x.\", AddressInvalidReason.LEADING_ZERO_X_REQUIRED);\n    }\n\n    const address = AccountAddress.fromString(input);\n\n    // Check if the address is in LONG form. If it is not, this is only allowed for\n    // special addresses, in which case we check it is in proper SHORT form.\n    if (input.length !== AccountAddress.LONG_STRING_LENGTH + 2) {\n      if (!address.isSpecial()) {\n        throw new ParsingError(\n          `The given hex string ${input} is not a special address, it must be represented as 0x + 64 chars.`,\n          AddressInvalidReason.LONG_FORM_REQUIRED_UNLESS_SPECIAL,\n        );\n      } else if (input.length !== 3) {\n        // 0x + one hex char is the only valid SHORT form for special addresses.\n        throw new ParsingError(\n          // eslint-disable-next-line max-len\n          `The given hex string ${input} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`,\n          AddressInvalidReason.INVALID_PADDING_ZEROES,\n        );\n      }\n    }\n\n    return address;\n  }\n\n  /**\n   * NOTE: This function has relaxed parsing behavior. For strict behavior, please use\n   * the `fromStringStrict` function. Where possible use `fromStringStrict` rather than this\n   * function, `fromString`.\n   *\n   * Creates an instance of AccountAddress from a hex string.\n   *\n   * This function allows all formats defined by AIP-40. In short this means the\n   * following formats are accepted:\n   *\n   * - LONG, with or without leading 0x\n   * - SHORT*, with or without leading 0x\n   *\n   * Where:\n   * - LONG is 64 hex characters.\n   * - SHORT* is 1 to 63 hex characters inclusive. The address can have missing values up to `maxMissingChars` before it is padded.\n   * - Padding zeroes are allowed, e.g. 0x0123 is valid.\n   *\n   * Learn more about the different address formats by reading AIP-40:\n   * https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-40.md.\n   *\n   * @param input A hex string representing an account address.\n   * @param args.maxMissingChars The number of characters that can be missing in a padded address before it is invalid.\n   *\n   * @returns An instance of AccountAddress.\n   *\n   * @throws ParsingError if the hex string is too short, too long, or contains invalid characters.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromString(input: string, { maxMissingChars = 4 }: { maxMissingChars?: number } = {}): AccountAddress {\n    let parsedInput = input;\n    // Remove leading 0x for parsing.\n    if (input.startsWith(\"0x\")) {\n      parsedInput = input.slice(2);\n    }\n\n    // Ensure the address string is at least 1 character long.\n    if (parsedInput.length === 0) {\n      throw new ParsingError(\n        \"Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.\",\n        AddressInvalidReason.TOO_SHORT,\n      );\n    }\n\n    // Ensure the address string is not longer than 64 characters.\n    if (parsedInput.length > 64) {\n      throw new ParsingError(\n        \"Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.\",\n        AddressInvalidReason.TOO_LONG,\n      );\n    }\n\n    // Ensure that the maxMissingChars is between or equal to 0 and 63.\n    if (maxMissingChars > 63 || maxMissingChars < 0) {\n      throw new ParsingError(\n        `maxMissingChars must be between or equal to 0 and 63. Received ${maxMissingChars}`,\n        AddressInvalidReason.INVALID_PADDING_STRICTNESS,\n      );\n    }\n\n    let addressBytes: Uint8Array;\n    try {\n      // Pad the address with leading zeroes, so it is 64 chars long and then convert\n      // the hex string to bytes. Every two characters in a hex string constitutes a\n      // single byte. So a 64 length hex string becomes a 32 byte array.\n      addressBytes = hexToBytes(parsedInput.padStart(64, \"0\"));\n    } catch (error: any) {\n      // At this point the only way this can fail is if the hex string contains\n      // invalid characters.\n      throw new ParsingError(`Hex characters are invalid: ${error?.message}`, AddressInvalidReason.INVALID_HEX_CHARS);\n    }\n\n    const address = new AccountAddress(addressBytes);\n\n    // Cannot pad the address if it has more than maxMissingChars missing.\n    if (parsedInput.length < 64 - maxMissingChars) {\n      if (!address.isSpecial()) {\n        throw new ParsingError(\n          `Hex string is too short, must be ${64 - maxMissingChars} to 64 chars long, excluding the leading 0x. You may need to fix \nthe addresss by padding it with 0s before passing it to \\`fromString\\` (e.g. <addressString>.padStart(64, '0')). \nReceived ${input}`,\n          AddressInvalidReason.TOO_SHORT,\n        );\n      }\n    }\n\n    return address;\n  }\n\n  /**\n   * Convenience method for creating an AccountAddress from various input types.\n   * This function accepts a string, Uint8Array, or an existing AccountAddress instance and returns the corresponding\n   * AccountAddress.\n   *\n   * @param input - The input to convert into an AccountAddress. This can be a string representation of an address, a Uint8Array,\n   * or an existing AccountAddress.\n   * @param args.maxMissingChars The number of characters that can be missing in a padded address before it is invalid.\n   * @group Implementation\n   * @category Serialization\n   */\n  static from(input: AccountAddressInput, { maxMissingChars = 4 }: { maxMissingChars?: number } = {}): AccountAddress {\n    if (typeof input === \"string\") {\n      return AccountAddress.fromString(input, { maxMissingChars });\n    }\n    if (input instanceof Uint8Array) {\n      return new AccountAddress(input);\n    }\n    return input;\n  }\n\n  /**\n   * Create an AccountAddress from various input types, including strings, Uint8Array, and AccountAddress instances.\n   *\n   * @param input - The input to convert into an AccountAddress, which can be a string, a Uint8Array, or an AccountAddress.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromStrict(input: AccountAddressInput): AccountAddress {\n    if (typeof input === \"string\") {\n      return AccountAddress.fromStringStrict(input);\n    }\n    if (input instanceof Uint8Array) {\n      return new AccountAddress(input);\n    }\n    return input;\n  }\n  // ===\n  // Methods for checking validity.\n  // ===\n\n  /**\n   * Check if the provided input is a valid AccountAddress.\n   *\n   * @param args - The arguments for validation.\n   * @param args.input - A hex string representing an account address.\n   * @param args.strict - If true, use strict parsing behavior; if false, use relaxed parsing behavior.\n   *\n   * @returns An object indicating whether the address is valid. If valid, valid = true; if not, valid = false with additional details.\n   * If the address is invalid, invalidReason will explain why it is invalid, and invalidReasonMessage will provide the error message.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isValid(args: { input: AccountAddressInput; strict?: boolean }): ParsingResult<AddressInvalidReason> {\n    try {\n      if (args.strict) {\n        AccountAddress.fromStrict(args.input);\n      } else {\n        AccountAddress.from(args.input);\n      }\n      return { valid: true };\n    } catch (error: any) {\n      return {\n        valid: false,\n        invalidReason: error?.invalidReason,\n        invalidReasonMessage: error?.message,\n      };\n    }\n  }\n\n  /**\n   * Determine if two AccountAddresses are equal based on their underlying byte data.\n   *\n   * @param other - The AccountAddress to compare to.\n   * @returns true if the AccountAddresses are equal, false if not.\n   * @group Implementation\n   * @category Serialization\n   */\n  equals(other: AccountAddress): boolean {\n    if (this.data.length !== other.data.length) return false;\n    return this.data.every((value, index) => value === other.data[index]);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}