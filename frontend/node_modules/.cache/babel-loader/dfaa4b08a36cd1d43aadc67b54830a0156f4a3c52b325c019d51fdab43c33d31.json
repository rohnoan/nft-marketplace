{"ast":null,"code":"import { a as u } from \"./chunk-ROT6S6BM.mjs\";\nimport { a as p } from \"./chunk-DPW6ELCQ.mjs\";\nimport { e as d, j as S } from \"./chunk-C3Q23D22.mjs\";\nimport { a as f } from \"./chunk-BYINW7I2.mjs\";\nimport { a as h } from \"./chunk-Z6KQX6VX.mjs\";\nimport { a as g } from \"./chunk-NJN3EAOM.mjs\";\nimport { b as s } from \"./chunk-STY74NUA.mjs\";\nimport { sha3_256 as H } from \"@noble/hashes/sha3\";\nimport { secp256k1 as y } from \"@noble/curves/secp256k1\";\nimport { HDKey as A } from \"@scure/bip32\";\nvar i = class i extends f {\n  constructor(e) {\n    super();\n    let t = s.fromHexInput(e),\n      {\n        length: r\n      } = t.toUint8Array();\n    if (r === i.LENGTH) this.key = t;else if (r === i.COMPRESSED_LENGTH) {\n      let o = y.ProjectivePoint.fromHex(t.toUint8Array());\n      this.key = s.fromHexInput(o.toRawBytes(!1));\n    } else throw new Error(`PublicKey length should be ${i.LENGTH} or ${i.COMPRESSED_LENGTH}, received ${r}`);\n  }\n  verifySignature(e) {\n    let {\n        message: t,\n        signature: r\n      } = e,\n      o = p(t),\n      c = s.fromHexInput(o).toUint8Array(),\n      x = H(c),\n      P = r.toUint8Array();\n    return y.verify(P, x, this.key.toUint8Array(), {\n      lowS: !0\n    });\n  }\n  async verifySignatureAsync(e) {\n    return this.verifySignature(e);\n  }\n  toUint8Array() {\n    return this.key.toUint8Array();\n  }\n  serialize(e) {\n    e.serializeBytes(this.key.toUint8Array());\n  }\n  deserialize(e) {\n    let t = e.deserializeBytes();\n    return new l(t);\n  }\n  static deserialize(e) {\n    let t = e.deserializeBytes();\n    return new i(t);\n  }\n  static isPublicKey(e) {\n    return e instanceof i;\n  }\n  static isInstance(e) {\n    return \"key\" in e && e.key?.data?.length === i.LENGTH;\n  }\n};\ni.LENGTH = 65, i.COMPRESSED_LENGTH = 33;\nvar m = i,\n  n = class n extends g {\n    constructor(e, t) {\n      super();\n      let r = u.parseHexInput(e, \"secp256k1\", t);\n      if (r.toUint8Array().length !== n.LENGTH) throw new Error(`PrivateKey length should be ${n.LENGTH}`);\n      this.key = r;\n    }\n    static generate() {\n      let e = y.utils.randomPrivateKey();\n      return new n(e, !1);\n    }\n    static fromDerivationPath(e, t) {\n      if (!d(e)) throw new Error(`Invalid derivation path ${e}`);\n      return n.fromDerivationPathInner(e, S(t));\n    }\n    static fromDerivationPathInner(e, t) {\n      let {\n        privateKey: r\n      } = A.fromMasterSeed(t).derive(e);\n      if (r === null) throw new Error(\"Invalid key\");\n      return new n(r, !1);\n    }\n    sign(e) {\n      let t = p(e),\n        r = s.fromHexInput(t),\n        o = H(r.toUint8Array()),\n        c = y.sign(o, this.key.toUint8Array(), {\n          lowS: !0\n        });\n      return new l(c.toCompactRawBytes());\n    }\n    publicKey() {\n      let e = y.getPublicKey(this.key.toUint8Array(), !1);\n      return new m(e);\n    }\n    toUint8Array() {\n      return this.key.toUint8Array();\n    }\n    toString() {\n      return this.toHexString();\n    }\n    toHexString() {\n      return this.key.toString();\n    }\n    toAIP80String() {\n      return u.formatPrivateKey(this.key.toString(), \"secp256k1\");\n    }\n    serialize(e) {\n      e.serializeBytes(this.toUint8Array());\n    }\n    static deserialize(e) {\n      let t = e.deserializeBytes();\n      return new n(t, !1);\n    }\n    static isPrivateKey(e) {\n      return e instanceof n;\n    }\n  };\nn.LENGTH = 32;\nvar v = n,\n  a = class a extends h {\n    constructor(e) {\n      super();\n      let t = s.fromHexInput(e);\n      if (t.toUint8Array().length !== a.LENGTH) throw new Error(`Signature length should be ${a.LENGTH}, received ${t.toUint8Array().length}`);\n      this.data = t;\n    }\n    toUint8Array() {\n      return this.data.toUint8Array();\n    }\n    serialize(e) {\n      e.serializeBytes(this.data.toUint8Array());\n    }\n    static deserialize(e) {\n      let t = e.deserializeBytes();\n      return new a(t);\n    }\n  };\na.LENGTH = 64;\nvar l = a;\nexport { m as a, v as b, l as c };","map":{"version":3,"names":["sha3_256","H","secp256k1","y","HDKey","A","i","f","constructor","e","t","s","fromHexInput","length","r","toUint8Array","LENGTH","key","COMPRESSED_LENGTH","o","ProjectivePoint","fromHex","toRawBytes","Error","verifySignature","message","signature","p","c","x","P","verify","lowS","verifySignatureAsync","serialize","serializeBytes","deserialize","deserializeBytes","l","isPublicKey","isInstance","data","m","n","g","u","parseHexInput","generate","utils","randomPrivateKey","fromDerivationPath","d","fromDerivationPathInner","S","privateKey","fromMasterSeed","derive","sign","toCompactRawBytes","publicKey","getPublicKey","toString","toHexString","toAIP80String","formatPrivateKey","isPrivateKey","v","a","h","b"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-standard\\node_modules\\@aptos-labs\\ts-sdk\\src\\core\\crypto\\secp256k1.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\nimport { HDKey } from \"@scure/bip32\";\nimport { Serializable, Deserializer, Serializer } from \"../../bcs\";\nimport { Hex } from \"../hex\";\nimport { HexInput, PrivateKeyVariants } from \"../../types\";\nimport { isValidBIP44Path, mnemonicToSeed } from \"./hdKey\";\nimport { PrivateKey } from \"./privateKey\";\nimport { PublicKey } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { convertSigningMessage } from \"./utils\";\nimport { AptosConfig } from \"../../api\";\n\n/**\n * Represents a Secp256k1 ECDSA public key.\n *\n * @extends PublicKey\n * @property LENGTH - The length of the Secp256k1 public key in bytes.\n * @group Implementation\n * @category Serialization\n */\nexport class Secp256k1PublicKey extends PublicKey {\n  // Secp256k1 ecdsa public keys contain a prefix indicating compression and two 32-byte coordinates.\n  static readonly LENGTH: number = 65;\n\n  // If it's compressed, it is only 33 bytes\n  static readonly COMPRESSED_LENGTH: number = 33;\n\n  // Hex value of the public key\n  private readonly key: Hex;\n\n  /**\n   * Create a new PublicKey instance from a HexInput, which can be a string or Uint8Array.\n   * This constructor validates the length of the provided signature data.\n   *\n   * @param hexInput - A HexInput (string or Uint8Array) representing the signature data.\n   * @throws Error if the length of the signature data is not equal to Secp256k1Signature.LENGTH.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    const { length } = hex.toUint8Array();\n    if (length === Secp256k1PublicKey.LENGTH) {\n      this.key = hex;\n    } else if (length === Secp256k1PublicKey.COMPRESSED_LENGTH) {\n      const point = secp256k1.ProjectivePoint.fromHex(hex.toUint8Array());\n      this.key = Hex.fromHexInput(point.toRawBytes(false));\n    } else {\n      throw new Error(\n        `PublicKey length should be ${Secp256k1PublicKey.LENGTH} or ${Secp256k1PublicKey.COMPRESSED_LENGTH}, received ${length}`,\n      );\n    }\n  }\n\n  // region PublicKey\n  /**\n   * Verifies a Secp256k1 signature against the public key.\n   *\n   * This function checks the validity of a signature for a given message, ensuring that the signature is canonical as a malleability check.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify against the public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: { message: HexInput; signature: Secp256k1Signature }): boolean {\n    const { message, signature } = args;\n    const messageToVerify = convertSigningMessage(message);\n    const messageBytes = Hex.fromHexInput(messageToVerify).toUint8Array();\n    const messageSha3Bytes = sha3_256(messageBytes);\n    const signatureBytes = signature.toUint8Array();\n    return secp256k1.verify(signatureBytes, messageSha3Bytes, this.key.toUint8Array(), { lowS: true });\n  }\n\n  /**\n   * Note: Secp256k1Signatures can be verified syncronously.\n   *\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.aptosConfig - The configuration object for connecting to the Aptos network\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify, which must be an instance of Secp256k1Signature.\n   * @returns A boolean indicating whether the signature is valid for the given message.\n   * @group Implementation\n   * @category Serialization\n   */\n  async verifySignatureAsync(args: {\n    aptosConfig: AptosConfig;\n    message: HexInput;\n    signature: Secp256k1Signature;\n  }): Promise<boolean> {\n    return this.verifySignature(args);\n  }\n\n  /**\n   * Get the data as a Uint8Array representation.\n   *\n   * @returns Uint8Array representation of the data.\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  /**\n   * Serializes the data into a byte array using the provided serializer.\n   * This function is essential for converting data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to convert the data.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n\n  /**\n   * Deserializes a Secp256k1Signature from the provided deserializer.\n   * This function allows you to reconstruct a Secp256k1Signature object from its serialized byte representation.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  // eslint-disable-next-line class-methods-use-this\n  deserialize(deserializer: Deserializer) {\n    const hex = deserializer.deserializeBytes();\n    return new Secp256k1Signature(hex);\n  }\n\n  static deserialize(deserializer: Deserializer): Secp256k1PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  // endregion\n\n  /**\n   * Determine if the provided public key is an instance of Secp256k1PublicKey.\n   *\n   * @deprecated use `instanceof Secp256k1PublicKey` instead\n   * @param publicKey - The public key to check.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPublicKey(publicKey: PublicKey): publicKey is Secp256k1PublicKey {\n    return publicKey instanceof Secp256k1PublicKey;\n  }\n\n  /**\n   * Determines if the provided public key is a valid instance of a Secp256k1 public key.\n   * This function checks for the presence of a \"key\" property and validates the length of the key data.\n   *\n   * @param publicKey - The public key to validate.\n   * @returns A boolean indicating whether the public key is a valid Secp256k1 public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isInstance(publicKey: PublicKey): publicKey is Secp256k1PublicKey {\n    return \"key\" in publicKey && (publicKey.key as any)?.data?.length === Secp256k1PublicKey.LENGTH;\n  }\n}\n\n/**\n * Represents a Secp256k1 ECDSA private key, providing functionality to create, sign messages,\n * derive public keys, and serialize/deserialize the key.\n * @group Implementation\n * @category Serialization\n */\nexport class Secp256k1PrivateKey extends Serializable implements PrivateKey {\n  /**\n   * Length of Secp256k1 ecdsa private key\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The private key bytes\n   * @private\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly key: Hex;\n\n  // region Constructors\n\n  /**\n   * Create a new PrivateKey instance from a Uint8Array or String.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   * @param strict If true, private key must AIP-80 compliant.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput, strict?: boolean) {\n    super();\n\n    const privateKeyHex = PrivateKey.parseHexInput(hexInput, PrivateKeyVariants.Secp256k1, strict);\n    if (privateKeyHex.toUint8Array().length !== Secp256k1PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${Secp256k1PrivateKey.LENGTH}`);\n    }\n\n    this.key = privateKeyHex;\n  }\n\n  /**\n   * Generate a new random private key.\n   *\n   * @returns Secp256k1PrivateKey - A newly generated Secp256k1 private key.\n   * @group Implementation\n   * @category Serialization\n   */\n  static generate(): Secp256k1PrivateKey {\n    const hexInput = secp256k1.utils.randomPrivateKey();\n    return new Secp256k1PrivateKey(hexInput, false);\n  }\n\n  /**\n   * Derives a private key from a mnemonic seed phrase using a specified BIP44 path.\n   *\n   * @param path - The BIP44 path to derive the key from.\n   * @param mnemonics - The mnemonic seed phrase used for key generation.\n   *\n   * @returns The generated private key.\n   *\n   * @throws Error if the provided path is not a valid BIP44 path.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromDerivationPath(path: string, mnemonics: string): Secp256k1PrivateKey {\n    if (!isValidBIP44Path(path)) {\n      throw new Error(`Invalid derivation path ${path}`);\n    }\n    return Secp256k1PrivateKey.fromDerivationPathInner(path, mnemonicToSeed(mnemonics));\n  }\n\n  /**\n   * Derives a private key from a specified BIP44 path using a given seed.\n   * This function is essential for generating keys that follow the hierarchical deterministic (HD) wallet structure.\n   *\n   * @param path - The BIP44 path used for key derivation.\n   * @param seed - The seed phrase created by the mnemonics, represented as a Uint8Array.\n   * @returns The generated private key as an instance of Secp256k1PrivateKey.\n   * @throws Error if the derived private key is invalid.\n   * @group Implementation\n   * @category Serialization\n   */\n  private static fromDerivationPathInner(path: string, seed: Uint8Array): Secp256k1PrivateKey {\n    const { privateKey } = HDKey.fromMasterSeed(seed).derive(path);\n    // library returns privateKey as Uint8Array | null\n    if (privateKey === null) {\n      throw new Error(\"Invalid key\");\n    }\n\n    return new Secp256k1PrivateKey(privateKey, false);\n  }\n\n  // endregion\n\n  // region PrivateKey\n\n  /**\n   * Sign the given message with the private key.\n   * This function generates a cryptographic signature for the provided message, ensuring the signature is canonical and non-malleable.\n   *\n   * @param message - A message in HexInput format to be signed.\n   * @returns Signature - The generated signature for the provided message.\n   * @group Implementation\n   * @category Serialization\n   */\n  sign(message: HexInput): Secp256k1Signature {\n    const messageToSign = convertSigningMessage(message);\n    const messageBytes = Hex.fromHexInput(messageToSign);\n    const messageHashBytes = sha3_256(messageBytes.toUint8Array());\n    const signature = secp256k1.sign(messageHashBytes, this.key.toUint8Array(), { lowS: true });\n    return new Secp256k1Signature(signature.toCompactRawBytes());\n  }\n\n  /**\n   * Derive the Secp256k1PublicKey from this private key.\n   *\n   * @returns Secp256k1PublicKey The derived public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  publicKey(): Secp256k1PublicKey {\n    const bytes = secp256k1.getPublicKey(this.key.toUint8Array(), false);\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   *\n   * @returns\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  /**\n   * Get the private key as a string representation.\n   *\n   * @returns string representation of the private key\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): string {\n    return this.toHexString();\n  }\n\n  /**\n   * Get the private key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the private key.\n   */\n  toHexString(): string {\n    return this.key.toString();\n  }\n\n  /**\n   * Get the private key as a AIP-80 compliant hex string.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @returns AIP-80 compliant string representation of the private key.\n   */\n  toAIP80String(): string {\n    return PrivateKey.formatPrivateKey(this.key.toString(), PrivateKeyVariants.Secp256k1);\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Secp256k1PrivateKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Secp256k1PrivateKey(bytes, false);\n  }\n\n  // endregion\n\n  /**\n   * Determines if the provided private key is an instance of Secp256k1PrivateKey.\n   *\n   * @param privateKey - The private key to be checked.\n   *\n   * @deprecated use `instanceof Secp256k1PrivateKey` instead\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPrivateKey(privateKey: PrivateKey): privateKey is Secp256k1PrivateKey {\n    return privateKey instanceof Secp256k1PrivateKey;\n  }\n}\n\n/**\n * Represents a signature of a message signed using a Secp256k1 ECDSA private key.\n *\n * @group Implementation\n * @category Serialization\n */\nexport class Secp256k1Signature extends Signature {\n  /**\n   * Secp256k1 ecdsa signatures are 256-bit.\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH = 64;\n\n  /**\n   * The signature bytes\n   * @private\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly data: Hex;\n\n  // region Constructors\n\n  /**\n   * Create a new Signature instance from a Uint8Array or String.\n   *\n   * @param hexInput A HexInput (string or Uint8Array)\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput) {\n    super();\n    const data = Hex.fromHexInput(hexInput);\n    if (data.toUint8Array().length !== Secp256k1Signature.LENGTH) {\n      throw new Error(\n        `Signature length should be ${Secp256k1Signature.LENGTH}, received ${data.toUint8Array().length}`,\n      );\n    }\n    this.data = data;\n  }\n\n  // endregion\n\n  // region Signature\n\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Secp256k1Signature {\n    const hex = deserializer.deserializeBytes();\n    return new Secp256k1Signature(hex);\n  }\n\n  // endregion\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}