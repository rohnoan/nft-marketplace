{"ast":null,"code":"import { b as r } from \"./chunk-STY74NUA.mjs\";\nvar a = class a {\n  static formatPrivateKey(i, n) {\n    let e = a.AIP80_PREFIXES[n],\n      t = i;\n    return typeof t == \"string\" && t.startsWith(e) && (t = t.split(\"-\")[2]), `${e}${r.fromHexInput(t).toString()}`;\n  }\n  static parseHexInput(i, n, e) {\n    let t,\n      p = a.AIP80_PREFIXES[n];\n    if (typeof i == \"string\") {\n      if (!e && !i.startsWith(p)) t = r.fromHexInput(i), e !== !1 && console.warn(\"[Aptos SDK] It is recommended that private keys are AIP-80 compliant (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md). You can fix the private key by formatting it with `PrivateKey.formatPrivateKey(privateKey: string, type: 'ed25519' | 'secp256k1'): string`.\");else if (i.startsWith(p)) t = r.fromHexString(i.split(\"-\")[2]);else throw e ? new Error(\"Invalid HexString input while parsing private key. Must AIP-80 compliant string.\") : new Error(\"Invalid HexString input while parsing private key.\");\n    } else t = r.fromHexInput(i);\n    return t;\n  }\n};\na.AIP80_PREFIXES = {\n  ed25519: \"ed25519-priv-\",\n  secp256k1: \"secp256k1-priv-\"\n};\nvar o = a;\nexport { o as a };","map":{"version":3,"names":["a","formatPrivateKey","i","n","e","AIP80_PREFIXES","t","startsWith","split","r","fromHexInput","toString","parseHexInput","p","console","warn","fromHexString","Error","ed25519","secp256k1","o"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\ts-sdk\\src\\core\\crypto\\privateKey.ts"],"sourcesContent":["/* eslint-disable max-len */\n\nimport { HexInput, PrivateKeyVariants } from \"../../types\";\nimport { Hex } from \"../hex\";\nimport { PublicKey } from \"./publicKey\";\nimport { Signature } from \"./signature\";\n\n/**\n * Represents a private key used for signing messages and deriving the associated public key.\n * @group Implementation\n * @category Serialization\n */\nexport interface PrivateKey {\n  /**\n   * Sign the given message with the private key to create a signature.\n   * @param message - The message to be signed, provided in HexInput format.\n   * @returns A Signature object representing the signed message.\n   * @group Implementation\n   * @category Serialization\n   */\n  sign(message: HexInput): Signature;\n\n  /**\n   * Derive the public key associated with the private key.\n   * @group Implementation\n   * @category Serialization\n   */\n  publicKey(): PublicKey;\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array;\n}\n\nexport class PrivateKey {\n  /**\n   * The AIP-80 compliant prefixes for each private key type. Append this to a private key's hex representation\n   * to get an AIP-80 compliant string.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   */\n  public static readonly AIP80_PREFIXES = {\n    [PrivateKeyVariants.Ed25519]: \"ed25519-priv-\",\n    [PrivateKeyVariants.Secp256k1]: \"secp256k1-priv-\",\n  };\n\n  /**\n   * Format a HexInput to an AIP-80 compliant string.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @param privateKey - The HexString or Uint8Array format of the private key.\n   * @param privateKeyType - The private key type\n   */\n  public static formatPrivateKey(privateKey: HexInput, type: PrivateKeyVariants): string {\n    const aip80Prefix = PrivateKey.AIP80_PREFIXES[type];\n\n    // Remove the prefix if it exists\n    let formattedPrivateKey = privateKey;\n    if (typeof formattedPrivateKey === \"string\" && formattedPrivateKey.startsWith(aip80Prefix)) {\n      // eslint-disable-next-line prefer-destructuring\n      formattedPrivateKey = formattedPrivateKey.split(\"-\")[2];\n    }\n\n    return `${aip80Prefix}${Hex.fromHexInput(formattedPrivateKey).toString()}`;\n  }\n\n  /**\n   * Parse a HexInput that may be a HexString, Uint8Array, or a AIP-80 compliant string to a Hex instance.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @param value - A HexString, Uint8Array, or a AIP-80 compliant string.\n   * @param privateKeyType - The private key type\n   * @param strict - If true, the value MUST be compliant with AIP-80.\n   */\n  public static parseHexInput(value: HexInput, type: PrivateKeyVariants, strict?: boolean): Hex {\n    let data: Hex;\n\n    const aip80Prefix = PrivateKey.AIP80_PREFIXES[type];\n    if (typeof value === \"string\") {\n      if (!strict && !value.startsWith(aip80Prefix)) {\n        // HexString input\n        data = Hex.fromHexInput(value);\n        // If the strictness is false, the user has opted into non-AIP-80 compliant private keys.\n        if (strict !== false) {\n          // eslint-disable-next-line no-console\n          console.warn(\n            \"[Aptos SDK] It is recommended that private keys are AIP-80 compliant (https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md). You can fix the private key by formatting it with `PrivateKey.formatPrivateKey(privateKey: string, type: 'ed25519' | 'secp256k1'): string`.\",\n          );\n        }\n      } else if (value.startsWith(aip80Prefix)) {\n        // AIP-80 Compliant String input\n        data = Hex.fromHexString(value.split(\"-\")[2]);\n      } else {\n        if (strict) {\n          // The value does not start with the AIP-80 prefix, and strict is true.\n          throw new Error(\"Invalid HexString input while parsing private key. Must AIP-80 compliant string.\");\n        }\n\n        // This condition should never be reached.\n        throw new Error(\"Invalid HexString input while parsing private key.\");\n      }\n    } else {\n      // The value is an Uint8Array\n      data = Hex.fromHexInput(value);\n    }\n\n    return data;\n  }\n}\n"],"mappings":";AAqCO,IAAMA,CAAA,GAAN,MAAMA,CAAW;EAoBtB,OAAcC,iBAAiBC,CAAA,EAAsBC,CAAA,EAAkC;IACrF,IAAMC,CAAA,GAAcJ,CAAA,CAAWK,cAAA,CAAeF,CAAI;MAG9CG,CAAA,GAAsBJ,CAAA;IAC1B,OAAI,OAAOI,CAAA,IAAwB,YAAYA,CAAA,CAAoBC,UAAA,CAAWH,CAAW,MAEvFE,CAAA,GAAsBA,CAAA,CAAoBE,KAAA,CAAM,GAAG,EAAE,CAAC,IAGjD,GAAGJ,CAAW,GAAGK,CAAA,CAAIC,YAAA,CAAaJ,CAAmB,EAAEK,QAAA,CAAS,CAAC,EAC1E;EAAA;EAWA,OAAcC,cAAcV,CAAA,EAAiBC,CAAA,EAA0BC,CAAA,EAAuB;IAC5F,IAAIE,CAAA;MAEEO,CAAA,GAAcb,CAAA,CAAWK,cAAA,CAAeF,CAAI;IAClD,IAAI,OAAOD,CAAA,IAAU;MACnB,IAAI,CAACE,CAAA,IAAU,CAACF,CAAA,CAAMK,UAAA,CAAWM,CAAW,GAE1CP,CAAA,GAAOG,CAAA,CAAIC,YAAA,CAAaR,CAAK,GAEzBE,CAAA,KAAW,MAEbU,OAAA,CAAQC,IAAA,CACN,uRACF,WAEOb,CAAA,CAAMK,UAAA,CAAWM,CAAW,GAErCP,CAAA,GAAOG,CAAA,CAAIO,aAAA,CAAcd,CAAA,CAAMM,KAAA,CAAM,GAAG,EAAE,CAAC,CAAC,OAE5C,MAAIJ,CAAA,GAEI,IAAIa,KAAA,CAAM,kFAAkF,IAI9F,IAAIA,KAAA,CAAM,oDAAoD;IAAA,OAItEX,CAAA,GAAOG,CAAA,CAAIC,YAAA,CAAaR,CAAK;IAG/B,OAAOI,CACT;EAAA;AACF;AA5EaN,CAAA,CAOYK,cAAA,GAAiB;EACrCa,OAAA,EAA6B;EAC7BC,SAAA,EAA+B;AAClC;AAVK,IAAMC,CAAA,GAANpB,CAAA;AAAA,SAAAoB,CAAA,IAAApB,CAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}