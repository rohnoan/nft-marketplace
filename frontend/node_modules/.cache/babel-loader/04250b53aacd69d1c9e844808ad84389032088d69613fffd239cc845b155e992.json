{"ast":null,"code":"import { poseidon1 as h, poseidon2 as u, poseidon3 as a, poseidon4 as l, poseidon5 as c, poseidon6 as d, poseidon7 as p, poseidon8 as f, poseidon9 as A, poseidon10 as U, poseidon11 as b, poseidon12 as w, poseidon13 as E, poseidon14 as I, poseidon15 as y, poseidon16 as B } from \"poseidon-lite\";\nvar i = [h, u, a, l, c, d, p, f, A, U, b, w, E, I, y, B],\n  g = 31,\n  m = 16,\n  s = (m - 1) * g;\nfunction C(n, t) {\n  let o = new TextEncoder().encode(n);\n  return $(o, t);\n}\nfunction $(n, t) {\n  if (n.length > t) throw new Error(`Inputted bytes of length ${n} is longer than ${t}`);\n  let r = _(n, t);\n  return M(r);\n}\nfunction T(n, t) {\n  if (n.length > t) throw new Error(`Input bytes of length ${n} is longer than ${t}`);\n  let r = k(n, t);\n  return P(r);\n}\nfunction _(n, t) {\n  if (n.length > t) throw new Error(`Input bytes of length ${n} is longer than ${t}`);\n  return T(n, t).concat([BigInt(n.length)]);\n}\nfunction P(n) {\n  if (n.length > s) throw new Error(`Can't pack more than ${s}.  Was given ${n.length} bytes`);\n  return L(n, g).map(t => N(t));\n}\nfunction L(n, t) {\n  let r = [];\n  for (let o = 0; o < n.length; o += t) r.push(n.subarray(o, o + t));\n  return r;\n}\nfunction N(n) {\n  let t = BigInt(0);\n  for (let r = n.length - 1; r >= 0; r -= 1) t = t << BigInt(8) | BigInt(n[r]);\n  return t;\n}\nfunction W(n, t) {\n  let r = BigInt(n),\n    o = new Uint8Array(t);\n  for (let e = 0; e < t; e += 1) o[e] = Number(r & BigInt(255)), r >>= BigInt(8);\n  return o;\n}\nfunction k(n, t) {\n  if (t < n.length) throw new Error(\"Padded size must be greater than or equal to the input array size.\");\n  let r = new Uint8Array(t);\n  r.set(n);\n  for (let o = n.length; o < t; o += 1) r[o] = 0;\n  return r;\n}\nfunction M(n) {\n  if (n.length > i.length) throw new Error(`Unable to hash input of length ${n.length}.  Max input length is ${i.length}`);\n  return i[n.length - 1](n);\n}\nexport { C as a, _ as b, N as c, W as d, M as e };","map":{"version":3,"names":["poseidon1","h","poseidon2","u","poseidon3","a","poseidon4","l","poseidon5","c","poseidon6","d","poseidon7","p","poseidon8","f","poseidon9","A","poseidon10","U","poseidon11","b","poseidon12","w","poseidon13","E","poseidon14","I","poseidon15","y","poseidon16","B","i","g","m","s","C","n","t","o","TextEncoder","encode","$","length","Error","r","_","M","T","k","P","concat","BigInt","L","map","N","push","subarray","W","Uint8Array","e","Number","set"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-standard\\node_modules\\@aptos-labs\\ts-sdk\\src\\core\\crypto\\poseidon.ts"],"sourcesContent":["/* eslint-disable no-bitwise */\nimport {\n  poseidon1,\n  poseidon2,\n  poseidon3,\n  poseidon4,\n  poseidon5,\n  poseidon6,\n  poseidon7,\n  poseidon8,\n  poseidon9,\n  poseidon10,\n  poseidon11,\n  poseidon12,\n  poseidon13,\n  poseidon14,\n  poseidon15,\n  poseidon16,\n} from \"poseidon-lite\";\n\nconst numInputsToPoseidonFunc = [\n  poseidon1,\n  poseidon2,\n  poseidon3,\n  poseidon4,\n  poseidon5,\n  poseidon6,\n  poseidon7,\n  poseidon8,\n  poseidon9,\n  poseidon10,\n  poseidon11,\n  poseidon12,\n  poseidon13,\n  poseidon14,\n  poseidon15,\n  poseidon16,\n];\n\nconst BYTES_PACKED_PER_SCALAR = 31;\nconst MAX_NUM_INPUT_SCALARS = 16;\nconst MAX_NUM_INPUT_BYTES = (MAX_NUM_INPUT_SCALARS - 1) * BYTES_PACKED_PER_SCALAR;\n\n/**\n * Hashes a string to a field element via Poseidon hashing.\n * This function is useful for converting a string into a fixed-size hash that can be used in cryptographic applications.\n *\n * @param str - The string to be hashed.\n * @param maxSizeBytes - The maximum size in bytes for the resulting hash.\n * @returns bigint - The result of the hash.\n * @group Implementation\n * @category Serialization\n */\nexport function hashStrToField(str: string, maxSizeBytes: number): bigint {\n  const textEncoder = new TextEncoder();\n  const strBytes = textEncoder.encode(str);\n  return hashBytesWithLen(strBytes, maxSizeBytes);\n}\n\n/**\n * Computes a Poseidon hash of the provided byte array, ensuring that the byte array does not exceed the specified maximum size.\n * This function is useful for generating a hash from a byte array while enforcing size constraints.\n *\n * @param bytes - The byte array to be hashed.\n * @param maxSizeBytes - The maximum allowed size for the byte array.\n * @throws Error if the length of the inputted bytes exceeds the specified maximum size.\n * @group Implementation\n * @category Serialization\n */\nfunction hashBytesWithLen(bytes: Uint8Array, maxSizeBytes: number): bigint {\n  if (bytes.length > maxSizeBytes) {\n    throw new Error(`Inputted bytes of length ${bytes} is longer than ${maxSizeBytes}`);\n  }\n  const packed = padAndPackBytesWithLen(bytes, maxSizeBytes);\n  return poseidonHash(packed);\n}\n\n/**\n * Pads the input byte array with zeros to a specified maximum size and then packs the bytes.\n * This function ensures that the byte array does not exceed the specified maximum size, throwing an error if it does.\n *\n * @param bytes - The byte array to be padded and packed.\n * @param maxSizeBytes - The maximum size in bytes that the input array can have.\n * @throws Error if the input byte array exceeds the specified maximum size.\n * @group Implementation\n * @category Serialization\n */\nfunction padAndPackBytesNoLen(bytes: Uint8Array, maxSizeBytes: number): bigint[] {\n  if (bytes.length > maxSizeBytes) {\n    throw new Error(`Input bytes of length ${bytes} is longer than ${maxSizeBytes}`);\n  }\n  const paddedStrBytes = padUint8ArrayWithZeros(bytes, maxSizeBytes);\n  return packBytes(paddedStrBytes);\n}\n\n/**\n * Pads and packs the given byte array to a specified maximum size and appends its length.\n * This function ensures that the byte array does not exceed the maximum size, throwing an error if it does.\n * It is useful for preparing byte data for further processing or transmission by ensuring a consistent format.\n *\n * @param bytes - The byte array to be padded and packed.\n * @param maxSizeBytes - The maximum allowed size for the byte array.\n * @throws Error if the length of the input bytes exceeds the maximum size.\n * @returns A new Uint8Array that contains the padded and packed bytes along with the length of the original byte array.\n * @group Implementation\n * @category Serialization\n */\nexport function padAndPackBytesWithLen(bytes: Uint8Array, maxSizeBytes: number): bigint[] {\n  if (bytes.length > maxSizeBytes) {\n    throw new Error(`Input bytes of length ${bytes} is longer than ${maxSizeBytes}`);\n  }\n  return padAndPackBytesNoLen(bytes, maxSizeBytes).concat([BigInt(bytes.length)]);\n}\n\n/**\n * Packs a Uint8Array into an array of BigInts, ensuring the input does not exceed the maximum allowed bytes.\n * @param bytes - The Uint8Array to be packed.\n * @throws {Error} Throws an error if the input exceeds the maximum number of bytes allowed.\n * @group Implementation\n * @category Serialization\n */\nfunction packBytes(bytes: Uint8Array): bigint[] {\n  if (bytes.length > MAX_NUM_INPUT_BYTES) {\n    throw new Error(`Can't pack more than ${MAX_NUM_INPUT_BYTES}.  Was given ${bytes.length} bytes`);\n  }\n  return chunkUint8Array(bytes, BYTES_PACKED_PER_SCALAR).map((chunk) => bytesToBigIntLE(chunk));\n}\n\n/**\n * Splits a Uint8Array into smaller chunks of the specified size.\n * This function is useful for processing large arrays in manageable segments.\n *\n * @param array - The Uint8Array to be split into chunks.\n * @param chunkSize - The size of each chunk.\n * @returns An array of Uint8Array chunks.\n * @group Implementation\n * @category Serialization\n */\nfunction chunkUint8Array(array: Uint8Array, chunkSize: number): Uint8Array[] {\n  const result: Uint8Array[] = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.subarray(i, i + chunkSize));\n  }\n  return result;\n}\n\n/**\n * Converts a little-endian byte array into a BigInt.\n * This function is useful for interpreting byte data as a numerical value in a way that respects the little-endian format.\n *\n * @param bytes - The byte array to convert.\n * @returns The resulting BigInt representation of the byte array.\n * @group Implementation\n * @category Serialization\n */\nexport function bytesToBigIntLE(bytes: Uint8Array): bigint {\n  let result = BigInt(0);\n  for (let i = bytes.length - 1; i >= 0; i -= 1) {\n    result = (result << BigInt(8)) | BigInt(bytes[i]);\n  }\n  return result;\n}\n\n/**\n * Converts a bigint value into a little-endian byte array of a specified length.\n * This function is useful for representing large integers in a byte format, which is often required for cryptographic operations\n * or binary data manipulation.\n *\n * @param value - The number to convert into bytes.\n * @param length - The desired length of the resulting byte array.\n * @returns A Uint8Array containing the little-endian representation of the bigint value.\n * @group Implementation\n * @category Serialization\n */\nexport function bigIntToBytesLE(value: bigint | number, length: number): Uint8Array {\n  let val = BigInt(value);\n  const bytes = new Uint8Array(length);\n  for (let i = 0; i < length; i += 1) {\n    bytes[i] = Number(val & BigInt(0xff));\n    val >>= BigInt(8);\n  }\n  return bytes;\n}\n\n/**\n * Pads the input Uint8Array with zeros to achieve the specified size.\n * This function is useful for ensuring that a byte array meets a required length for further processing.\n *\n * @param inputArray - The Uint8Array to be padded.\n * @param paddedSize - The desired size of the padded array, which must be greater than or equal to the input array size.\n * @throws Error if paddedSize is less than the length of inputArray.\n * @group Implementation\n * @category Serialization\n */\nfunction padUint8ArrayWithZeros(inputArray: Uint8Array, paddedSize: number): Uint8Array {\n  if (paddedSize < inputArray.length) {\n    throw new Error(\"Padded size must be greater than or equal to the input array size.\");\n  }\n\n  // Create a new Uint8Array with the padded size\n  const paddedArray = new Uint8Array(paddedSize);\n\n  // Copy the content of the input array to the new array\n  paddedArray.set(inputArray);\n\n  // Fill the remaining space with zeros\n  for (let i = inputArray.length; i < paddedSize; i += 1) {\n    paddedArray[i] = 0;\n  }\n\n  return paddedArray;\n}\n\n/**\n * Hashes up to 16 scalar elements via the Poseidon hashing algorithm.\n * Each element must be scalar fields of the BN254 elliptic curve group.\n *\n * @param inputs - An array of elements to be hashed, which can be of type number, bigint, or string.\n * @returns bigint - The result of the hash.\n * @throws Error - Throws an error if the input length exceeds the maximum allowed.\n * @group Implementation\n * @category Serialization\n */\nexport function poseidonHash(inputs: (number | bigint | string)[]): bigint {\n  if (inputs.length > numInputsToPoseidonFunc.length) {\n    throw new Error(\n      `Unable to hash input of length ${inputs.length}.  Max input length is ${numInputsToPoseidonFunc.length}`,\n    );\n  }\n  return numInputsToPoseidonFunc[inputs.length - 1](inputs);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}