{"ast":null,"code":"// src/encrDecr.ts\nimport { Ed25519Signature } from \"@aptos-labs/ts-sdk\";\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport nacl2 from \"tweetnacl\";\nimport ed2curve from \"ed2curve\";\n\n// src/errors.ts\nvar EncryptionEnvelopeError = class extends Error {};\nvar EnvelopeMessageMismatchError = class _EnvelopeMessageMismatchError extends EncryptionEnvelopeError {\n  constructor(message, field) {\n    super(message);\n    this.field = field;\n    this.name = \"EnvelopeMessageMismatchError\";\n    Object.setPrototypeOf(this, _EnvelopeMessageMismatchError.prototype);\n  }\n};\nvar DecryptionError = class _DecryptionError extends EncryptionEnvelopeError {\n  constructor(message) {\n    super(message);\n    this.name = \"DecryptionError\";\n    Object.setPrototypeOf(this, _DecryptionError.prototype);\n  }\n};\n\n// src/utils.ts\nimport nacl from \"tweetnacl\";\nvar KeyTypes = /* @__PURE__ */(KeyTypes2 => {\n  KeyTypes2[\"Ed25519PublicKey\"] = \"Ed25519PublicKey\";\n  KeyTypes2[\"Ed25519SecretKey\"] = \"Ed25519SecretKey\";\n  KeyTypes2[\"X25519PublicKey\"] = \"X25519PublicKey\";\n  KeyTypes2[\"X25519SecretKey\"] = \"X25519SecretKey\";\n  return KeyTypes2;\n})(KeyTypes || {});\nfunction createX25519KeyPair() {\n  return keypairToX25519(nacl.box.keyPair());\n}\nfunction createEd25519KeyPair() {\n  return keypairToEd25519(nacl.sign.keyPair());\n}\nfunction toKey(rawKey, type) {\n  return {\n    key: rawKey,\n    type\n  };\n}\nfunction keypairToEd25519(keyPair) {\n  return {\n    publicKey: toKey(keyPair.publicKey, \"Ed25519PublicKey\" /* Ed25519PublicKey */),\n    secretKey: toKey(keyPair.secretKey, \"Ed25519SecretKey\" /* Ed25519SecretKey */)\n  };\n}\nfunction keypairToX25519(keyPair) {\n  return {\n    publicKey: toKey(keyPair.publicKey, \"X25519PublicKey\" /* X25519PublicKey */),\n    secretKey: toKey(keyPair.secretKey, \"X25519SecretKey\" /* X25519SecretKey */)\n  };\n}\nfunction aptosAccountToEd25519Keypair(account) {\n  return ed25519KeypairFromSecret(account.signingKey.secretKey);\n}\nfunction ed25519KeypairFromSecret(ed25519SecretKeyBytes) {\n  return keypairToEd25519(nacl.sign.keyPair.fromSeed(ed25519SecretKeyBytes.slice(0, 32)));\n}\nfunction decodeBase64(base64Str) {\n  if (globalThis.Buffer) {\n    return new Uint8Array(Buffer.from(base64Str, \"base64\"));\n  }\n  return Uint8Array.from(atob(base64Str), m => m.codePointAt(0));\n}\nfunction encodeBase64(bytes) {\n  if (globalThis.Buffer) {\n    return Buffer.from(bytes).toString(\"base64\");\n  }\n  return btoa(Array.from(bytes, x => String.fromCodePoint(x)).join(\"\"));\n}\nfunction concatUint8array(arrayOne, arrayTwo) {\n  const mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);\n  mergedArray.set(arrayOne);\n  mergedArray.set(arrayTwo, arrayOne.length);\n  return mergedArray;\n}\n\n// src/encrDecr.ts\nvar SIGNATURE_PREFIX = \"APTOS::IDENTITY_CONNECT\";\nfunction convertEd25519PublicKeyToX25519PublicKey(ed25519PublicKey, errorKeyName) {\n  const x25519PublicKey = ed2curve.convertPublicKey(ed25519PublicKey.key.slice(0, 32));\n  if (!x25519PublicKey) throw new Error(`${errorKeyName} is not a valid Ed25519 public key`);\n  return toKey(x25519PublicKey, \"X25519PublicKey\" /* X25519PublicKey */);\n}\nfunction convertEd25519SecretKeyToX25519SecretKey(ed25519SecretKey) {\n  const x25519SecretKey = ed2curve.convertSecretKey(ed25519SecretKey.key.slice(0, 32));\n  return toKey(x25519SecretKey, \"X25519SecretKey\" /* X25519SecretKey */);\n}\nfunction serializeEncryptionResult(enc) {\n  return {\n    nonceB64: encodeBase64(enc.nonce),\n    securedB64: encodeBase64(enc.secured)\n  };\n}\nfunction deserializeEncryptionResult(enc) {\n  return {\n    nonce: decodeBase64(enc.nonceB64),\n    secured: decodeBase64(enc.securedB64)\n  };\n}\nfunction decryptSerializedEncryptionResult(senderX25519PublicKey, receiverEd25519SecretKey, enc) {\n  const des = deserializeEncryptionResult(enc);\n  return decryptObject(senderX25519PublicKey, receiverEd25519SecretKey, des.secured, des.nonce);\n}\nfunction decryptSerializedEncryptionResultDirect(senderX25519PublicKey, receiverX25519SecretKey, enc) {\n  const des = deserializeEncryptionResult(enc);\n  return decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, des.secured, des.nonce);\n}\nfunction encryptMessage(senderX25519SecretKey, receiverEd25519PublicKey, message) {\n  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(receiverEd25519PublicKey, \"receiver public key\");\n  return encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, message);\n}\nfunction encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {\n  const nonce = nacl2.randomBytes(nacl2.box.nonceLength);\n  const messageUint8 = new TextEncoder().encode(message);\n  const secured = nacl2.box(messageUint8, nonce, receiverX25519PublicKey.key, senderX25519SecretKey.key.slice(0, 32));\n  return {\n    nonce,\n    secured\n  };\n}\nfunction encryptObject(senderX25519SecretKey, receiverEd25519PublicKey, message) {\n  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(receiverEd25519PublicKey, \"receiver public key\");\n  return encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message);\n}\nfunction encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {\n  return encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, JSON.stringify(message));\n}\nfunction decryptMessage(senderX25519PublicKey, receiverEd25519SecretKey, securedMessage, nonce) {\n  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(receiverEd25519SecretKey);\n  return decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);\n}\nfunction decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {\n  let decryptedUint8;\n  try {\n    decryptedUint8 = nacl2.box.open(securedMessage, nonce, senderX25519PublicKey.key.slice(0, 32), receiverX25519SecretKey.key.slice(0, 32));\n  } catch (e) {\n    throw new DecryptionError(`Could not decrypt message: ${e.message}`);\n  }\n  if (!decryptedUint8) throw new DecryptionError(\"Could not decrypt message\");\n  return new TextDecoder().decode(decryptedUint8);\n}\nfunction decryptObject(senderX25519PublicKey, receiverEd25519SecretKey, securedMessage, nonce) {\n  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(receiverEd25519SecretKey);\n  return decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);\n}\nfunction decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {\n  const decryptedStr = decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);\n  return JSON.parse(decryptedStr);\n}\nfunction messageHash(message, purpose) {\n  const signaturePrefixHash = new Uint8Array(sha3_256(`${SIGNATURE_PREFIX}::${purpose}::`));\n  return new Uint8Array(sha3_256(concatUint8array(signaturePrefixHash, message)));\n}\nfunction signWithEd25519SecretKey(message, signingEd25519SecretKey, purpose) {\n  return nacl2.sign.detached(messageHash(message, purpose), signingEd25519SecretKey.key);\n}\nfunction makeEd25519SecretKeySignCallbackNoDomainSeparation(signingEd25519SecretKey) {\n  return async message => new Ed25519Signature(nacl2.sign.detached(message, signingEd25519SecretKey.key));\n}\nfunction verifySignature(message, signature, signingPublicKey, purpose) {\n  return signingPublicKey.verifySignature({\n    message: messageHash(message, purpose),\n    signature\n  });\n}\nfunction hashAndVerifySignature(message, signature, signingPublicKey, purpose) {\n  const messageUint8 = message instanceof Uint8Array ? message : new TextEncoder().encode(message);\n  const messageUint8Hash = sha3_256(messageUint8);\n  return verifySignature(messageUint8Hash, signature, signingPublicKey, purpose);\n}\n\n// src/securedEnvelope.ts\nimport { Ed25519PublicKey as AptosEd25519PublicKey, Ed25519Signature as Ed25519Signature2, Hex } from \"@aptos-labs/ts-sdk\";\nimport { sha3_256 as sha3_2562 } from \"@noble/hashes/sha3\";\nvar REQUIRED_FIELDS = [\"receiverEd25519PublicKeyB64\", \"senderEd25519PublicKeyB64\", \"senderX25519PublicKeyB64\", \"sequence\", \"timestampMillis\"].sort();\nfunction ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage) {\n  const intersection = Object.keys(privateMessage).filter(x => Object.keys(publicMessage).includes(x));\n  if (intersection.length > 0) {\n    const field = intersection[0];\n    throw new EnvelopeMessageMismatchError(`Field ${field} appears in both private and public message fields`, field);\n  }\n}\nfunction ensureMetadataFields(message) {\n  const messageKeys = Object.keys(message).sort();\n  const extraFields = messageKeys.filter(key => !REQUIRED_FIELDS.includes(key));\n  const missingFields = REQUIRED_FIELDS.filter(key => !messageKeys.includes(key));\n  if (extraFields.length > 0 || missingFields.length > 0) {\n    let extraFieldsStr = extraFields.length > 0 ? `extra(${extraFields.join(\", \")})` : \"\";\n    const missingFieldsStr = missingFields.length > 0 ? `missing(${missingFields.join(\", \")})` : \"\";\n    extraFieldsStr = extraFieldsStr.length > 0 && missingFieldsStr.length > 0 ? `${extraFieldsStr}, ` : extraFieldsStr;\n    throw new EnvelopeMessageMismatchError(`PublicMessage metadata fields do not conform to spec: ${extraFieldsStr}${missingFieldsStr}`, \"_metadata\");\n  }\n}\nfunction deserializeTransportEnvelope(transportEnvelope) {\n  const publicMessage = JSON.parse(transportEnvelope.serializedPublicMessage);\n  return {\n    ...transportEnvelope,\n    publicMessage\n  };\n}\nfunction encryptAndSignEnvelope(senderEd25519SecretKey, senderEd25519PublicKey, receiverEd25519PublicKey, sequence, publicMessage, privateMessage) {\n  const senderEphemeralX25519KeyPair = createX25519KeyPair();\n  const metadata = constructMetadata(senderEd25519PublicKey, receiverEd25519PublicKey, sequence, senderEphemeralX25519KeyPair.publicKey);\n  ensureMetadataFields(metadata);\n  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);\n  return dangerouslyEncryptAndSignEnvelopeUnvalidated(senderEd25519SecretKey, receiverEd25519PublicKey, metadata, privateMessage, publicMessage, senderEphemeralX25519KeyPair);\n}\nfunction constructMetadata(senderEd25519PublicKey, receiverEd25519PublicKey, sequence, senderEphemeralX25519PublicKey) {\n  return {\n    receiverEd25519PublicKeyB64: encodeBase64(receiverEd25519PublicKey.key),\n    senderEd25519PublicKeyB64: encodeBase64(senderEd25519PublicKey.key),\n    senderX25519PublicKeyB64: encodeBase64(senderEphemeralX25519PublicKey.key),\n    sequence,\n    timestampMillis: Date.now()\n  };\n}\nfunction dangerouslyEncryptAndSignEnvelopeUnvalidated(senderEd25519SecretKey, receiverEd25519PublicKey, metadata, privateMessage, publicMessage, senderEphemeralX25519KeyPair) {\n  const encryptionResult = encryptObject(senderEphemeralX25519KeyPair.secretKey, receiverEd25519PublicKey, privateMessage);\n  const encryptedPrivateMessage = serializeEncryptionResult(encryptionResult);\n  const encryptedPrivateMessageBytes = decodeBase64(encryptedPrivateMessage.securedB64);\n  const serializedPublicMessage = JSON.stringify({\n    ...publicMessage,\n    _metadata: metadata\n  });\n  const publicMessageBytes = new TextEncoder().encode(serializedPublicMessage);\n  const messageSignature = signEnvelope(publicMessageBytes, encryptedPrivateMessageBytes, senderEd25519SecretKey);\n  return {\n    encryptedPrivateMessage,\n    messageSignature,\n    serializedPublicMessage\n  };\n}\nfunction combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes) {\n  const publicMessageBytesHash = sha3_2562(publicMessageBytes);\n  const privateMessageBytesHash = sha3_2562(privateMessageBytes);\n  const combinedHash = new Uint8Array(publicMessageBytesHash.length + privateMessageBytesHash.length);\n  combinedHash.set(publicMessageBytesHash);\n  combinedHash.set(privateMessageBytesHash, publicMessageBytesHash.length);\n  return sha3_2562(combinedHash);\n}\nfunction signEnvelope(publicMessageBytes, privateMessageBytes, senderEd25519SecretKey) {\n  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);\n  const signatureBytes = signWithEd25519SecretKey(messageHashBytes, senderEd25519SecretKey, \"SECURED_ENVELOPE\");\n  return Hex.fromHexInput(signatureBytes).toString();\n}\nfunction verifyEnvelopeSignature(publicMessageBytes, privateMessageBytes, messageSignatureInput, senderEd25519PublicKey) {\n  const messageSignature = new Ed25519Signature2(Hex.fromHexInput(messageSignatureInput).toUint8Array());\n  const senderPublicKey = new AptosEd25519PublicKey(senderEd25519PublicKey.key);\n  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);\n  const messageVerified = verifySignature(messageHashBytes, messageSignature, senderPublicKey, \"SECURED_ENVELOPE\");\n  if (!messageVerified) {\n    throw new EnvelopeMessageMismatchError(\"Could not verify SecuredEnvelope signature\", \"messageSignature\");\n  }\n}\nfunction decryptEnvelope(senderEd25519PublicKey, receiverEd25519SecretKey, message) {\n  const {\n    encryptedPrivateMessage,\n    messageSignature,\n    serializedPublicMessage\n  } = message;\n  const publicMessage = JSON.parse(serializedPublicMessage);\n  const rawPrivateMessage = decodeBase64(encryptedPrivateMessage.securedB64);\n  const rawPublicMessage = new TextEncoder().encode(serializedPublicMessage);\n  verifyEnvelopeSignature(rawPublicMessage, rawPrivateMessage, messageSignature, senderEd25519PublicKey);\n  const senderEd25519PublicKeyB64 = encodeBase64(senderEd25519PublicKey.key);\n  const expectedPublicKeyB64 = publicMessage._metadata.senderEd25519PublicKeyB64;\n  if (senderEd25519PublicKeyB64 !== expectedPublicKeyB64) {\n    throw new EnvelopeMessageMismatchError(\"senderEd25519PublicKey in envelope does not match provided receiverEd25519SecretKey\", \"senderPublicKey\");\n  }\n  const senderX25519PublicKeyBytes = decodeBase64(publicMessage._metadata.senderX25519PublicKeyB64);\n  const senderX25519PublicKey = toKey(senderX25519PublicKeyBytes, \"X25519PublicKey\" /* X25519PublicKey */);\n  const encryptionResult = deserializeEncryptionResult(encryptedPrivateMessage);\n  const privateMessage = decryptObject(senderX25519PublicKey, receiverEd25519SecretKey, encryptionResult.secured, encryptionResult.nonce);\n  ensureMetadataFields(publicMessage._metadata);\n  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);\n  return {\n    messageSignature,\n    privateMessage,\n    publicMessage\n  };\n}\n\n// src/serialization.ts\nimport { base64ToBytes, bytesToBase64, deserializePublicKey, deserializeSignature, serializePublicKey, serializeSignature } from \"@aptos-connect/wallet-api\";\nimport { Deserializer, Ed25519PublicKey as AptosEd25519PublicKey2, Ed25519Signature as Ed25519Signature3, Hex as Hex2, Serializer } from \"@aptos-labs/ts-sdk\";\nfunction serializePublicKeyB64(publicKey) {\n  const serializer = new Serializer();\n  serializePublicKey(serializer, publicKey);\n  return bytesToBase64(serializer.toUint8Array());\n}\nfunction deserializePublicKeyB64(publicKeyB64) {\n  const serializedPublicKey = base64ToBytes(publicKeyB64);\n  const deserializer = new Deserializer(serializedPublicKey);\n  return deserializePublicKey(deserializer);\n}\nfunction deserializeEd25519PublicKeyB64(ed25519PublicKeyB64) {\n  return new AptosEd25519PublicKey2(decodeBase64(ed25519PublicKeyB64));\n}\nfunction serializeSignatureB64(signature) {\n  const serializer = new Serializer();\n  serializeSignature(serializer, signature);\n  return bytesToBase64(serializer.toUint8Array());\n}\nfunction deserializeSignatureB64(signatureB64) {\n  const serializedSignature = base64ToBytes(signatureB64);\n  const deserializer = new Deserializer(serializedSignature);\n  return deserializeSignature(deserializer);\n}\nfunction deserializeEd25519SignatureB64(ed25519SignatureB64) {\n  const signatureBytes = Hex2.fromHexInput(ed25519SignatureB64).toUint8Array();\n  return new Ed25519Signature3(signatureBytes);\n}\nfunction publicKeyB64FromEd25519PublicKeyB64(ed25519PublicKeyB64) {\n  const publicKey = deserializeEd25519PublicKeyB64(ed25519PublicKeyB64);\n  return serializePublicKeyB64(publicKey);\n}\n\n// src/walletAccounts.ts\nimport { PublicKey as AptosPublicKey } from \"@aptos-labs/ts-sdk\";\nimport { sha3_256 as sha3_2563 } from \"@noble/hashes/sha3\";\nvar AccountConnectionAction = /* @__PURE__ */(AccountConnectionAction2 => {\n  AccountConnectionAction2[\"ADD\"] = \"add\";\n  AccountConnectionAction2[\"REMOVE\"] = \"remove\";\n  return AccountConnectionAction2;\n})(AccountConnectionAction || {});\nfunction deriveAccountTransportEd25519Keypair(ed25519SecretKeyOrSignCallback, publicKey) {\n  const publicKeyBytes = publicKey instanceof AptosPublicKey ? publicKey.toUint8Array() : publicKey.key;\n  if (ed25519SecretKeyOrSignCallback instanceof Function) {\n    const seedGeneratorBytes = messageHash(publicKeyBytes, \"TRANSPORT_KEYPAIR\");\n    const signature = ed25519SecretKeyOrSignCallback(seedGeneratorBytes);\n    if (signature instanceof Promise) {\n      return signature.then(value => ed25519KeypairFromSecret(value.toUint8Array()));\n    }\n    return ed25519KeypairFromSecret(signature.toUint8Array());\n  }\n  const seedBytes = signWithEd25519SecretKey(publicKeyBytes, ed25519SecretKeyOrSignCallback, \"TRANSPORT_KEYPAIR\");\n  return ed25519KeypairFromSecret(seedBytes);\n}\nfunction createSerializedAccountInfo(...[signCallback, publicKey, transportEd25519PublicKey, action, intentId, accountAddress]) {\n  const authKey = publicKey.authKey();\n  const finalAccountAddress = accountAddress || authKey.derivedAddress().toString();\n  const publicKeyB64 = serializePublicKeyB64(publicKey);\n  const accountInfo = {\n    accountAddress: finalAccountAddress,\n    action,\n    intentId,\n    publicKeyB64,\n    timestampMillis: Date.now(),\n    transportEd25519PublicKeyB64: encodeBase64(transportEd25519PublicKey.key)\n  };\n  const accountInfoSerialized = JSON.stringify(accountInfo);\n  const accountInfoBytes = new TextEncoder().encode(accountInfoSerialized);\n  const accountInfoHash = sha3_2563(accountInfoBytes);\n  const signature = signCallback(messageHash(accountInfoHash, \"ACCOUNT_INFO\"));\n  if (signature instanceof Promise) {\n    return signature.then(value => ({\n      accountInfoSerialized,\n      signatureB64: serializeSignatureB64(value)\n    }));\n  }\n  return {\n    accountInfoSerialized,\n    signatureB64: serializeSignatureB64(signature)\n  };\n}\nasync function aptosAccountToSerializedInfo(account, intentId) {\n  const signCallback = async data => account.sign(data);\n  const transportKey = await deriveAccountTransportEd25519Keypair(signCallback, account.publicKey);\n  return createSerializedAccountInfo(signCallback, account.publicKey, transportKey.publicKey, \"add\" /* ADD */, intentId);\n}\nexport { AccountConnectionAction, DecryptionError, EncryptionEnvelopeError, EnvelopeMessageMismatchError, KeyTypes, REQUIRED_FIELDS, SIGNATURE_PREFIX, aptosAccountToEd25519Keypair, aptosAccountToSerializedInfo, concatUint8array, constructMetadata, convertEd25519PublicKeyToX25519PublicKey, convertEd25519SecretKeyToX25519SecretKey, createEd25519KeyPair, createSerializedAccountInfo, createX25519KeyPair, dangerouslyEncryptAndSignEnvelopeUnvalidated, decodeBase64, decryptEnvelope, decryptMessage, decryptMessageDirect, decryptObject, decryptObjectDirect, decryptSerializedEncryptionResult, decryptSerializedEncryptionResultDirect, deriveAccountTransportEd25519Keypair, deserializeEd25519PublicKeyB64, deserializeEd25519SignatureB64, deserializeEncryptionResult, deserializePublicKeyB64, deserializeSignatureB64, deserializeTransportEnvelope, ed25519KeypairFromSecret, encodeBase64, encryptAndSignEnvelope, encryptMessage, encryptMessageDirect, encryptObject, encryptObjectDirect, ensureMetadataFields, ensurePrivatePublicFieldsDisjoint, hashAndVerifySignature, keypairToEd25519, keypairToX25519, makeEd25519SecretKeySignCallbackNoDomainSeparation, messageHash, publicKeyB64FromEd25519PublicKeyB64, serializeEncryptionResult, serializePublicKeyB64, serializeSignatureB64, signWithEd25519SecretKey, toKey, verifyEnvelopeSignature, verifySignature };","map":{"version":3,"names":["Ed25519Signature","sha3_256","nacl2","ed2curve","EncryptionEnvelopeError","Error","EnvelopeMessageMismatchError","_EnvelopeMessageMismatchError","constructor","message","field","name","Object","setPrototypeOf","prototype","DecryptionError","_DecryptionError","nacl","KeyTypes","KeyTypes2","createX25519KeyPair","keypairToX25519","box","keyPair","createEd25519KeyPair","keypairToEd25519","sign","toKey","rawKey","type","key","publicKey","secretKey","aptosAccountToEd25519Keypair","account","ed25519KeypairFromSecret","signingKey","ed25519SecretKeyBytes","fromSeed","slice","decodeBase64","base64Str","globalThis","Buffer","Uint8Array","from","atob","m","codePointAt","encodeBase64","bytes","toString","btoa","Array","x","String","fromCodePoint","join","concatUint8array","arrayOne","arrayTwo","mergedArray","length","set","SIGNATURE_PREFIX","convertEd25519PublicKeyToX25519PublicKey","ed25519PublicKey","errorKeyName","x25519PublicKey","convertPublicKey","convertEd25519SecretKeyToX25519SecretKey","ed25519SecretKey","x25519SecretKey","convertSecretKey","serializeEncryptionResult","enc","nonceB64","nonce","securedB64","secured","deserializeEncryptionResult","decryptSerializedEncryptionResult","senderX25519PublicKey","receiverEd25519SecretKey","des","decryptObject","decryptSerializedEncryptionResultDirect","receiverX25519SecretKey","decryptObjectDirect","encryptMessage","senderX25519SecretKey","receiverEd25519PublicKey","receiverX25519PublicKey","encryptMessageDirect","randomBytes","nonceLength","messageUint8","TextEncoder","encode","encryptObject","encryptObjectDirect","JSON","stringify","decryptMessage","securedMessage","decryptMessageDirect","decryptedUint8","open","e","TextDecoder","decode","decryptedStr","parse","messageHash","purpose","signaturePrefixHash","signWithEd25519SecretKey","signingEd25519SecretKey","detached","makeEd25519SecretKeySignCallbackNoDomainSeparation","verifySignature","signature","signingPublicKey","hashAndVerifySignature","messageUint8Hash","Ed25519PublicKey","AptosEd25519PublicKey","Ed25519Signature2","Hex","sha3_2562","REQUIRED_FIELDS","sort","ensurePrivatePublicFieldsDisjoint","privateMessage","publicMessage","intersection","keys","filter","includes","ensureMetadataFields","messageKeys","extraFields","missingFields","extraFieldsStr","missingFieldsStr","deserializeTransportEnvelope","transportEnvelope","serializedPublicMessage","encryptAndSignEnvelope","senderEd25519SecretKey","senderEd25519PublicKey","sequence","senderEphemeralX25519KeyPair","metadata","constructMetadata","dangerouslyEncryptAndSignEnvelopeUnvalidated","senderEphemeralX25519PublicKey","receiverEd25519PublicKeyB64","senderEd25519PublicKeyB64","senderX25519PublicKeyB64","timestampMillis","Date","now","encryptionResult","encryptedPrivateMessage","encryptedPrivateMessageBytes","_metadata","publicMessageBytes","messageSignature","signEnvelope","combineHashedEnvelopeMessageBytes","privateMessageBytes","publicMessageBytesHash","privateMessageBytesHash","combinedHash","messageHashBytes","signatureBytes","fromHexInput","verifyEnvelopeSignature","messageSignatureInput","toUint8Array","senderPublicKey","messageVerified","decryptEnvelope","rawPrivateMessage","rawPublicMessage","expectedPublicKeyB64","senderX25519PublicKeyBytes","base64ToBytes","bytesToBase64","deserializePublicKey","deserializeSignature","serializePublicKey","serializeSignature","Deserializer","AptosEd25519PublicKey2","Ed25519Signature3","Hex2","Serializer","serializePublicKeyB64","serializer","deserializePublicKeyB64","publicKeyB64","serializedPublicKey","deserializer","deserializeEd25519PublicKeyB64","ed25519PublicKeyB64","serializeSignatureB64","deserializeSignatureB64","signatureB64","serializedSignature","deserializeEd25519SignatureB64","ed25519SignatureB64","publicKeyB64FromEd25519PublicKeyB64","PublicKey","AptosPublicKey","sha3_2563","AccountConnectionAction","AccountConnectionAction2","deriveAccountTransportEd25519Keypair","ed25519SecretKeyOrSignCallback","publicKeyBytes","Function","seedGeneratorBytes","Promise","then","value","seedBytes","createSerializedAccountInfo","signCallback","transportEd25519PublicKey","action","intentId","accountAddress","authKey","finalAccountAddress","derivedAddress","accountInfo","transportEd25519PublicKeyB64","accountInfoSerialized","accountInfoBytes","accountInfoHash","aptosAccountToSerializedInfo","data","transportKey"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\crypto\\src\\encrDecr.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\crypto\\src\\errors.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\crypto\\src\\utils.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\crypto\\src\\securedEnvelope.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\crypto\\src\\serialization.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\crypto\\src\\walletAccounts.ts"],"sourcesContent":["// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Ed25519Signature, PublicKey, Signature } from '@aptos-labs/ts-sdk';\nimport { sha3_256 } from '@noble/hashes/sha3';\nimport nacl from 'tweetnacl';\nimport ed2curve from 'ed2curve';\nimport { DecryptionError } from './errors';\nimport {\n  concatUint8array,\n  decodeBase64,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  KeyTypes,\n  toKey,\n  X25519PublicKey,\n  X25519SecretKey,\n} from './utils';\n\n// This callback takes in a message bytes, and signs it.\n// THIS DOES NOT PERFORM DOMAIN SEPARATION: IT IS ASSUMED OUR LIBRARY ALREADY DID IT.\n// This is to support hardware wallets.\nexport type SignCallback = (message: Uint8Array) => Promise<Signature>;\n\nexport type SignaturePurpose = 'TRANSPORT_KEYPAIR' | 'ACCOUNT_INFO' | 'SECURED_ENVELOPE';\n\nexport const SIGNATURE_PREFIX = 'APTOS::IDENTITY_CONNECT';\n\nexport type EncryptionResult = {\n  nonce: Uint8Array;\n  secured: Uint8Array;\n};\n\nexport type SerializedEncryptionResult = {\n  nonceB64: string;\n  securedB64: string;\n};\n\n/**\n * Converts an Ed25519 public key to an X25519 public key\n * HERE THERE BE DRAGONS. ONLY USE THIS IF YOU KNOW WHAT YOU ARE DOING.\n * @param ed25519PublicKey The Ed25519 public key to convert\n * @param errorKeyName The name of the key to use in error messages\n */\nexport function convertEd25519PublicKeyToX25519PublicKey(\n  ed25519PublicKey: Ed25519PublicKey,\n  errorKeyName: string,\n): X25519PublicKey {\n  const x25519PublicKey = ed2curve.convertPublicKey(ed25519PublicKey.key.slice(0, 32));\n  if (!x25519PublicKey) throw new Error(`${errorKeyName} is not a valid Ed25519 public key`);\n  return toKey(x25519PublicKey, KeyTypes.X25519PublicKey);\n}\n\n/**\n * Converts an Ed25519 secret key to an X25519 secret key\n * HERE THERE BE DRAGONS. ONLY USE THIS IF YOU KNOW WHAT YOU ARE DOING.\n * @param ed25519SecretKey The Ed25519 secret key to convert\n */\nexport function convertEd25519SecretKeyToX25519SecretKey(ed25519SecretKey: Ed25519SecretKey): X25519SecretKey {\n  const x25519SecretKey = ed2curve.convertSecretKey(ed25519SecretKey.key.slice(0, 32));\n  return toKey(x25519SecretKey, KeyTypes.X25519SecretKey);\n}\nexport function serializeEncryptionResult(enc: EncryptionResult): SerializedEncryptionResult {\n  return {\n    nonceB64: encodeBase64(enc.nonce),\n    securedB64: encodeBase64(enc.secured),\n  };\n}\n\nexport function deserializeEncryptionResult(enc: SerializedEncryptionResult): EncryptionResult {\n  return {\n    nonce: decodeBase64(enc.nonceB64),\n    secured: decodeBase64(enc.securedB64),\n  };\n}\n\n/**\n * Decrypts a `SerializedEncryptionResult` to an object\n * Uses the sender's X25519 public key and receiver's Ed25519 secret key\n * The receivers Ed25519 secret key is converted to an X25519 secret key for the Diffie-Hellman key exchange\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverEd25519SecretKey The receiver's Ed25519 secret key\n * @param enc The serialized encryption result\n */\nexport function decryptSerializedEncryptionResult<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  enc: SerializedEncryptionResult,\n): T {\n  const des = deserializeEncryptionResult(enc);\n  return decryptObject<T>(senderX25519PublicKey, receiverEd25519SecretKey, des.secured, des.nonce);\n}\n\n/**\n * Decrypts a `SerializedEncryptionResult` to an object\n * Uses the sender's X25519 public key and receiver's X25519 secret key\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverX25519SecretKey The receiver's X25519 secret key\n * @param enc The serialized encryption result\n */\nexport function decryptSerializedEncryptionResultDirect<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverX25519SecretKey: X25519SecretKey,\n  enc: SerializedEncryptionResult,\n): T {\n  const des = deserializeEncryptionResult(enc);\n  return decryptObjectDirect<T>(senderX25519PublicKey, receiverX25519SecretKey, des.secured, des.nonce);\n}\n\n/**\n * Encrypts a string, by using the sender's X25519 secret key and receiver's Ed25519 public key\n * The receiver's Ed25519 public key is converted to an X25519 public key for the Diffie-Hellman key exchange\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverEd25519PublicKey The receiver's Ed25519 public key\n * @param message The message to encrypt\n */\nexport function encryptMessage(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  message: string,\n): EncryptionResult {\n  // Encrypt the message with the receiver's public key and sender's secret key\n  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(\n    receiverEd25519PublicKey,\n    'receiver public key',\n  );\n  return encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, message);\n}\n\n/**\n * Encrypts a string, by using the sender's X25519 secret key and receiver's X25519 public key\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverX25519PublicKey The receiver's X25519 public key\n * @param message The message to encrypt\n */\nexport function encryptMessageDirect(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverX25519PublicKey: X25519PublicKey,\n  message: string,\n): EncryptionResult {\n  // Generate a random nonce\n  const nonce = nacl.randomBytes(nacl.box.nonceLength);\n\n  // Convert the message to a Uint8Array\n  const messageUint8 = new TextEncoder().encode(message);\n\n  const secured = nacl.box(messageUint8, nonce, receiverX25519PublicKey.key, senderX25519SecretKey.key.slice(0, 32));\n\n  return { nonce, secured };\n}\n\n/**\n * Encrypts an object to a string, by using the sender's X25519 secret key and receiver's Ed25519 public key\n * The receiver's Ed25519 public key is converted to an X25519 public key for the Diffie-Hellman key exchange\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverEd25519PublicKey The receiver's Ed25519 public key\n * @param message The message to encrypt\n */\nexport function encryptObject<T>(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  message: T,\n): EncryptionResult {\n  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(\n    receiverEd25519PublicKey,\n    'receiver public key',\n  );\n  return encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message);\n}\n\n/**\n * Encrypts an object to a string, by using the sender's X25519 secret key and receiver's X25519 public key\n * @param senderX25519SecretKey The sender's X25519 secret key\n * @param receiverX25519PublicKey The receiver's X25519 public key\n * @param message The message to encrypt\n */\nexport function encryptObjectDirect<T>(\n  senderX25519SecretKey: X25519SecretKey,\n  receiverX25519PublicKey: X25519PublicKey,\n  message: T,\n): EncryptionResult {\n  return encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, JSON.stringify(message));\n}\n\n/**\n * Decrypts a string, by using the sender's X25519 public key and receiver's Ed25519 secret key\n * The receivers Ed25519 secret key is converted to an X25519 secret key for the Diffie-Hellman key exchange\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverEd25519SecretKey The receiver's Ed25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptMessage(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): string {\n  // Decrypt the message with the receiver's secret key and sender's public key\n  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(receiverEd25519SecretKey);\n  return decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);\n}\n\n/**\n * Decrypts a string, by using the sender's X25519 public key and receiver's X25519 secret key\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverX25519SecretKey The receiver's X25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptMessageDirect(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverX25519SecretKey: X25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): string {\n  let decryptedUint8;\n  try {\n    decryptedUint8 = nacl.box.open(\n      securedMessage,\n      nonce,\n      senderX25519PublicKey.key.slice(0, 32),\n      receiverX25519SecretKey.key.slice(0, 32),\n    );\n  } catch (e: any) {\n    throw new DecryptionError(`Could not decrypt message: ${e.message}`);\n  }\n  if (!decryptedUint8) throw new DecryptionError('Could not decrypt message');\n\n  // Convert the decrypted Uint8Array back to a string\n  return new TextDecoder().decode(decryptedUint8);\n}\n\n/**\n * Decrypts an object, by using the sender's X25519 public key and receiver's Ed25519 secret key\n * The receivers Ed25519 secret key is converted to an X25519 secret key for the Diffie-Hellman key exchange\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverEd25519SecretKey The receiver's Ed25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptObject<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): T {\n  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(receiverEd25519SecretKey);\n  return decryptObjectDirect<T>(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);\n}\n\n/**\n * Decrypts an object, by using the sender's X25519 public key and receiver's X25519 secret key\n * @param senderX25519PublicKey The sender's X25519 public key\n * @param receiverX25519SecretKey The receiver's X25519 secret key\n * @param securedMessage The message to decrypt\n * @param nonce The nonce used to encrypt the message\n */\nexport function decryptObjectDirect<T>(\n  senderX25519PublicKey: X25519PublicKey,\n  receiverX25519SecretKey: X25519SecretKey,\n  securedMessage: Uint8Array,\n  nonce: Uint8Array,\n): T {\n  const decryptedStr = decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);\n  return JSON.parse(decryptedStr) as T;\n}\n\n/**\n * Hashes a message with a purpose-specific prefix using SHA-3 256-bit algorithm.\n * The purpose prefix is constructed as `'APTOS::IDENTITY_CONNECT' + '::' + purpose + '::'`\n * This is to prevent hash collisions with other services, uses, and purposes\n * @param message The message to hash as a Uint8Array.\n * @param purpose The purpose of the signature.\n * @returns Uint8Array The hashed message as a Uint8Array\n */\nexport function messageHash(message: Uint8Array, purpose: SignaturePurpose) {\n  const signaturePrefixHash = new Uint8Array(sha3_256(`${SIGNATURE_PREFIX}::${purpose}::`));\n  return new Uint8Array(sha3_256(concatUint8array(signaturePrefixHash, message)));\n}\n\nexport function signWithEd25519SecretKey(\n  message: Uint8Array,\n  signingEd25519SecretKey: Ed25519SecretKey,\n  purpose: SignaturePurpose,\n) {\n  return nacl.sign.detached(messageHash(message, purpose), signingEd25519SecretKey.key);\n}\n\n// This assumes that domain separation has already happened: this emulates the behavior of a hardware device\nexport function makeEd25519SecretKeySignCallbackNoDomainSeparation(\n  signingEd25519SecretKey: Ed25519SecretKey,\n): SignCallback {\n  return async (message: Uint8Array) => new Ed25519Signature(nacl.sign.detached(message, signingEd25519SecretKey.key));\n}\n\nexport function verifySignature(\n  message: Uint8Array,\n  signature: Signature,\n  signingPublicKey: PublicKey,\n  purpose: SignaturePurpose,\n): boolean {\n  return signingPublicKey.verifySignature({ message: messageHash(message, purpose), signature });\n}\n\nexport function hashAndVerifySignature(\n  message: string | Uint8Array,\n  signature: Signature,\n  signingPublicKey: PublicKey,\n  purpose: SignaturePurpose,\n): boolean {\n  const messageUint8 = message instanceof Uint8Array ? message : new TextEncoder().encode(message);\n  const messageUint8Hash = sha3_256(messageUint8);\n  return verifySignature(messageUint8Hash, signature, signingPublicKey, purpose);\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport class EncryptionEnvelopeError extends Error {}\n\nexport class EnvelopeMessageMismatchError extends EncryptionEnvelopeError {\n  constructor(\n    message: string,\n    public field: string,\n  ) {\n    super(message);\n    this.name = 'EnvelopeMessageMismatchError';\n    Object.setPrototypeOf(this, EnvelopeMessageMismatchError.prototype);\n  }\n}\n\nexport class DecryptionError extends EncryptionEnvelopeError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DecryptionError';\n    Object.setPrototypeOf(this, DecryptionError.prototype);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport nacl from 'tweetnacl';\n\nexport enum KeyTypes {\n  'Ed25519PublicKey' = 'Ed25519PublicKey',\n  'Ed25519SecretKey' = 'Ed25519SecretKey',\n  'X25519PublicKey' = 'X25519PublicKey',\n  'X25519SecretKey' = 'X25519SecretKey',\n}\n\nexport interface IKey<Type extends KeyTypes> {\n  key: Uint8Array;\n  type: Type;\n}\n\nexport type X25519PublicKey = IKey<KeyTypes.X25519PublicKey>;\nexport type X25519SecretKey = IKey<KeyTypes.X25519SecretKey>;\nexport type X25519KeyPair = {\n  publicKey: X25519PublicKey;\n  secretKey: X25519SecretKey;\n};\n\nexport type Ed25519PublicKey = IKey<KeyTypes.Ed25519PublicKey>;\nexport type Ed25519SecretKey = IKey<KeyTypes.Ed25519SecretKey>;\nexport type Ed25519KeyPair = {\n  publicKey: Ed25519PublicKey;\n  secretKey: Ed25519SecretKey;\n};\n\nexport type RawKeyPair = {\n  publicKey: Uint8Array;\n  secretKey: Uint8Array;\n};\n\nexport function createX25519KeyPair(): X25519KeyPair {\n  return keypairToX25519(nacl.box.keyPair());\n}\n\nexport function createEd25519KeyPair(): Ed25519KeyPair {\n  return keypairToEd25519(nacl.sign.keyPair());\n}\n\nexport function toKey<Type extends KeyTypes = KeyTypes>(\n  rawKey: Uint8Array,\n  type: Type,\n): Type extends KeyTypes.Ed25519PublicKey\n  ? Ed25519PublicKey\n  : Type extends KeyTypes.Ed25519SecretKey\n    ? Ed25519SecretKey\n    : Type extends KeyTypes.X25519PublicKey\n      ? X25519PublicKey\n      : Type extends KeyTypes.X25519SecretKey\n        ? X25519SecretKey\n        : never {\n  return {\n    key: rawKey,\n    type,\n  } as any;\n}\n\nexport function keypairToEd25519(keyPair: RawKeyPair): Ed25519KeyPair {\n  return {\n    publicKey: toKey(keyPair.publicKey, KeyTypes.Ed25519PublicKey),\n    secretKey: toKey(keyPair.secretKey, KeyTypes.Ed25519SecretKey),\n  };\n}\n\nexport function keypairToX25519(keyPair: RawKeyPair): X25519KeyPair {\n  return {\n    publicKey: toKey(keyPair.publicKey, KeyTypes.X25519PublicKey),\n    secretKey: toKey(keyPair.secretKey, KeyTypes.X25519SecretKey),\n  };\n}\n\nexport function aptosAccountToEd25519Keypair(account: { signingKey: nacl.SignKeyPair }) {\n  return ed25519KeypairFromSecret(account.signingKey.secretKey);\n}\n\nexport function ed25519KeypairFromSecret(ed25519SecretKeyBytes: Uint8Array): Ed25519KeyPair {\n  return keypairToEd25519(nacl.sign.keyPair.fromSeed(ed25519SecretKeyBytes.slice(0, 32)));\n}\n\nexport function decodeBase64(base64Str: string): Uint8Array {\n  if (globalThis.Buffer) {\n    return new Uint8Array(Buffer.from(base64Str, 'base64'));\n  }\n  return Uint8Array.from(atob(base64Str), (m) => m.codePointAt(0)!);\n}\n\nexport function encodeBase64(bytes: Uint8Array): string {\n  if (globalThis.Buffer) {\n    return Buffer.from(bytes).toString('base64');\n  }\n  return btoa(Array.from(bytes, (x) => String.fromCodePoint(x)).join(''));\n}\n\nexport function concatUint8array(arrayOne: Uint8Array, arrayTwo: Uint8Array): Uint8Array {\n  const mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);\n  mergedArray.set(arrayOne);\n  mergedArray.set(arrayTwo, arrayOne.length);\n  return mergedArray;\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Ed25519PublicKey as AptosEd25519PublicKey, Ed25519Signature, Hex } from '@aptos-labs/ts-sdk';\nimport { sha3_256 } from '@noble/hashes/sha3';\nimport {\n  createX25519KeyPair,\n  decodeBase64,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  X25519KeyPair,\n  KeyTypes,\n  toKey,\n  X25519PublicKey,\n} from './utils';\nimport { EnvelopeMessageMismatchError } from './errors';\nimport {\n  SerializedEncryptionResult,\n  SignCallback,\n  decryptObject,\n  encryptObject,\n  serializeEncryptionResult,\n  deserializeEncryptionResult,\n  verifySignature,\n  signWithEd25519SecretKey,\n} from './encrDecr';\n\n/**\n * When sending messages back and forth, there are some things that Identity Connect must know to function and provide\n * security for users, and dApps and wallets need to know that any messages sent to one another were sent (and\n * received) by the expected parties.\n *\n * To allow for secure communication between parties, we are introducing the\n * *SecuredEnvelope*. This envelope provides a secure channel for parties to encrypt private messages, *and*\n * authenticate one another, while allowing IC to route requests and block invalid messages.\n *\n * The envelope can be thought of as a wrapper around the JSON payload of a POST/PUT request T, and has two parts:\n * `messagePrivate`: This contains some of the parameters of `T`, which will be signed by the sender and encrypted\n *                   with the recipient's public key.\n * `publicMessage`: This field is sent unencrypted, but signed so that the IC endpoint can do basic validation before\n *                  processing. The parameters in `publicMessage` are DISJOINT from `messagePrivate`, and are invalid\n *                  otherwise: there are no keys in `messagePrivate` that also appear in `publicMessage`. It must\n *                  contain a ``_metadata`` field with security features like the timestamp, public keys, sequence\n *                  number, etc.\n *\n * Both IC and dApps can verify, on chain, that the senders’ keys match their address and that they are speaking\n * with who they expect. Encryption is done with an X25519 key derived from the ED25519 PublicKey of the wallet\n * account that is connecting (this allows for seamless cross-device account access), and an ephemeral X25519 KeyPair,\n * of which the SecretKey is thrown away after encryption. Decryption uses the X25519 key derived from the receiver\n * ED25519 SecretKey.\n *\n * Account private keys Ska (and their counterpart X25519 keys) are only used to decrypt and sign:\n * THEY ARE NEVER USED TO ENCRYPT!\n *\n * Operations follow the Cryptographic Doom Principle:\n *   Always verify the signature of the message before any other cryptographic operations\n * https://moxie.org/2011/12/13/the-cryptographic-doom-principle.html\n *\n *\n * To send a `SecuredEnvelope` over the wire, it must first be turned into a `SecuredEnvelopeTransport` - this\n * involves:\n * 1. Encrypting and serializing the `privateMessage` field to an `encryptedPrivateMessage`field.\n *     a. Generate ephemeral X25519 sender keypair `xPkse/xSkse`. The `xPkse` becomes the `senderX25519PublicKeyB64` in\n *      the `EnvelopeMetadata`.\n *     b. Convert the `receiverEd25519PublicKey` to a `receiverX25519PublicKey` - `xPkr`\n *     c. Generate a random `nonce` for the `[nacl.box](http://nacl.box)` encryption\n *     d. Encrypt the `privateMessage` using `[nacl.box](http://nacl.box)` with the `xSkse` and `xPkr`\n *     e. Package this encrypted data, and the `nonce`, into a `SerializedEncryptionResult`\n * 2. JSON serializing the `publicMessage` field into a `serializedPublicMessage`. We don’t care about canonical\n *    serialization/ordering as the sender signs over this serialized string.\n * 3.  Now that we have the private `encryptedPrivateMessage` and public `serializedPublicMessage` we can generate the\n *    `messageSignature`:\n *     a. Hash the `SHA3-256(encryptedPublicMessage)` to get `publicMessageHash`\n *     b. Hash the `SHA3-256(encryptedPrivateMessage)` to get `privateMessageHash`\n *     c. Hash `SHA3-256(publicMessageHash | privateMessageHash)` to get `combinedMessageHash`\n *     d. Get the `domainSeparatedMessageHash` by hashing the `combinedMessageHash` with a domain separator:\n *        `SHA3-256(SHA3-256('APTOS::IDENTITY_CONNECT::') | combinedMessageHash)`\n *     e. To obtain the final `messageSignature`, we sign the `domainSeparatedMessageHash` with the Ed25519 private\n *        key of the sender, and hex encode it.\n * 4. This creates the final `SecuredEnvelopeTransport` object, ready to be JSON serialized and sent in an HTTP\n *    request\n */\n\nexport const REQUIRED_FIELDS: (keyof EnvelopeMetadata)[] = [\n  'receiverEd25519PublicKeyB64',\n  'senderEd25519PublicKeyB64',\n  'senderX25519PublicKeyB64',\n  'sequence',\n  'timestampMillis',\n].sort() as (keyof EnvelopeMetadata)[];\n\n// The publicMessage._metadata field looks like this:\nexport type EnvelopeMetadata = {\n  // The receiver's public key, base64\n  receiverEd25519PublicKeyB64: string;\n  // The sender public key, base64\n  senderEd25519PublicKeyB64: string;\n  // The senders X25519 public key, base64\n  senderX25519PublicKeyB64: string;\n  // The sequence of the sender.\n  // This number only goes up, to prevent relay attacks\n  // This exists per pairing\n  // dApps, wallets, accounts, etc are expected to keep track of them\n  // IC will reject out-of-order sequence numbers\n  sequence: number;\n  // The timestamp this message was sent at\n  // IC will reject if it's in the future or older than 5 minutes\n  timestampMillis: number;\n};\n\nexport interface IEnvelopeMetadata extends Message {\n  _metadata: EnvelopeMetadata;\n}\n\n// A message- whether the `Public` or `Private` component- is a JSON object.\n// As such, we know that the keys are strings, and the values are any JSON-serializable type ('unknown')\nexport type Message = Record<string, unknown>;\n\nexport type SecuredEnvelope<Public extends Message> = {\n  encryptedPrivateMessage: SerializedEncryptionResult;\n  messageSignature: string;\n  publicMessage: Public & IEnvelopeMetadata;\n};\n\nexport type SecuredEnvelopeTransport = {\n  encryptedPrivateMessage: SerializedEncryptionResult;\n  messageSignature: string;\n  serializedPublicMessage: string;\n};\n\nexport type DecryptedEnvelope<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n> = {\n  messageSignature: string;\n  privateMessage: Private;\n  publicMessage: Public & IEnvelopeMetadata;\n};\n\nexport type DeserializedTransportEnvelope<Public extends Message> = SecuredEnvelopeTransport & SecuredEnvelope<Public>;\n\nexport type SignCallbackOrEd25519SecretKey = SignCallback | Ed25519SecretKey;\n\nexport function ensurePrivatePublicFieldsDisjoint<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(privateMessage: Private, publicMessage: Public) {\n  // gets all fields in privateMessage that are also in publicMessage\n  const intersection = Object.keys(privateMessage).filter((x) => Object.keys(publicMessage).includes(x));\n  if (intersection.length > 0) {\n    const field = intersection[0];\n    throw new EnvelopeMessageMismatchError(`Field ${field} appears in both private and public message fields`, field);\n  }\n}\n\nexport function ensureMetadataFields(message: EnvelopeMetadata) {\n  // ensure ONLY the fields in REQUIRED_FIELDS are present in message. Sort asc.\n  const messageKeys = Object.keys(message).sort();\n  const extraFields = messageKeys.filter((key) => !REQUIRED_FIELDS.includes(key as any));\n  const missingFields = REQUIRED_FIELDS.filter((key) => !messageKeys.includes(key as any));\n  if (extraFields.length > 0 || missingFields.length > 0) {\n    let extraFieldsStr = extraFields.length > 0 ? `extra(${extraFields.join(', ')})` : '';\n    const missingFieldsStr = missingFields.length > 0 ? `missing(${missingFields.join(', ')})` : '';\n    extraFieldsStr = extraFieldsStr.length > 0 && missingFieldsStr.length > 0 ? `${extraFieldsStr}, ` : extraFieldsStr;\n    throw new EnvelopeMessageMismatchError(\n      `PublicMessage metadata fields do not conform to spec: ${extraFieldsStr}${missingFieldsStr}`,\n      '_metadata',\n    );\n  }\n}\n\nexport function deserializeTransportEnvelope<Public extends Message>(\n  transportEnvelope: SecuredEnvelopeTransport,\n): DeserializedTransportEnvelope<Public> {\n  const publicMessage = JSON.parse(transportEnvelope.serializedPublicMessage) as Public & IEnvelopeMetadata;\n  return {\n    ...transportEnvelope,\n    publicMessage,\n  };\n}\n\n// This signs with the senders ed25519 private key,\n// but encrypts with an ephemeral X25519 keyPair + the receivers x25519 public key (converted from their ed25519 key)\n// This is so that the private key IS ONLY EVER USED FOR DECRYPTION, NEVER FOR ENCRYPTION\nexport function encryptAndSignEnvelope<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(\n  senderEd25519SecretKey: Ed25519SecretKey,\n  senderEd25519PublicKey: Ed25519PublicKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  sequence: number,\n  publicMessage: Public,\n  privateMessage: Private,\n): SecuredEnvelopeTransport {\n  const senderEphemeralX25519KeyPair = createX25519KeyPair();\n  const metadata = constructMetadata(\n    senderEd25519PublicKey,\n    receiverEd25519PublicKey,\n    sequence,\n    senderEphemeralX25519KeyPair.publicKey,\n  );\n\n  ensureMetadataFields(metadata);\n  ensurePrivatePublicFieldsDisjoint<Public, Private>(privateMessage, publicMessage);\n\n  return dangerouslyEncryptAndSignEnvelopeUnvalidated(\n    senderEd25519SecretKey,\n    receiverEd25519PublicKey,\n    metadata,\n    privateMessage,\n    publicMessage,\n    senderEphemeralX25519KeyPair,\n  );\n}\n\nexport function constructMetadata(\n  senderEd25519PublicKey: Ed25519PublicKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  sequence: number,\n  senderEphemeralX25519PublicKey: X25519PublicKey,\n): EnvelopeMetadata {\n  // This is used for SIGNING ONLY!\n  return {\n    receiverEd25519PublicKeyB64: encodeBase64(receiverEd25519PublicKey.key),\n    senderEd25519PublicKeyB64: encodeBase64(senderEd25519PublicKey.key),\n    senderX25519PublicKeyB64: encodeBase64(senderEphemeralX25519PublicKey.key),\n    sequence,\n    timestampMillis: Date.now(),\n  };\n}\n\nexport function dangerouslyEncryptAndSignEnvelopeUnvalidated<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(\n  senderEd25519SecretKey: Ed25519SecretKey,\n  receiverEd25519PublicKey: Ed25519PublicKey,\n  metadata: EnvelopeMetadata,\n  privateMessage: Private,\n  publicMessage: Public,\n  senderEphemeralX25519KeyPair: X25519KeyPair,\n): SecuredEnvelopeTransport {\n  const encryptionResult = encryptObject(\n    senderEphemeralX25519KeyPair.secretKey,\n    receiverEd25519PublicKey,\n    privateMessage,\n  );\n  const encryptedPrivateMessage = serializeEncryptionResult(encryptionResult);\n  const encryptedPrivateMessageBytes = decodeBase64(encryptedPrivateMessage.securedB64);\n  const serializedPublicMessage = JSON.stringify({ ...publicMessage, _metadata: metadata });\n  const publicMessageBytes = new TextEncoder().encode(serializedPublicMessage);\n  const messageSignature = signEnvelope(publicMessageBytes, encryptedPrivateMessageBytes, senderEd25519SecretKey);\n  return {\n    encryptedPrivateMessage,\n    messageSignature,\n    serializedPublicMessage,\n  };\n}\n\nfunction combineHashedEnvelopeMessageBytes(\n  publicMessageBytes: Uint8Array,\n  privateMessageBytes: Uint8Array,\n): Uint8Array {\n  const publicMessageBytesHash = sha3_256(publicMessageBytes);\n  const privateMessageBytesHash = sha3_256(privateMessageBytes);\n  // Concatenate the two hashes\n  const combinedHash = new Uint8Array(publicMessageBytesHash.length + privateMessageBytesHash.length);\n  combinedHash.set(publicMessageBytesHash);\n  combinedHash.set(privateMessageBytesHash, publicMessageBytesHash.length);\n  // Hash and return\n  return sha3_256(combinedHash);\n}\n\nfunction signEnvelope(\n  publicMessageBytes: Uint8Array,\n  privateMessageBytes: Uint8Array,\n  senderEd25519SecretKey: Ed25519SecretKey,\n) {\n  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);\n  const signatureBytes = signWithEd25519SecretKey(messageHashBytes, senderEd25519SecretKey, 'SECURED_ENVELOPE');\n  return Hex.fromHexInput(signatureBytes).toString();\n}\n\nexport function verifyEnvelopeSignature(\n  publicMessageBytes: Uint8Array,\n  privateMessageBytes: Uint8Array,\n  messageSignatureInput: string,\n  senderEd25519PublicKey: Ed25519PublicKey,\n) {\n  const messageSignature = new Ed25519Signature(Hex.fromHexInput(messageSignatureInput).toUint8Array());\n  const senderPublicKey = new AptosEd25519PublicKey(senderEd25519PublicKey.key);\n  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);\n  const messageVerified = verifySignature(messageHashBytes, messageSignature, senderPublicKey, 'SECURED_ENVELOPE');\n  if (!messageVerified) {\n    throw new EnvelopeMessageMismatchError('Could not verify SecuredEnvelope signature', 'messageSignature');\n  }\n}\n\nexport function decryptEnvelope<\n  Public extends Message & { [K in keyof Private]?: never },\n  Private extends Message & { [K in keyof Public]?: never },\n>(\n  senderEd25519PublicKey: Ed25519PublicKey,\n  receiverEd25519SecretKey: Ed25519SecretKey,\n  message: SecuredEnvelopeTransport,\n): DecryptedEnvelope<Public, Private> {\n  const { encryptedPrivateMessage, messageSignature, serializedPublicMessage } = message;\n  const publicMessage = JSON.parse(serializedPublicMessage) as Public & IEnvelopeMetadata;\n\n  // Ensure the private/public message signature matches the expected signature\n  const rawPrivateMessage = decodeBase64(encryptedPrivateMessage.securedB64);\n  const rawPublicMessage = new TextEncoder().encode(serializedPublicMessage);\n  verifyEnvelopeSignature(rawPublicMessage, rawPrivateMessage, messageSignature, senderEd25519PublicKey);\n\n  // Ensure the public key matches the expected public key\n  const senderEd25519PublicKeyB64 = encodeBase64(senderEd25519PublicKey.key);\n  const expectedPublicKeyB64 = publicMessage._metadata.senderEd25519PublicKeyB64;\n  if (senderEd25519PublicKeyB64 !== expectedPublicKeyB64) {\n    throw new EnvelopeMessageMismatchError(\n      'senderEd25519PublicKey in envelope does not match provided receiverEd25519SecretKey',\n      'senderPublicKey',\n    );\n  }\n\n  const senderX25519PublicKeyBytes = decodeBase64(publicMessage._metadata.senderX25519PublicKeyB64);\n  const senderX25519PublicKey = toKey(senderX25519PublicKeyBytes, KeyTypes.X25519PublicKey);\n  const encryptionResult = deserializeEncryptionResult(encryptedPrivateMessage);\n  const privateMessage = decryptObject<Private>(\n    senderX25519PublicKey,\n    receiverEd25519SecretKey,\n    encryptionResult.secured,\n    encryptionResult.nonce,\n  );\n\n  ensureMetadataFields(publicMessage._metadata);\n  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);\n\n  return {\n    messageSignature,\n    privateMessage,\n    publicMessage,\n  };\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  base64ToBytes,\n  bytesToBase64,\n  deserializePublicKey,\n  deserializeSignature,\n  serializePublicKey,\n  serializeSignature,\n} from '@aptos-connect/wallet-api';\nimport {\n  AccountPublicKey,\n  Deserializer,\n  Ed25519PublicKey as AptosEd25519PublicKey,\n  Ed25519Signature,\n  Hex,\n  PublicKey,\n  Serializer,\n  Signature,\n} from '@aptos-labs/ts-sdk';\nimport { decodeBase64 } from './utils';\n\nexport function serializePublicKeyB64(publicKey: PublicKey) {\n  const serializer = new Serializer();\n  serializePublicKey(serializer, publicKey);\n  return bytesToBase64(serializer.toUint8Array());\n}\n\nexport function deserializePublicKeyB64(publicKeyB64: string) {\n  const serializedPublicKey = base64ToBytes(publicKeyB64);\n  const deserializer = new Deserializer(serializedPublicKey);\n  return deserializePublicKey(deserializer) as AccountPublicKey;\n}\n\nexport function deserializeEd25519PublicKeyB64(ed25519PublicKeyB64: string) {\n  return new AptosEd25519PublicKey(decodeBase64(ed25519PublicKeyB64));\n}\n\nexport function serializeSignatureB64(signature: Signature) {\n  const serializer = new Serializer();\n  serializeSignature(serializer, signature);\n  return bytesToBase64(serializer.toUint8Array());\n}\n\nexport function deserializeSignatureB64(signatureB64: string) {\n  const serializedSignature = base64ToBytes(signatureB64);\n  const deserializer = new Deserializer(serializedSignature);\n  return deserializeSignature(deserializer);\n}\n\nexport function deserializeEd25519SignatureB64(ed25519SignatureB64: string) {\n  const signatureBytes = Hex.fromHexInput(ed25519SignatureB64).toUint8Array();\n  return new Ed25519Signature(signatureBytes);\n}\n\nexport function publicKeyB64FromEd25519PublicKeyB64(ed25519PublicKeyB64: string) {\n  const publicKey = deserializeEd25519PublicKeyB64(ed25519PublicKeyB64);\n  return serializePublicKeyB64(publicKey);\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n// Adding or removing an account? This will be idempotent, but racy\nimport { Account, AccountPublicKey, PublicKey as AptosPublicKey, Signature } from '@aptos-labs/ts-sdk';\nimport { sha3_256 } from '@noble/hashes/sha3';\nimport { messageHash, signWithEd25519SecretKey } from './encrDecr';\nimport { serializePublicKeyB64, serializeSignatureB64 } from './serialization';\nimport { Ed25519KeyPair, ed25519KeypairFromSecret, Ed25519PublicKey, Ed25519SecretKey, encodeBase64 } from './utils';\n\n// ADD/REMOVE is used for account connections\nexport enum AccountConnectionAction {\n  ADD = 'add',\n  REMOVE = 'remove',\n}\n\n/**\n * When a wallet wants to create a pairing, or add/remove an account from a wallet connection, it must prove that it\n * has the secret key for a given account. To do so it uses an `AccountConnectInfo` object.\n *  1. Once the `AccountConnectInfo` is assembled, it’s JSON serialized to get a `accountInfoSerialized` string.\n *  2. We then domain separate and hash the `accountInfoSerialized` to get the `accountInfoHash`:\n *    `SHA3-256(SHA3-256('APTOS::IDENTITY_CONNECT::') | SHA3-256(accountInfoSerialized))`\n *  3. To obtain the `signature`, we sign the `accountInfoHash` with the Ed25519 private key of the sender, and hex\n *     encode it.\n *  4. These are assembled into an `AccountConnectInfoSerialized`, ready to be sent in an HTTP request.\n */\n\nexport type BaseAccountConnectInfo = {\n  // The account address\n  accountAddress: string;\n  // either 'add' or 'remove'\n  action: AccountConnectionAction;\n  // A unique identifier for this connection: it is either the walletId or the pairingId\n  // Prevents replay attacks across wallets\n  intentId: string;\n  // Prevents replay attacks across time- these are only valid for 5 minutes\n  timestampMillis: number;\n  // The public key for the encrypted e2e channel, base64\n  transportEd25519PublicKeyB64: string;\n};\n\nexport type Ed25519AccountConnectInfo = BaseAccountConnectInfo & {\n  // The account ed25519 public key, base64\n  ed25519PublicKeyB64: string;\n  publicKeyB64?: undefined;\n};\n\nexport type AnyAccountConnectInfo = BaseAccountConnectInfo & {\n  ed25519PublicKeyB64?: undefined;\n  // The account public key, bcs-serialized and base64-encoded\n  publicKeyB64: string;\n};\n\n// Ensuring compatibility with previous wallet-sdk versions\nexport type AccountConnectInfo = Ed25519AccountConnectInfo | AnyAccountConnectInfo;\n\nexport type Ed25519AccountConnectInfoSerialized = {\n  accountInfoSerialized: string;\n  signature: string;\n  signatureB64?: undefined;\n};\n\nexport type AnyAccountConnectInfoSerialized = {\n  accountInfoSerialized: string;\n  signature?: undefined;\n  signatureB64: string;\n};\n\nexport type AccountConnectInfoSerialized = Ed25519AccountConnectInfoSerialized | AnyAccountConnectInfoSerialized;\n\nexport type SyncSignCallback = (message: Uint8Array) => Signature;\nexport type AsyncSignCallback = (message: Uint8Array) => Promise<Signature>;\nexport type AnySignCallback = SyncSignCallback | AsyncSignCallback;\n\nexport function deriveAccountTransportEd25519Keypair(\n  ed25519SecretKey: Ed25519SecretKey,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Ed25519KeyPair;\n\nexport function deriveAccountTransportEd25519Keypair(\n  signCallback: SyncSignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Ed25519KeyPair;\n\nexport async function deriveAccountTransportEd25519Keypair(\n  signCallback: AsyncSignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Promise<Ed25519KeyPair>;\n\nexport function deriveAccountTransportEd25519Keypair(\n  signCallback: AnySignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n): Ed25519KeyPair | Promise<Ed25519KeyPair>;\n\nexport function deriveAccountTransportEd25519Keypair(\n  ed25519SecretKeyOrSignCallback: Ed25519SecretKey | AnySignCallback,\n  publicKey: Ed25519PublicKey | AptosPublicKey,\n) {\n  const publicKeyBytes = publicKey instanceof AptosPublicKey ? publicKey.toUint8Array() : publicKey.key;\n  if (ed25519SecretKeyOrSignCallback instanceof Function) {\n    const seedGeneratorBytes = messageHash(publicKeyBytes, 'TRANSPORT_KEYPAIR');\n    const signature = ed25519SecretKeyOrSignCallback(seedGeneratorBytes);\n    if (signature instanceof Promise) {\n      return signature.then((value) => ed25519KeypairFromSecret(value.toUint8Array()));\n    }\n    return ed25519KeypairFromSecret(signature.toUint8Array());\n  }\n\n  const seedBytes = signWithEd25519SecretKey(publicKeyBytes, ed25519SecretKeyOrSignCallback, 'TRANSPORT_KEYPAIR');\n  return ed25519KeypairFromSecret(seedBytes);\n}\n\nexport type CreateSerializedAccountInfoArgs<TSignCallback extends AnySignCallback> = [\n  signCallback: TSignCallback,\n  publicKey: AccountPublicKey,\n  transportEd25519PublicKey: Ed25519PublicKey,\n  action: AccountConnectionAction,\n  intentId: string,\n  accountAddress?: string,\n];\n\nexport function createSerializedAccountInfo(\n  ...args: CreateSerializedAccountInfoArgs<SyncSignCallback>\n): AccountConnectInfoSerialized;\nexport function createSerializedAccountInfo(\n  ...args: CreateSerializedAccountInfoArgs<AsyncSignCallback>\n): Promise<AccountConnectInfoSerialized>;\nexport function createSerializedAccountInfo(\n  ...args: CreateSerializedAccountInfoArgs<AnySignCallback>\n): AccountConnectInfoSerialized | Promise<AccountConnectInfoSerialized>;\n\nexport function createSerializedAccountInfo(\n  ...[\n    signCallback,\n    publicKey,\n    transportEd25519PublicKey,\n    action,\n    intentId,\n    accountAddress,\n  ]: CreateSerializedAccountInfoArgs<AnySignCallback>\n): AccountConnectInfoSerialized | Promise<AccountConnectInfoSerialized> {\n  // TODO: WRITE TESTS FOR THIS!\n\n  // Either the passed in Pk, or the Pk derived from the Sk\n  const authKey = publicKey.authKey();\n\n  // Either the passed in account address, or the one derived from the authKey: (either Pk, or derived from Sk)\n  const finalAccountAddress = accountAddress || authKey.derivedAddress().toString();\n  const publicKeyB64 = serializePublicKeyB64(publicKey);\n\n  const accountInfo: AccountConnectInfo = {\n    accountAddress: finalAccountAddress,\n    action,\n    intentId,\n    publicKeyB64,\n    timestampMillis: Date.now(),\n    transportEd25519PublicKeyB64: encodeBase64(transportEd25519PublicKey.key),\n  };\n  const accountInfoSerialized = JSON.stringify(accountInfo);\n  const accountInfoBytes = new TextEncoder().encode(accountInfoSerialized);\n  const accountInfoHash = sha3_256(accountInfoBytes);\n\n  const signature = signCallback(messageHash(accountInfoHash, 'ACCOUNT_INFO'));\n  if (signature instanceof Promise) {\n    return signature.then((value) => ({\n      accountInfoSerialized,\n      signatureB64: serializeSignatureB64(value),\n    }));\n  }\n  return {\n    accountInfoSerialized,\n    signatureB64: serializeSignatureB64(signature),\n  };\n}\n\nexport async function aptosAccountToSerializedInfo(\n  account: Account,\n  intentId: string,\n): Promise<AccountConnectInfoSerialized> {\n  const signCallback = async (data: Uint8Array) => account.sign(data);\n  const transportKey = await deriveAccountTransportEd25519Keypair(signCallback, account.publicKey);\n  return createSerializedAccountInfo(\n    signCallback,\n    account.publicKey,\n    transportKey.publicKey,\n    AccountConnectionAction.ADD,\n    intentId,\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}