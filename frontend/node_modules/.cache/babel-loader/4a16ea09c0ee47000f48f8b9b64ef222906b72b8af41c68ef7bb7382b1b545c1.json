{"ast":null,"code":"// src/ACDappClient.ts\nimport { chainIdToNetwork, ConnectRequest, ConnectResponse, DisconnectRequest, GetConnectedAccountsRequest, GetConnectedAccountsResponse, makeUserApproval, SignAndSubmitTransactionRequest, SignAndSubmitTransactionResponse, SignInRequest, SignInResponse, SignMessageRequest, SignMessageResponse, SignTransactionRequest, SignTransactionResponse } from \"@aptos-connect/wallet-api\";\nimport { WebWalletTransport } from \"@aptos-connect/web-transport\";\nimport { AccountAddress as AccountAddress3, AnySignature, AptosConfig as AptosConfig2, Deserializer, Ed25519Signature, FeePayerRawTransaction, generateRawTransaction, Hex } from \"@aptos-labs/ts-sdk\";\nimport { NetworkName as NetworkName2 } from \"@identity-connect/api\";\nimport { createEd25519KeyPair, encodeBase64 as encodeBase642 } from \"@identity-connect/crypto\";\n\n// src/constants.ts\nvar DEFAULT_FRONTEND_URL = \"https://aptosconnect.app\";\n\n// src/conversion.ts\nimport { AccountAddress, generateTransactionPayload, generateTransactionPayloadWithABI } from \"@aptos-labs/ts-sdk\";\nfunction convertToSerializableArgument(argument) {\n  if (argument === void 0 || argument === null) {\n    return argument;\n  }\n  if (Array.isArray(argument)) {\n    return argument.map(subArgument => convertToSerializableArgument(subArgument));\n  }\n  if (typeof argument === \"string\" || typeof argument === \"number\" || typeof argument === \"boolean\" || argument instanceof Uint8Array) {\n    return argument;\n  }\n  if (typeof argument === \"bigint\") {\n    return argument.toString();\n  }\n  if (argument instanceof ArrayBuffer) {\n    return new Uint8Array(argument);\n  }\n  if (\"values\" in argument) {\n    return argument.values.map(subArgument => convertToSerializableArgument(subArgument));\n  }\n  if (\"data\" in argument) {\n    return AccountAddress.from(argument.data).toString();\n  }\n  if (argument.value === void 0) {\n    return void 0;\n  }\n  if (typeof argument.value === \"string\" || typeof argument.value === \"number\" || typeof argument.value === \"boolean\" || argument.value instanceof Uint8Array) {\n    return argument.value;\n  }\n  if (typeof argument.value === \"bigint\") {\n    return argument.value.toString();\n  }\n  throw new Error(\"Unexpected argument\");\n}\nfunction normalizePayloadForIC(payload, aptosConfig) {\n  if (\"bcsToBytes\" in payload) {\n    return payload;\n  }\n  if (\"bytecode\" in payload) {\n    return generateTransactionPayload(payload);\n  }\n  if (aptosConfig) {\n    return payload.abi !== void 0 ? generateTransactionPayloadWithABI({\n      ...payload,\n      abi: payload.abi\n    }) : generateTransactionPayload({\n      aptosConfig,\n      ...payload\n    });\n  }\n  const entryFunctionPayload = {\n    arguments: payload.functionArguments.map(convertToSerializableArgument),\n    function: payload.function,\n    type: \"entry_function_payload\",\n    type_arguments: (payload.typeArguments ?? []).map(ta => ta.toString())\n  };\n  return \"multisigAddress\" in payload ? {\n    multisig_address: AccountAddress.from(payload.multisigAddress).toString(),\n    transaction_payload: entryFunctionPayload,\n    type: \"multisig_payload\"\n  } : entryFunctionPayload;\n}\n\n// src/PairingClient.ts\nimport { AccountAddress as AccountAddress2 } from \"@aptos-labs/ts-sdk\";\nimport { NetworkName, SigningRequestStatus, SigningRequestTypes } from \"@identity-connect/api\";\nimport { decodeBase64, decryptEnvelope, deserializeEd25519PublicKeyB64, deserializePublicKeyB64, encodeBase64, encryptAndSignEnvelope, KeyTypes, toKey } from \"@identity-connect/crypto\";\nimport { deserializeSignTransactionResponseArgs, serializeSignAndSubmitTransactionRequestArgs, serializeSignTransactionRequestArgs } from \"@identity-connect/wallet-api\";\nimport axios, { AxiosError, isAxiosError } from \"axios\";\n\n// src/errors.ts\nvar SignatureRequestError = class _SignatureRequestError extends Error {\n  constructor(status) {\n    super(status);\n    this.name = \"SignatureRequestError\";\n    Object.setPrototypeOf(this, _SignatureRequestError.prototype);\n  }\n};\nvar UnexpectedSignatureResponseError = class _UnexpectedSignatureResponseError extends Error {\n  constructor(missingFields) {\n    const message = `Missing the following fields: ${missingFields.join(\", \")}`;\n    super(message);\n    this.name = \"UnexpectedSignatureResponseError\";\n    Object.setPrototypeOf(this, _UnexpectedSignatureResponseError.prototype);\n  }\n};\nvar PairingExpiredError = class _PairingExpiredError extends Error {\n  constructor() {\n    super();\n    this.name = \"PairingExpiredError\";\n    Object.setPrototypeOf(this, _PairingExpiredError.prototype);\n  }\n};\nvar UnregisteredDappError = class _UnregisteredDappError extends Error {\n  constructor() {\n    super(\"Dapp ID is invalid or not associated with a registered Dapp.\");\n    this.name = \"UnregisteredDappError\";\n    Object.setPrototypeOf(this, _UnregisteredDappError.prototype);\n  }\n};\n\n// src/state.ts\nvar DAPP_PAIRINGS_WINDOW_STORAGE_KEY = \"icDappPairings\";\nvar windowStateAccessors = {\n  async get(address) {\n    const pairings = await this.getAll();\n    return pairings[address];\n  },\n  async getAll() {\n    const serialized = window.localStorage.getItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY);\n    return serialized ? JSON.parse(serialized) : {};\n  },\n  async update(address, pairing) {\n    const pairings = await this.getAll();\n    if (pairing === void 0) {\n      delete pairings[address];\n    } else {\n      pairings[address] = pairing;\n    }\n    const newSerialized = JSON.stringify(pairings);\n    window.localStorage.setItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY, newSerialized);\n  }\n};\n\n// src/utils.ts\nvar SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS = [\"address\", \"application\", \"chainId\", \"fullMessage\", \"message\", \"nonce\", \"prefix\", \"signature\"];\nfunction validateSignMessageResponse(response) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter(field => !providedFields.has(field));\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\nvar SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS = [\"hash\"];\nfunction validateSignAndSubmitTransactionResponse(response) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(field => !providedFields.has(field));\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n\n// src/PairingClient.ts\nvar API_VERSION = \"0.2.0\";\nvar SIGNING_REQUEST_POLLING_INTERVAL = 2500;\nvar SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\\S+ to be )?(\\d+)/;\nasync function waitFor(milliseconds) {\n  return new Promise(resolve => {\n    setTimeout(resolve, milliseconds);\n  });\n}\nasync function withRetries(requestFn, onError, retries = 1) {\n  for (let i = 0; i < retries; i += 1) {\n    try {\n      return await requestFn();\n    } catch (err) {\n      onError(err);\n    }\n  }\n  return requestFn();\n}\nvar ACPairingClient = class {\n  constructor({\n    accessors = windowStateAccessors,\n    axiosConfig,\n    defaultNetworkName = NetworkName.MAINNET\n  } = {}) {\n    // endregion\n    this.onDisconnectListeners = /* @__PURE__ */new Set();\n    this.accessors = accessors;\n    this.defaultNetworkName = defaultNetworkName;\n    this.axiosInstance = axios.create({\n      baseURL: DEFAULT_FRONTEND_URL,\n      ...axiosConfig\n    });\n    const isClientSideRendering = typeof window !== \"undefined\";\n    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : void 0;\n  }\n  async getPairing(id) {\n    const response = await this.axiosInstance.get(`v1/pairing/${id}/`);\n    return response.data.data.pairing;\n  }\n  async syncFirstPairing() {\n    const pairings = await this.accessors.getAll();\n    const firstPairing = Object.values(pairings)[0];\n    if (firstPairing === void 0) {\n      return;\n    }\n    try {\n      const {\n        dappSpecificWallet,\n        maxDappSequenceNumber\n      } = await this.getPairing(firstPairing.pairingId);\n      await this.accessors.update(firstPairing.accountAddress, {\n        ...firstPairing,\n        currSequenceNumber: maxDappSequenceNumber,\n        dappWalletId: dappSpecificWallet?.id\n      });\n    } catch (err) {\n      await this.accessors.update(firstPairing.accountAddress, void 0);\n    }\n  }\n  async createSigningRequest(pairing, type, networkName, requestBody) {\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);\n    let sequenceNumber = pairing.currSequenceNumber + 1;\n    return withRetries(async () => {\n      const requestEnvelope = await encryptAndSignEnvelope(toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey), toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey), toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey), sequenceNumber, {\n        apiVersion: API_VERSION,\n        networkName,\n        requestType: type\n      }, requestBody);\n      const response = await this.axiosInstance.post(`v1/pairing/${pairing.pairingId}/signing-request/`, requestEnvelope);\n      await this.accessors.update(pairing.accountAddress, {\n        ...pairing,\n        currSequenceNumber: sequenceNumber\n      });\n      return response.data.data.signingRequest;\n    }, err => {\n      if (isAxiosError(err)) {\n        const errorMessage = err.response?.data?.message;\n        const expectedSequenceNumber = errorMessage?.match(SEQUENCE_NUMBER_MISMATCH_PATTERN)?.[1];\n        if (expectedSequenceNumber !== void 0) {\n          sequenceNumber = Number(expectedSequenceNumber);\n          return;\n        }\n      }\n      throw err;\n    });\n  }\n  async getSigningRequest(id) {\n    const response = await this.axiosInstance.get(`v1/signing-request/${id}/`, {\n      validateStatus: status => status === 200 || status === 404\n    });\n    return response.data?.data?.signingRequest;\n  }\n  async deletePairing(pairingId, secretKey, publicKey) {\n    const requestEnvelope = await encryptAndSignEnvelope(secretKey, publicKey, publicKey, 0,\n    // ignored\n    {}, {});\n    await this.axiosInstance.post(`v1/pairing/${pairingId}/delete/`, requestEnvelope, {\n      validateStatus: status => status === 204 || status === 404\n    });\n  }\n  async cancelSigningRequest(pairing, id) {\n    const sequenceNumber = pairing.currSequenceNumber;\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);\n    const requestEnvelope = await encryptAndSignEnvelope(toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey), toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey), toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey), sequenceNumber + 1, {}, {});\n    const response = await this.axiosInstance.patch(`v1/signing-request/${id}/cancel/`, requestEnvelope);\n    await this.accessors.update(pairing.accountAddress, {\n      ...pairing,\n      currSequenceNumber: sequenceNumber + 1\n    });\n    return response.data.data.signingRequest;\n  }\n  async signRequest(address, type, requestBody, {\n    cancelToken,\n    networkName\n  } = {}) {\n    await this.initPromise;\n    const pairing = await this.accessors.get(address);\n    if (pairing === void 0) {\n      throw new Error(\"The requested account is not paired\");\n    }\n    let signingRequest;\n    try {\n      signingRequest = await this.createSigningRequest(pairing, type, networkName || this.defaultNetworkName, requestBody);\n      while (signingRequest.status === \"PENDING\") {\n        await waitFor(SIGNING_REQUEST_POLLING_INTERVAL);\n        if (cancelToken?.cancelled) {\n          signingRequest.status = SigningRequestStatus.CANCELLED;\n          break;\n        }\n        signingRequest = (await this.getSigningRequest(signingRequest.id)) ?? signingRequest;\n      }\n    } catch (err) {\n      if (isAxiosError(err) && err.code === \"404\") {\n        await this.accessors.update(address, void 0);\n        for (const listener of this.onDisconnectListeners) {\n          listener(address);\n        }\n        throw new PairingExpiredError();\n      }\n      throw err;\n    }\n    if (signingRequest.status !== \"APPROVED\") {\n      throw new SignatureRequestError(signingRequest.status);\n    }\n    const decrypted = decryptEnvelope(toKey(decodeBase64(pairing.accountTransportEd25519PublicKeyB64), KeyTypes.Ed25519PublicKey), toKey(decodeBase64(pairing.dappEd25519SecretKeyB64), KeyTypes.Ed25519SecretKey), signingRequest.responseEnvelope);\n    return decrypted.privateMessage;\n  }\n  // region Public API\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async addPairing({\n    publicKey,\n    secretKey\n  }, finalizedPairing) {\n    await this.accessors.update(finalizedPairing.account.accountAddress, {\n      accountAddress: finalizedPairing.account.accountAddress,\n      accountAlias: finalizedPairing.account.userSubmittedAlias ?? void 0,\n      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,\n      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,\n      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,\n      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),\n      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),\n      dappWalletId: finalizedPairing.dappSpecificWalletId,\n      pairingId: finalizedPairing.id\n    });\n  }\n  async disconnect(address) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === void 0) {\n      throw new Error(\"The specified account is not paired\");\n    }\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    await this.deletePairing(pairing.pairingId, toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey), toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey));\n    await this.accessors.update(address, void 0);\n    for (const listener of this.onDisconnectListeners) {\n      listener(address);\n    }\n  }\n  async signMessage(address, args, options) {\n    const response = await this.signRequest(address, SigningRequestTypes.SIGN_MESSAGE, args, options);\n    validateSignMessageResponse(response);\n    return response;\n  }\n  async signTransaction(address, args, options) {\n    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);\n    const serializedResponseArgs = await this.signRequest(address, SigningRequestTypes.SIGN_TRANSACTION, serializedRequestArgs, options);\n    return deserializeSignTransactionResponseArgs(serializedResponseArgs);\n  }\n  // endregion\n  async signAndSubmitTransaction(address, args, options) {\n    const serializedRequestArgs = serializeSignAndSubmitTransactionRequestArgs(args);\n    try {\n      const responseArgs = await this.signRequest(address, SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION, serializedRequestArgs, options);\n      validateSignAndSubmitTransactionResponse(responseArgs);\n      return responseArgs;\n    } catch (e) {\n      if (e instanceof AxiosError && e.response?.data?.message) {\n        throw new Error(e.response?.data?.message);\n      }\n      throw e;\n    }\n  }\n  async getConnectedAccounts() {\n    await this.initPromise;\n    const pairings = await this.accessors.getAll();\n    return Object.values(pairings).map(({\n      accountAddress,\n      accountEd25519PublicKeyB64,\n      accountPublicKeyB64\n    }) => ({\n      address: AccountAddress2.from(accountAddress),\n      publicKey: accountPublicKeyB64 !== void 0 ? deserializePublicKeyB64(accountPublicKeyB64) : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64)\n    }));\n  }\n  onDisconnect(listener) {\n    this.onDisconnectListeners.add(listener);\n    return () => this.onDisconnectListeners.delete(listener);\n  }\n};\n\n// src/ACDappClient.ts\nvar ACDappClient = class {\n  constructor({\n    backendBaseURL,\n    dappId,\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName2.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    provider = \"google\",\n    tgWebAppURL\n  } = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title\n    };\n    this.transport = new WebWalletTransport(frontendBaseURL, provider, tgWebAppURL);\n    this.dappId = dappId;\n    this.pairingClient = new ACPairingClient({\n      axiosConfig: {\n        baseURL: backendBaseURL ?? frontendBaseURL\n      },\n      defaultNetworkName\n    });\n  }\n  // region Public API\n  async getKeylessAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async getIcAccounts() {\n    return this.pairingClient.getConnectedAccounts() ?? [];\n  }\n  async isIcAccount(address) {\n    const icAccounts = await this.getIcAccounts();\n    return icAccounts.find(account => account.address.equals(AccountAddress3.from(address))) !== void 0;\n  }\n  async getConnectedAccounts() {\n    const keylessAccounts = await this.getKeylessAccounts();\n    const icAccounts = await this.getIcAccounts();\n    return [...keylessAccounts, ...icAccounts];\n  }\n  async disconnect(address) {\n    if (await this.isIcAccount(address)) {\n      const stringAddress = AccountAddress3.from(address).toString();\n      await this.pairingClient.disconnect(stringAddress);\n    } else {\n      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);\n      await this.transport.sendRequest(serializedRequest);\n    }\n  }\n  async connect({\n    claimOptions,\n    preferredWalletName\n  } = {}) {\n    const dappKeypair = createEd25519KeyPair();\n    const injectedPreferredWalletName = typeof window !== \"undefined\" ? window.AC_PREFERRED_WALLET_NAME : void 0;\n    const requestArgs = {\n      claimOptions,\n      dappEd25519PublicKeyB64: encodeBase642(dappKeypair.publicKey.key),\n      dappId: this.dappId,\n      preferredWalletName: preferredWalletName ?? injectedPreferredWalletName\n    };\n    const serializedRequest = ConnectRequest.serialize(this.dappInfo, requestArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse.deserialize(serializedResponse);\n    if (response.args.status === \"approved\") {\n      const {\n        account,\n        pairing\n      } = response.args.args;\n      if (pairing) {\n        await this.pairingClient.addPairing(dappKeypair, pairing);\n      }\n      return makeUserApproval({\n        account\n      });\n    }\n    return response.args;\n  }\n  async signIn(args) {\n    const serializedRequest = SignInRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignInResponse.deserialize(serializedResponse, serializedRequest.version);\n    return response.args;\n  }\n  async signMessage(args) {\n    const {\n      signerAddress\n    } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        chainId\n      } = args;\n      const network = chainIdToNetwork(chainId);\n      let message;\n      let nonce;\n      try {\n        message = new TextDecoder().decode(args.message);\n        nonce = new TextDecoder().decode(args.nonce);\n      } catch (err) {\n        throw new Error(\"Only UTF-8 encoded text is supported when using IC\");\n      }\n      const {\n        fullMessage,\n        signature: hexSignature\n      } = await this.pairingClient.signMessage(signerAddress.toString(), {\n        address: true,\n        application: true,\n        chainId: true,\n        message,\n        nonce\n      }, {\n        networkName: network\n      });\n      const signatureBytes = Hex.fromHexInput(hexSignature).toUint8Array();\n      const signature = signatureBytes.length === Ed25519Signature.LENGTH ? new Ed25519Signature(signatureBytes) : AnySignature.deserialize(new Deserializer(signatureBytes));\n      return makeUserApproval({\n        fullMessage,\n        signature\n      });\n    }\n    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signTransaction(args) {\n    const normalizedArgs = \"transaction\" in args ? SignTransactionRequest.normalizeArgs(args) : args;\n    const {\n      signerAddress\n    } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        expirationSecondsFromNow,\n        expirationTimestamp,\n        feePayer,\n        gasUnitPrice,\n        maxGasAmount,\n        network,\n        payload,\n        secondarySigners,\n        sender,\n        sequenceNumber\n      } = normalizedArgs;\n      if (feePayer !== void 0) {\n        throw new Error(\"Sponsored transaction not currently supported\");\n      }\n      if (secondarySigners && secondarySigners.length > 0) {\n        throw new Error(\"Multi-agent transactions not currently supported\");\n      }\n      if (!(\"bcsToBytes\" in payload)) {\n        throw new Error(\"Payload input format is only supported with Keyless accounts.\");\n      }\n      const responseArgs = await this.pairingClient.signTransaction(signerAddress.toString(), {\n        options: {\n          expirationSecondsFromNow,\n          expirationTimestamp,\n          gasUnitPrice,\n          maxGasAmount,\n          sender: sender?.address.toString(),\n          sequenceNumber: sequenceNumber !== void 0 ? Number(sequenceNumber) : void 0\n        },\n        payload\n      }, {\n        networkName: network\n      });\n      return makeUserApproval({\n        authenticator: responseArgs.accountAuthenticator,\n        rawTransaction: responseArgs.rawTxn\n      });\n    }\n    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signAndSubmitTransaction(args) {\n    const {\n      signerAddress\n    } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        expirationTimestamp,\n        feePayer,\n        gasUnitPrice,\n        maxGasAmount,\n        network\n      } = args;\n      const aptosConfig = new AptosConfig2({\n        network\n      });\n      let convertedArgs;\n      if (feePayer !== void 0) {\n        const payload = await normalizePayloadForIC(args.payload, aptosConfig);\n        const rawTxn = await generateRawTransaction({\n          aptosConfig,\n          feePayerAddress: feePayer.address,\n          options: {\n            gasUnitPrice,\n            maxGasAmount\n          },\n          payload,\n          sender: signerAddress\n        });\n        convertedArgs = {\n          feePayerAuthenticator: feePayer.authenticator,\n          rawTxn: new FeePayerRawTransaction(rawTxn, [], feePayer.address)\n        };\n      } else {\n        const payload = normalizePayloadForIC(args.payload);\n        convertedArgs = {\n          options: {\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount\n          },\n          payload\n        };\n      }\n      const {\n        hash\n      } = await this.pairingClient.signAndSubmitTransaction(signerAddress.toString(), convertedArgs, {\n        networkName: network\n      });\n      return makeUserApproval({\n        txnHash: hash\n      });\n    }\n    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  // endregion\n};\n\n// src/ICDappClient.ts\nimport { createEd25519KeyPair as createEd25519KeyPair2, encodeBase64 as encodeBase643 } from \"@identity-connect/crypto\";\nimport { isAxiosError as isAxiosError2 } from \"axios\";\n\n// src/prompt.ts\nvar DEFAULT_PROMPT_SIZE = {\n  height: 695,\n  width: 465\n};\nvar PROMPT_POLLER_INTERVAL = 500;\nfunction openPrompt(url, size = DEFAULT_PROMPT_SIZE) {\n  const {\n    height,\n    width\n  } = size;\n  const options = {\n    height,\n    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),\n    popup: true,\n    top: window.screenTop + Math.round((window.outerHeight - height) / 2),\n    width\n  };\n  const strOptions = Object.entries(options).map(([key, value]) => `${key}=${JSON.stringify(value)}`).reduce((acc, entry) => `${acc}, ${entry}`);\n  const href = url instanceof URL ? url.href : url;\n  const promptWindow = window.open(href, void 0, strOptions);\n  if (promptWindow === null) {\n    throw new Error(\"Couldn't open prompt\");\n  }\n  return promptWindow;\n}\nasync function waitForPromptResponse(promptWindow) {\n  return new Promise(resolve => {\n    const listeners = {\n      onMessage: message => {\n        if (message.source !== promptWindow) {\n          return;\n        }\n        window.removeEventListener(\"message\", listeners.onMessage);\n        clearTimeout(listeners.promptPollerId);\n        resolve({\n          args: message.data,\n          status: \"approved\"\n        });\n      },\n      promptPollerId: setInterval(() => {\n        if (promptWindow.closed) {\n          window.removeEventListener(\"message\", listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          resolve({\n            status: \"dismissed\"\n          });\n        }\n      }, PROMPT_POLLER_INTERVAL)\n    };\n    window.addEventListener(\"message\", listeners.onMessage);\n  });\n}\n\n// src/ICDappClient.ts\nvar ICDappClient = class extends ACPairingClient {\n  constructor(dappId, {\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    ...pairingClientConfig\n  } = {}) {\n    super(pairingClientConfig);\n    this.dappId = dappId;\n    this.frontendBaseURL = frontendBaseURL;\n  }\n  async createPairingRequest(dappEd25519PublicKeyB64) {\n    try {\n      const response = await this.axiosInstance.post(\"v1/pairing/\", {\n        dappEd25519PublicKeyB64,\n        dappId: this.dappId\n      });\n      return response.data.data.pairing;\n    } catch (err) {\n      if (isAxiosError2(err) && err.response?.data?.message === \"Dapp not found\") {\n        throw new UnregisteredDappError();\n      }\n      throw err;\n    }\n  }\n  // region Public API\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async connect() {\n    const {\n      publicKey,\n      secretKey\n    } = createEd25519KeyPair2();\n    const dappEd25519PublicKeyB64 = encodeBase643(publicKey.key);\n    const url = new URL(`${this.frontendBaseURL}/pairing`);\n    const promptWindow = await openPrompt(url.href);\n    let pairingId;\n    try {\n      const pendingPairing = await this.createPairingRequest(dappEd25519PublicKeyB64);\n      pairingId = pendingPairing.id;\n    } catch (err) {\n      promptWindow.close();\n      throw err;\n    }\n    url.searchParams.set(\"pairingId\", pairingId);\n    promptWindow.location.href = url.href;\n    const promptResponse = await waitForPromptResponse(promptWindow);\n    if (promptResponse.status === \"dismissed\") {\n      void this.deletePairing(pairingId, secretKey, publicKey);\n      return void 0;\n    }\n    const finalizedPairing = promptResponse.args;\n    await this.addPairing({\n      publicKey,\n      secretKey\n    }, finalizedPairing);\n    return finalizedPairing.account.accountAddress;\n  }\n  async offboard(address) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === void 0) {\n      throw new Error(\"This account is not paired\");\n    }\n    const walletId = pairing.dappWalletId;\n    if (walletId === void 0) {\n      throw new Error(\"This account cannot be offboarded\");\n    }\n    const url = new URL(`${this.frontendBaseURL}/offboarding?walletId=${walletId}`);\n    const promptWindow = openPrompt(url);\n    const response = await waitForPromptResponse(promptWindow);\n    if (response.status === \"approved\" && response.args.offboarded) {\n      this.disconnect(address);\n      return true;\n    }\n    return false;\n  }\n  // endregion\n};\n\n// src/KeylessClient.ts\nimport { ConnectRequest as ConnectRequest2, ConnectResponse as ConnectResponse2, DisconnectRequest as DisconnectRequest2, GetConnectedAccountsRequest as GetConnectedAccountsRequest2, GetConnectedAccountsResponse as GetConnectedAccountsResponse2, IsConnectedRequest, IsConnectedResponse, SignAndSubmitTransactionRequest as SignAndSubmitTransactionRequest2, SignAndSubmitTransactionResponse as SignAndSubmitTransactionResponse2, SignMessageRequest as SignMessageRequest2, SignMessageResponse as SignMessageResponse2, SignTransactionRequest as SignTransactionRequest2, SignTransactionResponse as SignTransactionResponse2 } from \"@aptos-connect/wallet-api\";\nimport { WebWalletTransport as WebWalletTransport2 } from \"@aptos-connect/web-transport\";\nimport { NetworkName as NetworkName3 } from \"@identity-connect/api\";\nvar ACKeylessClient = class {\n  constructor({\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName3.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    provider = \"google\"\n  } = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title\n    };\n    this.transport = new WebWalletTransport2(frontendBaseURL, provider);\n  }\n  // region Public API\n  async isConnected() {\n    const serializedRequest = IsConnectedRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = IsConnectedResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async getConnectedAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest2.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = GetConnectedAccountsResponse2.deserialize(serializedResponse);\n    return response.args;\n  }\n  async disconnect() {\n    const serializedRequest = DisconnectRequest2.serialize(this.dappInfo);\n    await this.transport.sendRequest(serializedRequest);\n  }\n  async connect() {\n    const serializedRequest = ConnectRequest2.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse2.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signMessage(args) {\n    const serializedRequest = SignMessageRequest2.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse2.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signTransaction(args) {\n    const normalizedArgs = \"transaction\" in args ? SignTransactionRequest2.normalizeArgs(args) : args;\n    const serializedRequest = SignTransactionRequest2.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse2.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signAndSubmitTransaction(args) {\n    const serializedRequest = SignAndSubmitTransactionRequest2.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignAndSubmitTransactionResponse2.deserialize(serializedResponse);\n    return response.args;\n  }\n  // endregion\n};\nexport { ACDappClient, ACKeylessClient, DAPP_PAIRINGS_WINDOW_STORAGE_KEY, ICDappClient, windowStateAccessors };","map":{"version":3,"names":["chainIdToNetwork","ConnectRequest","ConnectResponse","DisconnectRequest","GetConnectedAccountsRequest","GetConnectedAccountsResponse","makeUserApproval","SignAndSubmitTransactionRequest","SignAndSubmitTransactionResponse","SignInRequest","SignInResponse","SignMessageRequest","SignMessageResponse","SignTransactionRequest","SignTransactionResponse","WebWalletTransport","AccountAddress","AccountAddress3","AnySignature","AptosConfig","AptosConfig2","Deserializer","Ed25519Signature","FeePayerRawTransaction","generateRawTransaction","Hex","NetworkName","NetworkName2","createEd25519KeyPair","encodeBase64","encodeBase642","DEFAULT_FRONTEND_URL","generateTransactionPayload","generateTransactionPayloadWithABI","convertToSerializableArgument","argument","Array","isArray","map","subArgument","Uint8Array","toString","ArrayBuffer","values","from","data","value","Error","normalizePayloadForIC","payload","aptosConfig","abi","entryFunctionPayload","arguments","functionArguments","function","type","type_arguments","typeArguments","ta","multisig_address","multisigAddress","transaction_payload","AccountAddress2","SigningRequestStatus","SigningRequestTypes","decodeBase64","decryptEnvelope","deserializeEd25519PublicKeyB64","deserializePublicKeyB64","encryptAndSignEnvelope","KeyTypes","toKey","deserializeSignTransactionResponseArgs","serializeSignAndSubmitTransactionRequestArgs","serializeSignTransactionRequestArgs","axios","AxiosError","isAxiosError","SignatureRequestError","_SignatureRequestError","constructor","status","name","Object","setPrototypeOf","prototype","UnexpectedSignatureResponseError","_UnexpectedSignatureResponseError","missingFields","message","join","PairingExpiredError","_PairingExpiredError","UnregisteredDappError","_UnregisteredDappError","DAPP_PAIRINGS_WINDOW_STORAGE_KEY","windowStateAccessors","get","address","pairings","getAll","serialized","window","localStorage","getItem","JSON","parse","update","pairing","newSerialized","stringify","setItem","SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS","validateSignMessageResponse","response","providedFields","Set","keys","filter","field","has","length","SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS","validateSignAndSubmitTransactionResponse","API_VERSION","SIGNING_REQUEST_POLLING_INTERVAL","SEQUENCE_NUMBER_MISMATCH_PATTERN","waitFor","milliseconds","Promise","resolve","setTimeout","withRetries","requestFn","onError","retries","i","err","ACPairingClient","accessors","axiosConfig","defaultNetworkName","MAINNET","onDisconnectListeners","axiosInstance","create","baseURL","isClientSideRendering","initPromise","syncFirstPairing","getPairing","id","firstPairing","dappSpecificWallet","maxDappSequenceNumber","pairingId","accountAddress","currSequenceNumber","dappWalletId","createSigningRequest","networkName","requestBody","dappEd25519SecretKey","dappEd25519SecretKeyB64","dappEd25519PublicKey","dappEd25519PublicKeyB64","accountTransportEd25519PublicKey","accountTransportEd25519PublicKeyB64","sequenceNumber","requestEnvelope","Ed25519SecretKey","Ed25519PublicKey","apiVersion","requestType","post","signingRequest","errorMessage","expectedSequenceNumber","match","Number","getSigningRequest","validateStatus","deletePairing","secretKey","publicKey","cancelSigningRequest","patch","signRequest","cancelToken","cancelled","CANCELLED","code","listener","decrypted","responseEnvelope","privateMessage","addPairing","finalizedPairing","account","accountAlias","userSubmittedAlias","accountPublicKeyB64","publicKeyB64","transportEd25519PublicKeyB64","key","dappSpecificWalletId","disconnect","signMessage","args","options","SIGN_MESSAGE","signTransaction","serializedRequestArgs","serializedResponseArgs","SIGN_TRANSACTION","signAndSubmitTransaction","responseArgs","SIGN_AND_SUBMIT_TRANSACTION","e","getConnectedAccounts","accountEd25519PublicKeyB64","onDisconnect","add","delete","ACDappClient","backendBaseURL","dappId","dappImageURI","dappName","frontendBaseURL","provider","tgWebAppURL","dappInfo","domain","location","origin","imageURI","document","title","transport","pairingClient","getKeylessAccounts","serializedRequest","serialize","serializedResponse","sendRequest","deserialize","getIcAccounts","isIcAccount","icAccounts","find","equals","keylessAccounts","stringAddress","connect","claimOptions","preferredWalletName","dappKeypair","injectedPreferredWalletName","AC_PREFERRED_WALLET_NAME","requestArgs","signIn","version","signerAddress","chainId","network","nonce","TextDecoder","decode","fullMessage","signature","hexSignature","application","signatureBytes","fromHexInput","toUint8Array","LENGTH","normalizedArgs","normalizeArgs","expirationSecondsFromNow","expirationTimestamp","feePayer","gasUnitPrice","maxGasAmount","secondarySigners","sender","authenticator","accountAuthenticator","rawTransaction","rawTxn","convertedArgs","feePayerAddress","feePayerAuthenticator","hash","txnHash","createEd25519KeyPair2","encodeBase643","isAxiosError2","DEFAULT_PROMPT_SIZE","height","width","PROMPT_POLLER_INTERVAL","openPrompt","url","size","left","screenLeft","Math","round","outerWidth","popup","top","screenTop","outerHeight","strOptions","entries","reduce","acc","entry","href","URL","promptWindow","open","waitForPromptResponse","listeners","onMessage","source","removeEventListener","clearTimeout","promptPollerId","setInterval","closed","addEventListener","ICDappClient","pairingClientConfig","createPairingRequest","pendingPairing","close","searchParams","set","promptResponse","offboard","walletId","offboarded","ConnectRequest2","ConnectResponse2","DisconnectRequest2","GetConnectedAccountsRequest2","GetConnectedAccountsResponse2","IsConnectedRequest","IsConnectedResponse","SignAndSubmitTransactionRequest2","SignAndSubmitTransactionResponse2","SignMessageRequest2","SignMessageResponse2","SignTransactionRequest2","SignTransactionResponse2","WebWalletTransport2","NetworkName3","ACKeylessClient","isConnected"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\dapp-sdk\\src\\ACDappClient.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\dapp-sdk\\src\\constants.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\dapp-sdk\\src\\conversion.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\dapp-sdk\\src\\PairingClient.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\dapp-sdk\\src\\errors.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\dapp-sdk\\src\\state.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\dapp-sdk\\src\\utils.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\dapp-sdk\\src\\ICDappClient.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\dapp-sdk\\src\\prompt.ts","C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\wallet-adapter-react\\node_modules\\@identity-connect\\dapp-sdk\\src\\KeylessClient.ts"],"sourcesContent":["// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  chainIdToNetwork,\n  ConnectRequest,\n  ConnectResponse,\n  type DappInfo,\n  DisconnectRequest,\n  GetConnectedAccountsRequest,\n  GetConnectedAccountsResponse,\n  makeUserApproval,\n  SignAndSubmitTransactionRequest,\n  SignAndSubmitTransactionResponse,\n  SignInRequest,\n  SignInResponse,\n  SignMessageRequest,\n  SignMessageResponse,\n  SignTransactionRequest,\n  SignTransactionResponse,\n  UserApproval,\n  UserDismissal,\n} from '@aptos-connect/wallet-api';\nimport { WebWalletTransport } from '@aptos-connect/web-transport';\nimport {\n  AccountAddress,\n  AccountAddressInput,\n  AnySignature,\n  AptosConfig,\n  Deserializer,\n  Ed25519Signature,\n  FeePayerRawTransaction,\n  generateRawTransaction,\n  Hex,\n} from '@aptos-labs/ts-sdk';\nimport { NetworkName } from '@identity-connect/api';\nimport { createEd25519KeyPair, encodeBase64 } from '@identity-connect/crypto';\nimport { SignAndSubmitTransactionRequestArgs } from '@identity-connect/wallet-api';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { normalizePayloadForIC } from './conversion';\nimport { ACPairingClient } from './PairingClient';\n\nexport interface WithSignerAddress {\n  signerAddress: AccountAddress;\n}\n\nexport interface ACDappClientConfig {\n  backendBaseURL?: string;\n  dappId?: string;\n  dappImageURI?: string;\n  dappName?: string;\n  defaultNetworkName?: NetworkName;\n  frontendBaseURL?: string;\n  provider?: 'google' | 'apple';\n  tgWebAppURL?: string;\n}\n\nexport class ACDappClient {\n  private readonly defaultNetworkName: NetworkName;\n  readonly dappInfo: DappInfo;\n\n  private readonly transport: WebWalletTransport;\n\n  private readonly dappId?: string;\n  private readonly pairingClient: ACPairingClient;\n\n  constructor({\n    backendBaseURL,\n    dappId,\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    provider = 'google',\n    tgWebAppURL,\n  }: ACDappClientConfig = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title,\n    };\n\n    this.transport = new WebWalletTransport(frontendBaseURL, provider, tgWebAppURL);\n\n    this.dappId = dappId;\n    this.pairingClient = new ACPairingClient({\n      axiosConfig: {\n        baseURL: backendBaseURL ?? frontendBaseURL,\n      },\n      defaultNetworkName,\n    });\n  }\n\n  // region Public API\n\n  private async getKeylessAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  private async getIcAccounts() {\n    return this.pairingClient.getConnectedAccounts() ?? [];\n  }\n\n  private async isIcAccount(address: AccountAddressInput) {\n    const icAccounts = await this.getIcAccounts();\n    return icAccounts.find((account) => account.address.equals(AccountAddress.from(address))) !== undefined;\n  }\n\n  async getConnectedAccounts() {\n    const keylessAccounts = await this.getKeylessAccounts();\n    const icAccounts = await this.getIcAccounts();\n    return [...keylessAccounts, ...icAccounts];\n  }\n\n  async disconnect(address: AccountAddressInput) {\n    if (await this.isIcAccount(address)) {\n      const stringAddress = AccountAddress.from(address).toString();\n      await this.pairingClient.disconnect(stringAddress);\n    } else {\n      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);\n      await this.transport.sendRequest(serializedRequest);\n    }\n  }\n\n  async connect({\n    claimOptions,\n    preferredWalletName,\n  }: Omit<ConnectRequest.Args, 'dappId' | 'dappEd25519PublicKeyB64'> = {}) {\n    const dappKeypair = createEd25519KeyPair();\n    const injectedPreferredWalletName =\n      typeof window !== 'undefined' ? (window as any).AC_PREFERRED_WALLET_NAME : undefined;\n\n    const requestArgs = {\n      claimOptions,\n      dappEd25519PublicKeyB64: encodeBase64(dappKeypair.publicKey.key),\n      dappId: this.dappId,\n      preferredWalletName: preferredWalletName ?? injectedPreferredWalletName,\n    } satisfies ConnectRequest.Args;\n\n    const serializedRequest = ConnectRequest.serialize(this.dappInfo, requestArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse.deserialize(serializedResponse);\n\n    if (response.args.status === 'approved') {\n      const { account, pairing } = response.args.args;\n      if (pairing) {\n        await this.pairingClient.addPairing(dappKeypair, pairing);\n      }\n      return makeUserApproval({ account });\n    }\n    return response.args;\n  }\n\n  async signIn(args: SignInRequest.Args): Promise<UserDismissal | UserApproval<SignInResponse.ApprovalArgs>> {\n    const serializedRequest = SignInRequest.serialize(this.dappInfo, args);\n\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n\n    const response = SignInResponse.deserialize(serializedResponse, serializedRequest.version);\n\n    return response.args;\n  }\n\n  async signMessage(args: SignMessageRequest.Args & WithSignerAddress) {\n    const { signerAddress } = args;\n\n    if (await this.isIcAccount(signerAddress)) {\n      const { chainId } = args;\n      const network = chainIdToNetwork(chainId) as string;\n\n      let message: string;\n      let nonce: string;\n      try {\n        message = new TextDecoder().decode(args.message);\n        nonce = new TextDecoder().decode(args.nonce);\n      } catch (err) {\n        throw new Error('Only UTF-8 encoded text is supported when using IC');\n      }\n\n      const { fullMessage, signature: hexSignature } = await this.pairingClient.signMessage(\n        signerAddress.toString(),\n        {\n          address: true,\n          application: true,\n          chainId: true,\n          message,\n          nonce,\n        },\n        { networkName: network as NetworkName },\n      );\n\n      const signatureBytes = Hex.fromHexInput(hexSignature).toUint8Array();\n      const signature =\n        signatureBytes.length === Ed25519Signature.LENGTH\n          ? new Ed25519Signature(signatureBytes)\n          : AnySignature.deserialize(new Deserializer(signatureBytes));\n      return makeUserApproval<SignMessageResponse.ApprovalArgs>({\n        fullMessage,\n        signature,\n      });\n    }\n    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signTransaction(\n    args: (SignTransactionRequest.Args | SignTransactionRequest.ArgsWithTransaction) & WithSignerAddress,\n  ): Promise<SignTransactionResponse.Args> {\n    const normalizedArgs = 'transaction' in args ? SignTransactionRequest.normalizeArgs(args) : args;\n    const { signerAddress } = args;\n\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        expirationSecondsFromNow,\n        expirationTimestamp,\n        feePayer,\n        gasUnitPrice,\n        maxGasAmount,\n        network,\n        payload,\n        secondarySigners,\n        sender,\n        sequenceNumber,\n      } = normalizedArgs;\n\n      if (feePayer !== undefined) {\n        throw new Error('Sponsored transaction not currently supported');\n      }\n\n      if (secondarySigners && secondarySigners.length > 0) {\n        throw new Error('Multi-agent transactions not currently supported');\n      }\n\n      if (!('bcsToBytes' in payload)) {\n        throw new Error('Payload input format is only supported with Keyless accounts.');\n      }\n\n      const responseArgs = await this.pairingClient.signTransaction(\n        signerAddress.toString(),\n        {\n          options: {\n            expirationSecondsFromNow,\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount,\n            sender: sender?.address.toString(),\n            sequenceNumber: sequenceNumber !== undefined ? Number(sequenceNumber) : undefined,\n          },\n          payload,\n        },\n        {\n          networkName: network as NetworkName | undefined,\n        },\n      );\n      return makeUserApproval({\n        authenticator: responseArgs.accountAuthenticator,\n        rawTransaction: responseArgs.rawTxn,\n      });\n    }\n\n    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signAndSubmitTransaction(args: SignAndSubmitTransactionRequest.Args & WithSignerAddress) {\n    const { signerAddress } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const { expirationTimestamp, feePayer, gasUnitPrice, maxGasAmount, network } = args;\n      const aptosConfig = new AptosConfig({ network });\n\n      let convertedArgs: SignAndSubmitTransactionRequestArgs;\n      if (feePayer !== undefined) {\n        const payload = await normalizePayloadForIC(args.payload, aptosConfig);\n        const rawTxn = await generateRawTransaction({\n          aptosConfig,\n          feePayerAddress: feePayer.address,\n          options: {\n            gasUnitPrice,\n            maxGasAmount,\n          },\n          payload,\n          sender: signerAddress,\n        });\n        convertedArgs = {\n          feePayerAuthenticator: feePayer.authenticator,\n          rawTxn: new FeePayerRawTransaction(rawTxn, [], feePayer.address),\n        };\n      } else {\n        const payload = normalizePayloadForIC(args.payload);\n        convertedArgs = {\n          options: {\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount,\n          },\n          payload,\n        };\n      }\n\n      const { hash } = await this.pairingClient.signAndSubmitTransaction(signerAddress.toString(), convertedArgs, {\n        networkName: network as NetworkName | undefined,\n      });\n      return makeUserApproval<SignAndSubmitTransactionResponse.ApprovalArgs>({ txnHash: hash });\n    }\n\n    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  // endregion\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport const DEFAULT_FRONTEND_URL = 'https://aptosconnect.app';\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  AccountAddress,\n  AnyTransactionPayloadInstance,\n  AptosConfig,\n  EntryFunctionArgumentTypes,\n  generateTransactionPayload,\n  generateTransactionPayloadWithABI,\n  InputGenerateTransactionPayloadData,\n  SimpleEntryFunctionArgumentTypes,\n  TransactionPayload,\n} from '@aptos-labs/ts-sdk';\nimport { JsonTransactionPayload } from '@identity-connect/wallet-api';\n\ntype EntryFunctionArgument = SimpleEntryFunctionArgumentTypes | EntryFunctionArgumentTypes;\ntype SerializableArgument = undefined | null | number | string | boolean | Uint8Array | SerializableArgument[];\n\n/**\n * Return an equivalent argument value that can be safely serialized.\n */\nfunction convertToSerializableArgument(argument: EntryFunctionArgument): SerializableArgument {\n  if (argument === undefined || argument === null) {\n    return argument;\n  }\n\n  if (Array.isArray(argument)) {\n    return argument.map((subArgument) => convertToSerializableArgument(subArgument));\n  }\n\n  if (\n    typeof argument === 'string' ||\n    typeof argument === 'number' ||\n    typeof argument === 'boolean' ||\n    argument instanceof Uint8Array\n  ) {\n    return argument;\n  }\n\n  if (typeof argument === 'bigint') {\n    return argument.toString();\n  }\n\n  // ArrayBuffer\n  if (argument instanceof ArrayBuffer) {\n    return new Uint8Array(argument);\n  }\n\n  // MoveVector\n  if ('values' in argument) {\n    return argument.values.map((subArgument) => convertToSerializableArgument(subArgument));\n  }\n\n  // AccountAddress\n  if ('data' in argument) {\n    return AccountAddress.from(argument.data).toString();\n  }\n\n  // MoveOption\n  if (argument.value === undefined) {\n    return undefined;\n  }\n\n  if (\n    typeof argument.value === 'string' ||\n    typeof argument.value === 'number' ||\n    typeof argument.value === 'boolean' ||\n    argument.value instanceof Uint8Array\n  ) {\n    return argument.value;\n  }\n\n  if (typeof argument.value === 'bigint') {\n    return argument.value.toString();\n  }\n\n  throw new Error('Unexpected argument');\n}\n\n/**\n * Normalize payload input so that it's compatible with IC requests.\n * This variant is sync and will convert a payload generation input into a\n * `JsonTransactionPayload` when the ABI is not available\n */\nexport function normalizePayloadForIC(\n  payload: TransactionPayload | InputGenerateTransactionPayloadData,\n): AnyTransactionPayloadInstance | JsonTransactionPayload;\n/**\n * Normalize payload input so that it's compatible with IC requests.\n * This variant is async and will generate a payload instance when an input is provided\n */\nexport async function normalizePayloadForIC(\n  payload: TransactionPayload | InputGenerateTransactionPayloadData,\n  aptosConfig: AptosConfig,\n): Promise<AnyTransactionPayloadInstance>;\n\nexport function normalizePayloadForIC(\n  payload: TransactionPayload | InputGenerateTransactionPayloadData,\n  aptosConfig?: AptosConfig,\n): AnyTransactionPayloadInstance | JsonTransactionPayload | Promise<AnyTransactionPayloadInstance> {\n  if ('bcsToBytes' in payload) {\n    return payload as AnyTransactionPayloadInstance;\n  }\n  if ('bytecode' in payload) {\n    // The signature of this function returns a promise, but it's actually sync code\n    return generateTransactionPayload(payload);\n  }\n  if (aptosConfig) {\n    return payload.abi !== undefined\n      ? generateTransactionPayloadWithABI({ ...payload, abi: payload.abi })\n      : generateTransactionPayload({ aptosConfig, ...payload });\n  }\n\n  const entryFunctionPayload = {\n    arguments: payload.functionArguments.map(convertToSerializableArgument),\n    function: payload.function,\n    type: 'entry_function_payload' as const,\n    type_arguments: (payload.typeArguments ?? []).map((ta) => ta.toString()),\n  };\n\n  return 'multisigAddress' in payload\n    ? {\n        multisig_address: AccountAddress.from(payload.multisigAddress).toString(),\n        transaction_payload: entryFunctionPayload,\n        type: 'multisig_payload' as const,\n      }\n    : entryFunctionPayload;\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-await-in-loop */\n\nimport { AccountInfo } from '@aptos-connect/wallet-api';\nimport { AccountAddress } from '@aptos-labs/ts-sdk';\nimport {\n  CancelSigningRequestSerializedResponse,\n  CreateSigningRequestSerializedResponse,\n  FinalizedPairingData,\n  GetPairingSerializedResponse,\n  GetSigningRequestSerializedResponse,\n  NetworkName,\n  SerializedDate,\n  SigningRequestData,\n  SigningRequestStatus,\n  SigningRequestTypes,\n} from '@identity-connect/api';\nimport {\n  decodeBase64,\n  decryptEnvelope,\n  deserializeEd25519PublicKeyB64,\n  deserializePublicKeyB64,\n  Ed25519KeyPair,\n  Ed25519PublicKey,\n  Ed25519SecretKey,\n  encodeBase64,\n  encryptAndSignEnvelope,\n  KeyTypes,\n  toKey,\n} from '@identity-connect/crypto';\nimport {\n  deserializeSignTransactionResponseArgs,\n  type SerializedSignAndSubmitTransactionRequestArgs,\n  type SerializedSignTransactionRequestArgs,\n  type SerializedSignTransactionResponseArgs,\n  serializeSignAndSubmitTransactionRequestArgs,\n  serializeSignTransactionRequestArgs,\n  type SignAndSubmitTransactionRequestArgs,\n  type SignAndSubmitTransactionResponseArgs,\n  SignMessageRequestArgs,\n  SignMessageResponseArgs,\n  type SignTransactionRequestArgs,\n  type SignTransactionResponseArgs,\n  type SignTransactionWithPayloadRequestArgs,\n  type SignTransactionWithPayloadResponseArgs,\n  type SignTransactionWithRawTxnRequestArgs,\n  type SignTransactionWithRawTxnResponseArgs,\n} from '@identity-connect/wallet-api';\nimport axios, { AxiosError, AxiosInstance, CreateAxiosDefaults, isAxiosError } from 'axios';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { PairingExpiredError, SignatureRequestError } from './errors';\nimport { DappPairingData, DappStateAccessors, windowStateAccessors } from './state';\nimport { CancelToken } from './types';\nimport { validateSignAndSubmitTransactionResponse, validateSignMessageResponse } from './utils';\n\nconst API_VERSION = '0.2.0' as const;\nconst SIGNING_REQUEST_POLLING_INTERVAL = 2500;\nconst SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\\S+ to be )?(\\d+)/;\n\nasync function waitFor(milliseconds: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n}\n\nasync function withRetries<Response>(\n  requestFn: () => Promise<Response>,\n  onError: (err: any) => void,\n  retries: number = 1,\n) {\n  for (let i = 0; i < retries; i += 1) {\n    try {\n      return await requestFn();\n    } catch (err) {\n      onError(err);\n    }\n  }\n  return requestFn();\n}\n\nexport interface SignRequestOptions {\n  cancelToken?: CancelToken;\n  networkName?: NetworkName;\n}\n\nexport type OnDisconnectListener = (address: string) => void;\nexport type OnDisconnectListenerCleanup = () => void;\n\nexport interface ACPairingClientConfig {\n  accessors?: DappStateAccessors;\n  axiosConfig?: CreateAxiosDefaults;\n  defaultNetworkName?: NetworkName;\n}\n\nexport class ACPairingClient {\n  protected readonly accessors: DappStateAccessors;\n  private readonly defaultNetworkName: NetworkName;\n  protected readonly axiosInstance: AxiosInstance;\n  private readonly initPromise?: Promise<void>;\n\n  constructor({\n    accessors = windowStateAccessors,\n    axiosConfig,\n    defaultNetworkName = NetworkName.MAINNET,\n  }: ACPairingClientConfig = {}) {\n    this.accessors = accessors;\n    this.defaultNetworkName = defaultNetworkName;\n    this.axiosInstance = axios.create({\n      baseURL: DEFAULT_FRONTEND_URL,\n      ...axiosConfig,\n    });\n\n    const isClientSideRendering = typeof window !== 'undefined';\n    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : undefined;\n  }\n\n  private async getPairing(id: string) {\n    const response = await this.axiosInstance.get<GetPairingSerializedResponse>(`v1/pairing/${id}/`);\n    return response.data.data.pairing;\n  }\n\n  private async syncFirstPairing() {\n    const pairings = await this.accessors.getAll();\n    const firstPairing = Object.values(pairings)[0];\n    if (firstPairing === undefined) {\n      return;\n    }\n\n    try {\n      const { dappSpecificWallet, maxDappSequenceNumber } = await this.getPairing(firstPairing.pairingId);\n      await this.accessors.update(firstPairing.accountAddress, {\n        ...firstPairing,\n        currSequenceNumber: maxDappSequenceNumber,\n        dappWalletId: dappSpecificWallet?.id,\n      });\n    } catch (err) {\n      await this.accessors.update(firstPairing.accountAddress, undefined);\n    }\n  }\n\n  private async createSigningRequest<TRequestBody>(\n    pairing: DappPairingData,\n    type: string,\n    networkName: NetworkName,\n    requestBody: TRequestBody,\n  ) {\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);\n\n    let sequenceNumber = pairing.currSequenceNumber + 1;\n    return withRetries(\n      async () => {\n        const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n          toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n          toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n          toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n          sequenceNumber,\n          { apiVersion: API_VERSION, networkName, requestType: type },\n          requestBody,\n        );\n\n        const response = await this.axiosInstance.post<CreateSigningRequestSerializedResponse>(\n          `v1/pairing/${pairing.pairingId}/signing-request/`,\n          requestEnvelope,\n        );\n\n        await this.accessors.update(pairing.accountAddress, {\n          ...pairing,\n          currSequenceNumber: sequenceNumber,\n        });\n\n        return response.data.data.signingRequest;\n      },\n      (err) => {\n        if (isAxiosError(err)) {\n          const errorMessage: string = err.response?.data?.message;\n          const expectedSequenceNumber = errorMessage?.match(SEQUENCE_NUMBER_MISMATCH_PATTERN)?.[1];\n          if (expectedSequenceNumber !== undefined) {\n            sequenceNumber = Number(expectedSequenceNumber);\n            return;\n          }\n        }\n        throw err;\n      },\n    );\n  }\n\n  private async getSigningRequest(id: string) {\n    const response = await this.axiosInstance.get<GetSigningRequestSerializedResponse | undefined>(\n      `v1/signing-request/${id}/`,\n      {\n        validateStatus: (status) => status === 200 || status === 404,\n      },\n    );\n    return response.data?.data?.signingRequest;\n  }\n\n  protected async deletePairing(pairingId: string, secretKey: Ed25519SecretKey, publicKey: Ed25519PublicKey) {\n    const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n      secretKey,\n      publicKey,\n      publicKey,\n      0, // ignored\n      {},\n      {},\n    );\n\n    await this.axiosInstance.post<CreateSigningRequestSerializedResponse>(\n      `v1/pairing/${pairingId}/delete/`,\n      requestEnvelope,\n      { validateStatus: (status) => status === 204 || status === 404 },\n    );\n  }\n\n  async cancelSigningRequest(pairing: DappPairingData, id: string) {\n    const sequenceNumber = pairing.currSequenceNumber;\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);\n\n    const requestEnvelope = await encryptAndSignEnvelope<any, any>(\n      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n      toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n      sequenceNumber + 1,\n      {},\n      {},\n    );\n\n    const response = await this.axiosInstance.patch<CancelSigningRequestSerializedResponse>(\n      `v1/signing-request/${id}/cancel/`,\n      requestEnvelope,\n    );\n\n    // TODO: auto-sync sequence number on error\n    await this.accessors.update(pairing.accountAddress, {\n      ...pairing,\n      currSequenceNumber: sequenceNumber + 1,\n    });\n\n    return response.data.data.signingRequest;\n  }\n\n  private async signRequest<TRequestBody, TResponseBody>(\n    address: string,\n    type: SigningRequestTypes,\n    requestBody: TRequestBody,\n    { cancelToken, networkName }: SignRequestOptions = {},\n  ) {\n    await this.initPromise;\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('The requested account is not paired');\n    }\n\n    let signingRequest: SerializedDate<SigningRequestData>;\n\n    try {\n      signingRequest = await this.createSigningRequest<TRequestBody>(\n        pairing,\n        type,\n        networkName || this.defaultNetworkName,\n        requestBody,\n      );\n\n      while (signingRequest.status === 'PENDING') {\n        await waitFor(SIGNING_REQUEST_POLLING_INTERVAL);\n        if (cancelToken?.cancelled) {\n          // TODO: send cancel request\n          signingRequest.status = SigningRequestStatus.CANCELLED;\n          break;\n        }\n        signingRequest = (await this.getSigningRequest(signingRequest.id)) ?? signingRequest;\n      }\n    } catch (err) {\n      if (isAxiosError(err) && err.code === '404') {\n        await this.accessors.update(address, undefined);\n        for (const listener of this.onDisconnectListeners) {\n          listener(address);\n        }\n        throw new PairingExpiredError();\n      }\n      throw err;\n    }\n\n    if (signingRequest.status !== 'APPROVED') {\n      throw new SignatureRequestError(signingRequest.status);\n    }\n\n    const decrypted = decryptEnvelope<{}, TResponseBody & {}>(\n      toKey(decodeBase64(pairing.accountTransportEd25519PublicKeyB64), KeyTypes.Ed25519PublicKey),\n      toKey(decodeBase64(pairing.dappEd25519SecretKeyB64), KeyTypes.Ed25519SecretKey),\n      signingRequest.responseEnvelope!,\n    );\n    return decrypted.privateMessage;\n  }\n\n  // region Public API\n\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async addPairing({ publicKey, secretKey }: Ed25519KeyPair, finalizedPairing: SerializedDate<FinalizedPairingData>) {\n    await this.accessors.update(finalizedPairing.account.accountAddress, {\n      accountAddress: finalizedPairing.account.accountAddress,\n      accountAlias: finalizedPairing.account.userSubmittedAlias ?? undefined,\n      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,\n      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,\n      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,\n      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),\n      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),\n      dappWalletId: finalizedPairing.dappSpecificWalletId,\n      pairingId: finalizedPairing.id,\n    });\n  }\n\n  async disconnect(address: string) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('The specified account is not paired');\n    }\n\n    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);\n    await this.deletePairing(\n      pairing.pairingId,\n      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),\n      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),\n    );\n    await this.accessors.update(address, undefined);\n    for (const listener of this.onDisconnectListeners) {\n      listener(address);\n    }\n  }\n\n  async signMessage(address: string, args: SignMessageRequestArgs, options?: SignRequestOptions) {\n    const response = await this.signRequest<SignMessageRequestArgs, SignMessageResponseArgs>(\n      address,\n      SigningRequestTypes.SIGN_MESSAGE,\n      args,\n      options,\n    );\n    validateSignMessageResponse(response);\n    return response;\n  }\n\n  // region signTransaction\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionWithPayloadRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionWithPayloadResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionWithRawTxnRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionWithRawTxnResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionResponseArgs>;\n\n  async signTransaction(\n    address: string,\n    args: SignTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignTransactionResponseArgs> {\n    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);\n    const serializedResponseArgs = await this.signRequest<\n      SerializedSignTransactionRequestArgs,\n      SerializedSignTransactionResponseArgs\n    >(address, SigningRequestTypes.SIGN_TRANSACTION, serializedRequestArgs, options);\n    return deserializeSignTransactionResponseArgs(serializedResponseArgs);\n  }\n\n  // endregion\n\n  async signAndSubmitTransaction(\n    address: string,\n    args: SignAndSubmitTransactionRequestArgs,\n    options?: SignRequestOptions,\n  ): Promise<SignAndSubmitTransactionResponseArgs> {\n    const serializedRequestArgs = serializeSignAndSubmitTransactionRequestArgs(args);\n    try {\n      const responseArgs = await this.signRequest<\n        SerializedSignAndSubmitTransactionRequestArgs,\n        SignAndSubmitTransactionResponseArgs\n      >(address, SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION, serializedRequestArgs, options);\n      validateSignAndSubmitTransactionResponse(responseArgs);\n      return responseArgs;\n    } catch (e) {\n      if (e instanceof AxiosError && e.response?.data?.message) {\n        throw new Error(e.response?.data?.message);\n      }\n      throw e;\n    }\n  }\n\n  async getConnectedAccounts() {\n    await this.initPromise;\n    const pairings = await this.accessors.getAll();\n    return Object.values(pairings).map<AccountInfo>(\n      ({ accountAddress, accountEd25519PublicKeyB64, accountPublicKeyB64 }) => ({\n        address: AccountAddress.from(accountAddress),\n        publicKey:\n          accountPublicKeyB64 !== undefined\n            ? deserializePublicKeyB64(accountPublicKeyB64)\n            : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64),\n      }),\n    );\n  }\n\n  // endregion\n\n  private readonly onDisconnectListeners = new Set<OnDisconnectListener>();\n\n  onDisconnect(listener: OnDisconnectListener): OnDisconnectListenerCleanup {\n    this.onDisconnectListeners.add(listener);\n    return () => this.onDisconnectListeners.delete(listener);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SigningRequestStatus } from '@identity-connect/api';\n\nexport class SignatureRequestError extends Error {\n  constructor(status: SigningRequestStatus) {\n    super(status);\n    this.name = 'SignatureRequestError';\n    Object.setPrototypeOf(this, SignatureRequestError.prototype);\n  }\n}\n\nexport class UnexpectedSignatureResponseError extends Error {\n  constructor(missingFields: string[]) {\n    const message = `Missing the following fields: ${missingFields.join(', ')}`;\n    super(message);\n    this.name = 'UnexpectedSignatureResponseError';\n    Object.setPrototypeOf(this, UnexpectedSignatureResponseError.prototype);\n  }\n}\n\nexport class PairingExpiredError extends Error {\n  constructor() {\n    super();\n    this.name = 'PairingExpiredError';\n    Object.setPrototypeOf(this, PairingExpiredError.prototype);\n  }\n}\n\nexport class UnregisteredDappError extends Error {\n  constructor() {\n    super('Dapp ID is invalid or not associated with a registered Dapp.');\n    this.name = 'UnregisteredDappError';\n    Object.setPrototypeOf(this, UnregisteredDappError.prototype);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface BaseDappPairingData {\n  accountAddress: string;\n  accountAlias?: string;\n  accountTransportEd25519PublicKeyB64: string;\n  currSequenceNumber: number;\n  dappEd25519PublicKeyB64: string;\n  dappEd25519SecretKeyB64: string;\n  dappWalletId?: string;\n  pairingId: string;\n}\n\n// Keeping this temporarily for backward compatibility\nexport interface PrevDappPairingData extends BaseDappPairingData {\n  accountEd25519PublicKeyB64: string;\n  accountPublicKeyB64?: undefined;\n}\n\nexport interface CurrDappPairingData extends BaseDappPairingData {\n  accountEd25519PublicKeyB64?: undefined;\n  accountPublicKeyB64: string;\n}\n\nexport type DappPairingData = PrevDappPairingData | CurrDappPairingData;\n\nexport type DappPairingDataMap = { [address: string]: DappPairingData };\n\nexport interface DappStateAccessors {\n  get: (address: string) => Promise<DappPairingData | undefined>;\n  getAll: () => Promise<DappPairingDataMap>;\n  update: (address: string, pairing?: DappPairingData) => Promise<void>;\n}\n\nexport const DAPP_PAIRINGS_WINDOW_STORAGE_KEY = 'icDappPairings';\n\n/**\n * Default implementation of DappStateAccessors that uses the Window localStorage API.\n * This should work for most dapps.\n */\nexport const windowStateAccessors: DappStateAccessors = {\n  async get(address: string) {\n    const pairings = await this.getAll();\n    return pairings[address];\n  },\n  async getAll() {\n    const serialized = window.localStorage.getItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY);\n    return serialized ? (JSON.parse(serialized) as DappPairingDataMap) : {};\n  },\n  async update(address: string, pairing?: DappPairingData) {\n    const pairings = await this.getAll();\n    if (pairing === undefined) {\n      delete pairings[address];\n    } else {\n      pairings[address] = pairing;\n    }\n    const newSerialized = JSON.stringify(pairings);\n    window.localStorage.setItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY, newSerialized);\n  },\n};\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SignAndSubmitTransactionResponseArgs, SignMessageResponseArgs } from '@identity-connect/wallet-api';\nimport { UnexpectedSignatureResponseError } from './errors';\n\nconst SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS: (keyof SignMessageResponseArgs)[] = [\n  'address',\n  'application',\n  'chainId',\n  'fullMessage',\n  'message',\n  'nonce',\n  'prefix',\n  'signature',\n];\n\nexport function validateSignMessageResponse(response: SignMessageResponseArgs) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter((field) => !providedFields.has(field));\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n\nconst SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS: (keyof SignAndSubmitTransactionResponseArgs)[] = ['hash'];\n\nexport function validateSignAndSubmitTransactionResponse(response: SignAndSubmitTransactionResponseArgs) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(\n    (field) => !providedFields.has(field),\n  );\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport { CreatePairingSerializedResponse, FinalizedPairingData, SerializedDate } from '@identity-connect/api';\nimport { createEd25519KeyPair, encodeBase64 } from '@identity-connect/crypto';\nimport { isAxiosError } from 'axios';\nimport { DEFAULT_FRONTEND_URL } from './constants';\nimport { UnregisteredDappError } from './errors';\nimport { ACPairingClient, ACPairingClientConfig } from './PairingClient';\nimport { openPrompt, waitForPromptResponse } from './prompt';\n\nexport interface ICDappClientConfig extends ACPairingClientConfig {\n  frontendBaseURL?: string;\n}\n\nexport class ICDappClient extends ACPairingClient {\n  private readonly frontendBaseURL: string;\n\n  constructor(\n    private readonly dappId: string,\n    { frontendBaseURL = DEFAULT_FRONTEND_URL, ...pairingClientConfig }: ICDappClientConfig = {},\n  ) {\n    super(pairingClientConfig);\n    this.frontendBaseURL = frontendBaseURL;\n  }\n\n  private async createPairingRequest(dappEd25519PublicKeyB64: string) {\n    try {\n      const response = await this.axiosInstance.post<CreatePairingSerializedResponse>('v1/pairing/', {\n        dappEd25519PublicKeyB64,\n        dappId: this.dappId,\n      });\n      return response.data.data.pairing;\n    } catch (err) {\n      // TODO: export typed errors from API\n      if (isAxiosError(err) && err.response?.data?.message === 'Dapp not found') {\n        throw new UnregisteredDappError();\n      }\n      throw err;\n    }\n  }\n\n  // region Public API\n\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async connect() {\n    const { publicKey, secretKey } = createEd25519KeyPair();\n    const dappEd25519PublicKeyB64 = encodeBase64(publicKey.key);\n\n    // Open the prompt without pairingId (for a snappier ux)\n    const url = new URL(`${this.frontendBaseURL}/pairing`);\n    const promptWindow = await openPrompt(url.href);\n\n    let pairingId: string;\n    try {\n      const pendingPairing = await this.createPairingRequest(dappEd25519PublicKeyB64);\n      pairingId = pendingPairing.id;\n    } catch (err) {\n      // Close the prompt and have the dapp handle the error\n      promptWindow.close();\n      throw err;\n    }\n\n    // Update the prompt's URL as soon as a pairingId is available\n    url.searchParams.set('pairingId', pairingId);\n    promptWindow.location.href = url.href;\n    const promptResponse = await waitForPromptResponse<SerializedDate<FinalizedPairingData>>(promptWindow);\n\n    if (promptResponse.status === 'dismissed') {\n      // Ignore the result. This is just a courtesy call, so if anything goes wrong\n      // the pairing will be removed during scheduled cleanup)\n      void this.deletePairing(pairingId, secretKey, publicKey);\n      return undefined;\n    }\n\n    const finalizedPairing = promptResponse.args;\n    await this.addPairing({ publicKey, secretKey }, finalizedPairing);\n\n    return finalizedPairing.account.accountAddress;\n  }\n\n  async offboard(address: string) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === undefined) {\n      throw new Error('This account is not paired');\n    }\n\n    const walletId = pairing.dappWalletId;\n    if (walletId === undefined) {\n      throw new Error('This account cannot be offboarded');\n    }\n\n    const url = new URL(`${this.frontendBaseURL}/offboarding?walletId=${walletId}`);\n    const promptWindow = openPrompt(url);\n    const response = await waitForPromptResponse<{ offboarded: boolean }>(promptWindow);\n    if (response.status === 'approved' && response.args.offboarded) {\n      // If exported, disconnect the pairing to clean up\n      this.disconnect(address);\n      return true;\n    }\n    return false;\n  }\n\n  // endregion\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nconst DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };\nconst PROMPT_POLLER_INTERVAL = 500;\n\nexport function openPrompt(url: string | URL, size = DEFAULT_PROMPT_SIZE) {\n  const { height, width } = size;\n  const options = {\n    height,\n    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),\n    popup: true,\n    top: window.screenTop + Math.round((window.outerHeight - height) / 2),\n    width,\n  };\n\n  const strOptions = Object.entries(options)\n    .map(([key, value]) => `${key}=${JSON.stringify(value)}`)\n    .reduce((acc, entry) => `${acc}, ${entry}`);\n\n  const href = url instanceof URL ? url.href : url;\n  const promptWindow = window.open(href, undefined, strOptions);\n  if (promptWindow === null) {\n    throw new Error(\"Couldn't open prompt\");\n  }\n\n  return promptWindow;\n}\n\nexport interface PromptApproval<TResponseArgs> {\n  args: TResponseArgs;\n  status: 'approved';\n}\n\nexport interface PromptDismissal {\n  status: 'dismissed';\n}\n\nexport type PromptResponse<TResponseArgs> = PromptApproval<TResponseArgs> | PromptDismissal;\n\nexport async function waitForPromptResponse<TResponseArgs>(promptWindow: Window) {\n  return new Promise<PromptResponse<TResponseArgs>>((resolve) => {\n    const listeners = {\n      onMessage: (message: MessageEvent) => {\n        if (message.source !== promptWindow) {\n          return;\n        }\n        window.removeEventListener('message', listeners.onMessage);\n        clearTimeout(listeners.promptPollerId);\n        resolve({\n          args: message.data,\n          status: 'approved',\n        });\n      },\n      promptPollerId: setInterval(() => {\n        if (promptWindow.closed) {\n          window.removeEventListener('message', listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          resolve({\n            status: 'dismissed',\n          });\n        }\n      }, PROMPT_POLLER_INTERVAL),\n    };\n\n    window.addEventListener('message', listeners.onMessage);\n  });\n}\n","// Copyright © Aptos\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  ConnectRequest,\n  ConnectResponse,\n  type DappInfo,\n  DisconnectRequest,\n  GetConnectedAccountsRequest,\n  GetConnectedAccountsResponse,\n  IsConnectedRequest,\n  IsConnectedResponse,\n  SignAndSubmitTransactionRequest,\n  SignAndSubmitTransactionResponse,\n  SignMessageRequest,\n  SignMessageResponse,\n  SignTransactionRequest,\n  SignTransactionResponse,\n} from '@aptos-connect/wallet-api';\nimport { WebWalletTransport } from '@aptos-connect/web-transport';\nimport { NetworkName } from '@identity-connect/api';\nimport { DEFAULT_FRONTEND_URL } from './constants';\n\nexport interface ACKeylessClientConfig {\n  dappImageURI?: string;\n  dappName?: string;\n  defaultNetworkName?: NetworkName;\n  frontendBaseURL?: string;\n  provider?: 'google' | 'apple';\n}\n\nexport class ACKeylessClient {\n  private readonly defaultNetworkName: NetworkName;\n\n  readonly dappInfo: DappInfo;\n\n  private readonly transport: WebWalletTransport;\n\n  constructor({\n    dappImageURI,\n    dappName,\n    defaultNetworkName = NetworkName.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    provider = 'google',\n  }: ACKeylessClientConfig = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title,\n    };\n\n    this.transport = new WebWalletTransport(frontendBaseURL, provider);\n  }\n\n  // region Public API\n\n  async isConnected() {\n    const serializedRequest = IsConnectedRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = IsConnectedResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async getConnectedAccounts() {\n    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async disconnect() {\n    const serializedRequest = DisconnectRequest.serialize(this.dappInfo);\n    await this.transport.sendRequest(serializedRequest);\n  }\n\n  async connect() {\n    const serializedRequest = ConnectRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = ConnectResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signMessage(args: SignMessageRequest.Args) {\n    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signTransaction(\n    args: SignTransactionRequest.Args | SignTransactionRequest.ArgsWithTransaction,\n  ): Promise<SignTransactionResponse.Args> {\n    const normalizedArgs = 'transaction' in args ? SignTransactionRequest.normalizeArgs(args) : args;\n    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  async signAndSubmitTransaction(args: SignAndSubmitTransactionRequest.Args) {\n    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n\n  // endregion\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}