{"ast":null,"code":"import { a as i } from \"./chunk-BUUV6B4P.mjs\";\nimport { b as r } from \"./chunk-GYVSI3TS.mjs\";\nimport { decode as u } from \"js-base64\";\nasync function f(n) {\n  return new Promise(e => {\n    setTimeout(e, n);\n  });\n}\nfunction A(n) {\n  return n instanceof Error ? n.message : String(n);\n}\nvar _ = () => Math.floor(Date.now() / 1e3);\nfunction x(n) {\n  let e = new Date(n * 1e3);\n  return e.setMinutes(0), e.setSeconds(0), e.setMilliseconds(0), Math.floor(e.getTime() / 1e3);\n}\nfunction S(n) {\n  let e = n.replace(/-/g, \"+\").replace(/_/g, \"/\"),\n    t = e + \"==\".substring(0, (3 - e.length % 3) % 3);\n  return u(t);\n}\nfunction h(n) {\n  let e = n.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  for (; e.length % 4 !== 0;) e += \"=\";\n  return new Uint8Array(Buffer.from(e, \"base64\"));\n}\nvar T = (n, e) => n * 10 ** e,\n  b = (n, e) => n / 10 ** e,\n  a = n => {\n    let e = \"\";\n    for (let t = 2; t < n.length; t += 2) e += String.fromCharCode(parseInt(n.substring(t, t + 2), 16));\n    return e;\n  },\n  M = n => {\n    let {\n        account_address: e,\n        module_name: t,\n        struct_name: o\n      } = n,\n      s = a(t),\n      c = a(o);\n    return `${e}::${s}::${c}`;\n  },\n  y = n => typeof n == \"object\" && !Array.isArray(n) && n !== null && \"account_address\" in n && \"module_name\" in n && \"struct_name\" in n && typeof n.account_address == \"string\" && typeof n.module_name == \"string\" && typeof n.struct_name == \"string\";\nfunction v(n) {\n  let e = n.split(\"::\");\n  if (e.length !== 3) throw new Error(`Invalid function ${n}`);\n  let t = e[0],\n    o = e[1],\n    s = e[2];\n  return {\n    moduleAddress: t,\n    moduleName: o,\n    functionName: s\n  };\n}\nfunction w(n) {\n  let e = n.split(\"::\");\n  return e.length === 3 && r.isValid({\n    input: e[0]\n  }).valid;\n}\nfunction E(n, e = 6, t = 5) {\n  return `${n.slice(0, e)}...${n.slice(-t)}`;\n}\nvar d = \"0x1::aptos_coin::AptosCoin\",\n  I = r.A.toStringLong();\nfunction m(n) {\n  let e = /0x[0-9a-fA-F]+/g;\n  return n.replace(e, t => r.from(t, {\n    maxMissingChars: 63\n  }).toStringShort());\n}\nfunction $(n) {\n  let e = m(n);\n  return e === d ? r.A : i(r.A, e);\n}\nexport { f as a, A as b, _ as c, x as d, S as e, h as f, T as g, b as h, M as i, y as j, v as k, w as l, E as m, $ as n };","map":{"version":3,"names":["decode","u","f","n","Promise","e","setTimeout","A","Error","message","String","_","nowInSeconds","Math","floor","Date","now","x","setMinutes","setSeconds","setMilliseconds","getTime","S","replace","t","substring","length","h","Uint8Array","Buffer","from","T","convertAmountFromHumanReadableToOnChain","b","convertAmountFromOnChainToHumanReadable","a","fromCharCode","parseInt","M","account_address","module_name","struct_name","o","s","c","y","Array","isArray","v","split","moduleAddress","moduleName","functionName","w","r","isValid","input","valid","E","slice","d","I","toStringLong","m","maxMissingChars","toStringShort","$","i","g","j","k","l"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\ts-sdk\\src\\utils\\helpers.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { decode } from \"js-base64\";\nimport { MoveFunctionId, MoveStructId } from \"../types\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport { createObjectAddress } from \"../core/account/utils/address\";\n\n/**\n * Sleep for the specified amount of time in milliseconds.\n * This function can be used to introduce delays in asynchronous operations.\n *\n * @param timeMs - The time in milliseconds to sleep.\n * @group Implementation\n * @category Utils\n */\nexport async function sleep(timeMs: number): Promise<null> {\n  return new Promise((resolve) => {\n    setTimeout(resolve, timeMs);\n  });\n}\n\n/**\n * Get the error message from an unknown error.\n *\n * @param error The error to get the message from\n * @returns The error message\n * @group Implementation\n * @category Utils\n */\nexport function getErrorMessage(error: unknown): string {\n  return error instanceof Error ? error.message : String(error);\n}\n\n/**\n * @group Implementation\n * @category Utils\n */\nexport const nowInSeconds = () => Math.floor(Date.now() / 1000);\n\n/**\n * Floors the given timestamp to the nearest whole hour.\n * This function is useful for normalizing timestamps to hourly intervals.\n *\n * @param timestampInSeconds - The timestamp in seconds to be floored.\n * @group Implementation\n * @category Utils\n */\nexport function floorToWholeHour(timestampInSeconds: number): number {\n  const date = new Date(timestampInSeconds * 1000);\n  // Reset minutes and seconds to zero\n  date.setMinutes(0);\n  date.setSeconds(0);\n  date.setMilliseconds(0);\n  return Math.floor(date.getTime() / 1000);\n}\n\n/**\n * Decodes a base64 URL-encoded string into its original form.\n * This function is useful for converting base64 URL-encoded data back to a readable format.\n *\n * @param base64Url - The base64 URL-encoded string to decode.\n * @returns The decoded string.\n * @group Implementation\n * @category Utils\n */\nexport function base64UrlDecode(base64Url: string): string {\n  // Replace base64url-specific characters\n  const base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Pad the string with '=' characters if needed\n  const paddedBase64 = base64 + \"==\".substring(0, (3 - (base64.length % 3)) % 3);\n  const decodedString = decode(paddedBase64);\n  return decodedString;\n}\n\nexport function base64UrlToBytes(base64Url: string): Uint8Array {\n  // Convert Base64Url to Base64\n  let base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  // Add padding if needed\n  while (base64.length % 4 !== 0) {\n    base64 += \"=\";\n  }\n  // Use Buffer to convert base64 to Uint8Array\n  return new Uint8Array(Buffer.from(base64, \"base64\"));\n}\n\n/**\n * Amount is represented in the smallest unit format on chain, this function converts\n * a human-readable amount format to the smallest unit format\n * @example\n * human-readable amount format: 500\n * on chain amount format when decimal is 8: 50000000000\n *\n * @param value The value in human-readable format\n * @param decimal The token decimal\n * @returns The value in the smallest units\n * @group Implementation\n * @category Utils\n */\nexport const convertAmountFromHumanReadableToOnChain = (value: number, decimal: number) => value * 10 ** decimal;\n\n/**\n * Amount is represented in the smallest unit format on chain, this function converts\n * the smallest unit format to a human-readable amount format\n * @example\n * human-readable amount format: 500\n * on chain amount format when decimal is 8: 50000000000\n *\n * @param value The value in human-readable format\n * @param decimal The token decimal\n * @returns The value in the smallest units\n * @group Implementation\n * @category Utils\n */\nexport const convertAmountFromOnChainToHumanReadable = (value: number, decimal: number) => value / 10 ** decimal;\n\n/**\n * Convert a hex string to an ascii string with the `0x` prefix.\n *\n * `0x6170746f735f636f696e` --> `aptos_coin`\n *\n * @param hex The hex string to convert (e.g. `0x6170746f735f636f696e`)\n * @returns The ascii string\n * @group Implementation\n * @category Utils\n */\nconst hexToAscii = (hex: string) => {\n  let str = \"\";\n  for (let n = 2; n < hex.length; n += 2) {\n    str += String.fromCharCode(parseInt(hex.substring(n, n + 2), 16));\n  }\n  return str;\n};\n\n/**\n * Convert an encoded struct to a MoveStructId.\n *\n * @example\n * const structObj = {\n *   account_address: \"0x1\",\n *   module_name: \"0x6170746f735f636f696e\",\n *   struct_name: \"0x4170746f73436f696e\",\n * };\n * // structId is \"0x1::aptos_coin::AptosCoin\"\n * const structId = parseEncodedStruct(structObj);\n *\n * @param structObj The struct with account_address, module_name, and struct_name properties\n * @returns The MoveStructId\n * @group Implementation\n * @category Utils\n */\nexport const parseEncodedStruct = (structObj: {\n  account_address: string;\n  module_name: string;\n  struct_name: string;\n}): MoveStructId => {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  const { account_address, module_name, struct_name } = structObj;\n  const moduleName = hexToAscii(module_name);\n  const structName = hexToAscii(struct_name);\n  return `${account_address}::${moduleName}::${structName}`;\n};\n\n/**\n * Determines whether the given object is an encoded struct type with the following properties:\n * - account_address: string\n * - module_name: string\n * - struct_name: string\n *\n * @param structObj The object to check\n * @returns Whether the object is an encoded struct type\n * @group Implementation\n * @category Utils\n */\nexport const isEncodedStruct = (\n  structObj: any,\n): structObj is {\n  account_address: string;\n  module_name: string;\n  struct_name: string;\n} =>\n  typeof structObj === \"object\" &&\n  !Array.isArray(structObj) &&\n  structObj !== null &&\n  \"account_address\" in structObj &&\n  \"module_name\" in structObj &&\n  \"struct_name\" in structObj &&\n  typeof structObj.account_address === \"string\" &&\n  typeof structObj.module_name === \"string\" &&\n  typeof structObj.struct_name === \"string\";\n\n/**\n * Splits a function identifier into its constituent parts: module address, module name, and function name.\n * This function helps in validating and extracting details from a function identifier string.\n *\n * @param functionArg - The function identifier string in the format \"moduleAddress::moduleName::functionName\".\n * @returns An object containing the module address, module name, and function name.\n * @throws Error if the function identifier does not contain exactly three parts.\n * @group Implementation\n * @category Transactions\n */\nexport function getFunctionParts(functionArg: MoveFunctionId) {\n  const funcNameParts = functionArg.split(\"::\");\n  if (funcNameParts.length !== 3) {\n    throw new Error(`Invalid function ${functionArg}`);\n  }\n  const moduleAddress = funcNameParts[0];\n  const moduleName = funcNameParts[1];\n  const functionName = funcNameParts[2];\n  return { moduleAddress, moduleName, functionName };\n}\n\n/**\n * Validates the provided function information.\n *\n * @param functionInfo - The function information to validate.\n * @returns Whether the function information is valid.\n * @group Implementation\n * @category Utils\n */\nexport function isValidFunctionInfo(functionInfo: string): boolean {\n  const parts = functionInfo.split(\"::\");\n  return parts.length === 3 && AccountAddress.isValid({ input: parts[0] }).valid;\n}\n\n/**\n * Truncates the provided wallet address at the middle with an ellipsis.\n *\n * @param address - The wallet address to truncate.\n * @param start - The number of characters to show at the beginning of the address.\n * @param end - The number of characters to show at the end of the address.\n * @returns The truncated address.\n * @group Implementation\n * @category Utils\n */\nexport function truncateAddress(address: string, start: number = 6, end: number = 5) {\n  return `${address.slice(0, start)}...${address.slice(-end)}`;\n}\n\n/**\n * Constants for metadata address calculation\n */\nconst APTOS_COIN_TYPE_STR = \"0x1::aptos_coin::AptosCoin\";\nconst APT_METADATA_ADDRESS_HEX = AccountAddress.A.toStringLong();\n\n/**\n * Helper function to standardize Move type string by converting all addresses to short form,\n * including addresses within nested type parameters\n */\nfunction standardizeMoveTypeString(input: string): string {\n  // Regular expression to match addresses in the type string, including those within type parameters\n  // This regex matches \"0x\" followed by hex digits, handling both standalone addresses and those within <>\n  const addressRegex = /0x[0-9a-fA-F]+/g;\n\n  return input.replace(addressRegex, (match) => {\n    // Use AccountAddress to handle the address\n    return AccountAddress.from(match, { maxMissingChars: 63 }).toStringShort();\n  });\n}\n\n/**\n * Calculates the paired FA metadata address for a given coin type.\n * This function is tolerant of various address formats in the coin type string,\n * including complex nested types.\n *\n * @example\n * // All these formats are valid and will produce the same result:\n * pairedFaMetadataAddress(\"0x1::aptos_coin::AptosCoin\")  // simple form\n * pairedFaMetadataAddress(\"0x0000000000000000000000000000000000000000000000000000000000000001::aptos_coin::AptosCoin\")  // long form\n * pairedFaMetadataAddress(\"0x00001::aptos_coin::AptosCoin\")  // with leading zeros\n * pairedFaMetadataAddress(\"0x1::coin::Coin<0x1412::a::struct<0x0001::aptos_coin::AptosCoin>>\")  // nested type parameters\n *\n * @param coinType - The coin type string in any of these formats:\n *   - Short form address: \"0x1::aptos_coin::AptosCoin\"\n *   - Long form address: \"0x0000000000000000000000000000000000000000000000000000000000000001::aptos_coin::AptosCoin\"\n *   - With leading zeros: \"0x00001::aptos_coin::AptosCoin\"\n *   - With nested types: \"0x1::coin::Coin<0x1412::a::struct<0x0001::aptos_coin::AptosCoin>>\"\n * @returns The calculated metadata address as an AccountAddress instance\n */\nexport function pairedFaMetadataAddress(coinType: `0x${string}::${string}::${string}`): AccountAddress {\n  // Standardize the coin type string to handle any address format\n  const standardizedMoveTypeName = standardizeMoveTypeString(coinType);\n\n  return standardizedMoveTypeName === APTOS_COIN_TYPE_STR\n    ? AccountAddress.A\n    : createObjectAddress(AccountAddress.A, standardizedMoveTypeName);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}