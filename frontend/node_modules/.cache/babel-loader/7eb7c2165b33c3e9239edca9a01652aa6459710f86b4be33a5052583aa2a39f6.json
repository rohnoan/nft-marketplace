{"ast":null,"code":"import { b as c } from \"./chunk-STY74NUA.mjs\";\nimport { a as U, b, c as f, d as h, e as l, f as y } from \"./chunk-56CNRT2K.mjs\";\nimport { a as s } from \"./chunk-KDMSOCZY.mjs\";\nvar B = class {\n    bcsToBytes() {\n      let e = new n();\n      return this.serialize(e), e.toUint8Array();\n    }\n    bcsToHex() {\n      let e = this.bcsToBytes();\n      return c.fromHexInput(e);\n    }\n    toStringWithoutPrefix() {\n      return this.bcsToHex().toStringWithoutPrefix();\n    }\n    toString() {\n      return `0x${this.toStringWithoutPrefix()}`;\n    }\n  },\n  n = class {\n    constructor(e = 64) {\n      if (e <= 0) throw new Error(\"Length needs to be greater than 0\");\n      this.buffer = new ArrayBuffer(e), this.offset = 0;\n    }\n    ensureBufferWillHandleSize(e) {\n      for (; this.buffer.byteLength < this.offset + e;) {\n        let t = new ArrayBuffer(this.buffer.byteLength * 2);\n        new Uint8Array(t).set(new Uint8Array(this.buffer)), this.buffer = t;\n      }\n    }\n    appendToBuffer(e) {\n      this.ensureBufferWillHandleSize(e.length), new Uint8Array(this.buffer, this.offset).set(e), this.offset += e.length;\n    }\n    serializeWithFunction(e, t, i) {\n      this.ensureBufferWillHandleSize(t);\n      let a = new DataView(this.buffer, this.offset);\n      e.apply(a, [0, i, !0]), this.offset += t;\n    }\n    serializeStr(e) {\n      let t = new TextEncoder();\n      this.serializeBytes(t.encode(e));\n    }\n    serializeBytes(e) {\n      this.serializeU32AsUleb128(e.length), this.appendToBuffer(e);\n    }\n    serializeFixedBytes(e) {\n      this.appendToBuffer(e);\n    }\n    serializeBool(e) {\n      p(e);\n      let t = e ? 1 : 0;\n      this.appendToBuffer(new Uint8Array([t]));\n    }\n    serializeU8(e) {\n      this.appendToBuffer(new Uint8Array([e]));\n    }\n    serializeU16(e) {\n      this.serializeWithFunction(DataView.prototype.setUint16, 2, e);\n    }\n    serializeU32(e) {\n      this.serializeWithFunction(DataView.prototype.setUint32, 4, e);\n    }\n    serializeU64(e) {\n      let t = BigInt(e) & BigInt(f),\n        i = BigInt(e) >> BigInt(32);\n      this.serializeU32(Number(t)), this.serializeU32(Number(i));\n    }\n    serializeU128(e) {\n      let t = BigInt(e) & h,\n        i = BigInt(e) >> BigInt(64);\n      this.serializeU64(t), this.serializeU64(i);\n    }\n    serializeU256(e) {\n      let t = BigInt(e) & l,\n        i = BigInt(e) >> BigInt(128);\n      this.serializeU128(t), this.serializeU128(i);\n    }\n    serializeU32AsUleb128(e) {\n      let t = e,\n        i = [];\n      for (; t >>> 7;) i.push(t & 127 | 128), t >>>= 7;\n      i.push(t), this.appendToBuffer(new Uint8Array(i));\n    }\n    toUint8Array() {\n      return new Uint8Array(this.buffer).slice(0, this.offset);\n    }\n    serialize(e) {\n      e.serialize(this);\n    }\n    serializeVector(e) {\n      this.serializeU32AsUleb128(e.length), e.forEach(t => {\n        t.serialize(this);\n      });\n    }\n    serializeOption(e, t) {\n      let i = e !== void 0;\n      this.serializeBool(i), i && (typeof e == \"string\" ? this.serializeStr(e) : e instanceof Uint8Array ? t !== void 0 ? this.serializeFixedBytes(e) : this.serializeBytes(e) : e.serialize(this));\n    }\n    serializeOptionStr(e) {\n      e === void 0 ? this.serializeU32AsUleb128(0) : (this.serializeU32AsUleb128(1), this.serializeStr(e));\n    }\n  };\ns([o(0, U)], n.prototype, \"serializeU8\", 1), s([o(0, b)], n.prototype, \"serializeU16\", 1), s([o(0, f)], n.prototype, \"serializeU32\", 1), s([o(BigInt(0), h)], n.prototype, \"serializeU64\", 1), s([o(BigInt(0), l)], n.prototype, \"serializeU128\", 1), s([o(BigInt(0), y)], n.prototype, \"serializeU256\", 1), s([o(0, f)], n.prototype, \"serializeU32AsUleb128\", 1);\nfunction p(r) {\n  if (typeof r != \"boolean\") throw new Error(`${r} is not a boolean value`);\n}\nvar A = (r, e, t) => `${r} is out of range: [${e}, ${t}]`;\nfunction z(r, e, t) {\n  let i = BigInt(r);\n  if (i > BigInt(t) || i < BigInt(e)) throw new Error(A(r, e, t));\n}\nfunction o(r, e) {\n  return (t, i, a) => {\n    let g = a.value;\n    return a.value = function (u) {\n      return z(u, r, e), g.apply(this, [u]);\n    }, a;\n  };\n}\nexport { B as a, n as b, p as c, A as d, z as e };","map":{"version":3,"names":["B","bcsToBytes","e","n","serialize","toUint8Array","bcsToHex","c","fromHexInput","toStringWithoutPrefix","toString","constructor","Error","buffer","ArrayBuffer","offset","ensureBufferWillHandleSize","byteLength","t","Uint8Array","set","appendToBuffer","length","serializeWithFunction","i","a","DataView","apply","serializeStr","TextEncoder","serializeBytes","encode","serializeU32AsUleb128","serializeFixedBytes","serializeBool","p","serializeU8","serializeU16","prototype","setUint16","serializeU32","setUint32","serializeU64","BigInt","f","Number","serializeU128","h","serializeU256","l","push","slice","serializeVector","forEach","serializeOption","serializeOptionStr","s","o","U","b","y","r","A","outOfRangeErrorMessage","z","g","value","u","d"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\ts-sdk\\src\\bcs\\serializer.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable no-bitwise */\nimport {\n  MAX_U128_BIG_INT,\n  MAX_U16_NUMBER,\n  MAX_U32_NUMBER,\n  MAX_U64_BIG_INT,\n  MAX_U8_NUMBER,\n  MAX_U256_BIG_INT,\n} from \"./consts\";\nimport { Hex } from \"../core/hex\";\nimport { AnyNumber, Uint16, Uint32, Uint8 } from \"../types\";\n\n/**\n * This class serves as a base class for all serializable types. It facilitates\n * composable serialization of complex types and enables the serialization of\n * instances to their BCS (Binary Canonical Serialization) representation.\n * @group Implementation\n * @category BCS\n */\nexport abstract class Serializable {\n  abstract serialize(serializer: Serializer): void;\n\n  /**\n   * Serializes a `Serializable` value to its BCS representation.\n   * This function is the TypeScript SDK equivalent of `bcs::to_bytes` in Move.\n   * @returns the BCS representation of the Serializable instance as a byte buffer.\n   * @group Implementation\n   * @category BCS\n   */\n  bcsToBytes(): Uint8Array {\n    const serializer = new Serializer();\n    this.serialize(serializer);\n    return serializer.toUint8Array();\n  }\n\n  /**\n   * Converts the BCS-serialized bytes of a value into a Hex instance.\n   * This function provides a Hex representation of the BCS-serialized data for easier handling and manipulation.\n   * @returns A Hex instance with the BCS-serialized bytes loaded into its underlying Uint8Array.\n   * @group Implementation\n   * @category BCS\n   */\n  bcsToHex(): Hex {\n    const bcsBytes = this.bcsToBytes();\n    return Hex.fromHexInput(bcsBytes);\n  }\n\n  /**\n   * Returns the hex string representation of the `Serializable` value without the 0x prefix.\n   * @returns the hex format as a string without `0x` prefix.\n   */\n  toStringWithoutPrefix(): string {\n    return this.bcsToHex().toStringWithoutPrefix();\n  }\n\n  /**\n   * Returns the hex string representation of the `Serializable` value with the 0x prefix.\n   * @returns the hex formatas a string prefixed by `0x`.\n   */\n  toString(): string {\n    return `0x${this.toStringWithoutPrefix()}`;\n  }\n}\n\n/**\n * A class for serializing various data types into a binary format.\n * It provides methods to serialize strings, bytes, numbers, and other serializable objects\n * using the Binary Coded Serialization (BCS) layout. The serialized data can be retrieved as a\n * Uint8Array.\n * @group Implementation\n * @category BCS\n */\nexport class Serializer {\n  private buffer: ArrayBuffer;\n\n  private offset: number;\n\n  /**\n   * Constructs a serializer with a buffer of size `length` bytes, 64 bytes by default.\n   * The `length` must be greater than 0.\n   *\n   * @param length - The size of the buffer in bytes.\n   * @group Implementation\n   * @category BCS\n   */\n  constructor(length: number = 64) {\n    if (length <= 0) {\n      throw new Error(\"Length needs to be greater than 0\");\n    }\n    this.buffer = new ArrayBuffer(length);\n    this.offset = 0;\n  }\n\n  /**\n   * Ensures that the internal buffer can accommodate the specified number of bytes.\n   * This function dynamically resizes the buffer if the current size is insufficient.\n   *\n   * @param bytes - The number of bytes to ensure the buffer can handle.\n   * @group Implementation\n   * @category BCS\n   */\n  private ensureBufferWillHandleSize(bytes: number) {\n    while (this.buffer.byteLength < this.offset + bytes) {\n      const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);\n      new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));\n      this.buffer = newBuffer;\n    }\n  }\n\n  /**\n   * Appends the specified values to the buffer, ensuring that the buffer can accommodate the new data.\n   *\n   * @param {Uint8Array} values - The values to be appended to the buffer.\n   * @group Implementation\n   * @category BCS\n   */\n  protected appendToBuffer(values: Uint8Array) {\n    this.ensureBufferWillHandleSize(values.length);\n    new Uint8Array(this.buffer, this.offset).set(values);\n    this.offset += values.length;\n  }\n\n  /**\n   * Serializes a value into the buffer using the provided function, ensuring the buffer can accommodate the size.\n   *\n   * @param fn - The function to serialize the value, which takes a byte offset, the value to serialize, and an optional little-endian flag.\n   * @param fn.byteOffset - The byte offset at which to write the value.\n   * @param fn.value - The numeric value to serialize into the buffer.\n   * @param fn.littleEndian - Optional flag indicating whether to use little-endian byte order (defaults to true).\n   * @group Implementation\n   * @category BCS\n   */\n  // TODO: JSDoc bytesLength and value\n  private serializeWithFunction(\n    fn: (byteOffset: number, value: number, littleEndian?: boolean) => void,\n    bytesLength: number,\n    value: number,\n  ) {\n    this.ensureBufferWillHandleSize(bytesLength);\n    const dv = new DataView(this.buffer, this.offset);\n    fn.apply(dv, [0, value, true]);\n    this.offset += bytesLength;\n  }\n\n  /**\n   * Serializes a string. UTF8 string is supported.\n   * The number of bytes in the string content is serialized first, as a uleb128-encoded u32 integer.\n   * Then the string content is serialized as UTF8 encoded bytes.\n   *\n   * BCS layout for \"string\": string_length | string_content\n   * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.\n   *\n   * @param value - The string to serialize.\n   *\n   * @example\n   * ```typescript\n   * const serializer = new Serializer();\n   * serializer.serializeStr(\"1234abcd\");\n   * assert(serializer.toUint8Array() === new Uint8Array([8, 49, 50, 51, 52, 97, 98, 99, 100]));\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  serializeStr(value: string) {\n    const textEncoder = new TextEncoder();\n    this.serializeBytes(textEncoder.encode(value));\n  }\n\n  /**\n   * Serializes an array of bytes.\n   *\n   * This function encodes the length of the byte array as a u32 integer in uleb128 format, followed by the byte array itself.\n   * BCS layout for \"bytes\": bytes_length | bytes\n   * where bytes_length is a u32 integer encoded as a uleb128 integer, equal to the length of the bytes array.\n   * @param value - The byte array to serialize.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeBytes(value: Uint8Array) {\n    this.serializeU32AsUleb128(value.length);\n    this.appendToBuffer(value);\n  }\n\n  /**\n   * Serializes an array of bytes with a known length, allowing for efficient deserialization without needing to serialize the\n   * length itself.\n   * When deserializing, the number of bytes to deserialize needs to be passed in.\n\n   * @param value - The Uint8Array to be serialized.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeFixedBytes(value: Uint8Array) {\n    this.appendToBuffer(value);\n  }\n\n  /**\n   * Serializes a boolean value into a byte representation.\n   *\n   * The BCS layout for a boolean uses one byte, where \"0x01\" represents true and \"0x00\" represents false.\n   *\n   * @param value - The boolean value to serialize.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeBool(value: boolean) {\n    /**\n     * Ensures that the provided value is a boolean.\n     * This function throws an error if the value is not a boolean, helping to enforce type safety in your code.\n     *\n     * @param value - The value to be checked for boolean type.\n     * @throws {Error} Throws an error if the value is not a boolean.\n     * @group Implementation\n     * @category BCS\n     */\n    ensureBoolean(value);\n    const byteValue = value ? 1 : 0;\n    this.appendToBuffer(new Uint8Array([byteValue]));\n  }\n\n  /**\n   * Serializes a Uint8 value and appends it to the buffer.\n   * BCS layout for \"uint8\": One byte. Binary format in little-endian representation.\n   *\n   * @param value - The Uint8 value to serialize.\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(0, MAX_U8_NUMBER)\n  serializeU8(value: Uint8) {\n    this.appendToBuffer(new Uint8Array([value]));\n  }\n\n  /**\n   * Serializes a uint16 number.\n   *\n   * @group Implementation\n   * @category BCS\n\n   */\n\n  /**\n   * Serializes a 16-bit unsigned integer value into a binary format.\n   * BCS layout for \"uint16\": Two bytes. Binary format in little-endian representation.\n   *\n   * @param value - The 16-bit unsigned integer value to serialize.\n   * @example\n   * ```typescript\n   * const serializer = new Serializer();\n   * serializer.serializeU16(4660);\n   * assert(serializer.toUint8Array() === new Uint8Array([0x34, 0x12]));\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(0, MAX_U16_NUMBER)\n  serializeU16(value: Uint16) {\n    this.serializeWithFunction(DataView.prototype.setUint16, 2, value);\n  }\n\n  /**\n   * Serializes a 32-bit unsigned integer value into a binary format.\n   * This function is useful for encoding data that needs to be stored or transmitted in a compact form.\n   * @example\n   * ```typescript\n   * const serializer = new Serializer();\n   * serializer.serializeU32(305419896);\n   * assert(serializer.toUint8Array() === new Uint8Array([0x78, 0x56, 0x34, 0x12]));\n   * ```\n   * @param value - The 32-bit unsigned integer value to serialize.\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(0, MAX_U32_NUMBER)\n  serializeU32(value: Uint32) {\n    this.serializeWithFunction(DataView.prototype.setUint32, 4, value);\n  }\n\n  /**\n   * Serializes a 64-bit unsigned integer into a format suitable for storage or transmission.\n   * This function breaks down the value into two 32-bit components and writes them in little-endian order.\n   *\n   * @param value - The 64-bit unsigned integer to serialize, represented as a number.\n   * @example\n   * ```ts\n   * const serializer = new Serializer();\n   * serializer.serializeU64(1311768467750121216);\n   * assert(serializer.toUint8Array() === new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(BigInt(0), MAX_U64_BIG_INT)\n  serializeU64(value: AnyNumber) {\n    const low = BigInt(value) & BigInt(MAX_U32_NUMBER);\n    const high = BigInt(value) >> BigInt(32);\n\n    // write little endian number\n    this.serializeU32(Number(low));\n    this.serializeU32(Number(high));\n  }\n\n  /**\n   * Serializes a U128 value into a format suitable for storage or transmission.\n   *\n   * @param value - The U128 value to serialize, represented as a number.\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(BigInt(0), MAX_U128_BIG_INT)\n  serializeU128(value: AnyNumber) {\n    const low = BigInt(value) & MAX_U64_BIG_INT;\n    const high = BigInt(value) >> BigInt(64);\n\n    // write little endian number\n    this.serializeU64(low);\n    this.serializeU64(high);\n  }\n\n  /**\n   * Serializes a U256 value into a byte representation.\n   * This function is essential for encoding large numbers in a compact format suitable for transmission or storage.\n   *\n   * @param value - The U256 value to serialize, represented as an AnyNumber.\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(BigInt(0), MAX_U256_BIG_INT)\n  serializeU256(value: AnyNumber) {\n    const low = BigInt(value) & MAX_U128_BIG_INT;\n    const high = BigInt(value) >> BigInt(128);\n\n    // write little endian number\n    this.serializeU128(low);\n    this.serializeU128(high);\n  }\n\n  /**\n   * Serializes a 32-bit unsigned integer as a variable-length ULEB128 encoded byte array.\n   * BCS uses uleb128 encoding in two cases: (1) lengths of variable-length sequences and (2) tags of enum values\n   *\n   * @param val - The 32-bit unsigned integer value to be serialized.\n   * @group Implementation\n   * @category BCS\n   */\n  @checkNumberRange(0, MAX_U32_NUMBER)\n  serializeU32AsUleb128(val: Uint32) {\n    let value = val;\n    const valueArray = [];\n    while (value >>> 7 !== 0) {\n      valueArray.push((value & 0x7f) | 0x80);\n      value >>>= 7;\n    }\n    valueArray.push(value);\n    this.appendToBuffer(new Uint8Array(valueArray));\n  }\n\n  /**\n   * Returns the buffered bytes as a Uint8Array.\n   *\n   * This function allows you to retrieve the byte representation of the buffer up to the current offset.\n   *\n   * @returns Uint8Array - The byte array representation of the buffer.\n   * @group Implementation\n   * @category BCS\n   */\n  toUint8Array(): Uint8Array {\n    return new Uint8Array(this.buffer).slice(0, this.offset);\n  }\n\n  /**\n   * Serializes a `Serializable` value, facilitating composable serialization.\n   *\n   * @param value The Serializable value to serialize.\n   *\n   * @returns the serializer instance\n   * @group Implementation\n   * @category BCS\n   */\n  serialize<T extends Serializable>(value: T): void {\n    // NOTE: The `serialize` method called by `value` is defined in `value`'s\n    // Serializable interface, not the one defined in this class.\n    value.serialize(this);\n  }\n\n  /**\n   * Serializes an array of BCS Serializable values to a serializer instance.\n   * The bytes are added to the serializer instance's byte buffer.\n   *\n   * @param values The array of BCS Serializable values\n   * @example\n   * const addresses = new Array<AccountAddress>(\n   *   AccountAddress.from(\"0x1\"),\n   *   AccountAddress.from(\"0x2\"),\n   *   AccountAddress.from(\"0xa\"),\n   *   AccountAddress.from(\"0xb\"),\n   * );\n   * const serializer = new Serializer();\n   * serializer.serializeVector(addresses);\n   * const serializedBytes = serializer.toUint8Array();\n   * // serializedBytes is now the BCS-serialized bytes\n   * // The equivalent value in Move would be:\n   * // `bcs::to_bytes(&vector<address> [@0x1, @0x2, @0xa, @0xb])`;\n   * @group Implementation\n   * @category BCS\n   */\n  serializeVector<T extends Serializable>(values: Array<T>): void {\n    this.serializeU32AsUleb128(values.length);\n    values.forEach((item) => {\n      item.serialize(this);\n    });\n  }\n\n  /**\n   * Serializes an optional value which can be a Serializable, string, or Uint8Array.\n   * For strings and Uint8Arrays, it uses the appropriate serialization method.\n   *\n   * @param value The value to serialize (Serializable, string, Uint8Array, or undefined)\n   * @param len Optional fixed length for Uint8Array serialization. If provided, uses serializeFixedBytes instead of serializeBytes\n   *\n   * @example\n   * ```typescript\n   * const serializer = new Serializer();\n   * serializer.serializeOption(\"hello\");  // Serializes optional string\n   * serializer.serializeOption(new Uint8Array([1, 2, 3]));  // Serializes optional bytes\n   * serializer.serializeOption(new Uint8Array([1, 2, 3]), 3);  // Serializes optional fixed-length bytes\n   * serializer.serializeOption(new AccountAddress(...));  // Serializes optional Serializable\n   * serializer.serializeOption(undefined);  // Serializes none case\n   * ```\n   * @group Implementation\n   * @category BCS\n   */\n  serializeOption<T extends Serializable | string | Uint8Array>(value?: T, len?: number): void {\n    const hasValue = value !== undefined;\n    this.serializeBool(hasValue);\n    if (hasValue) {\n      if (typeof value === \"string\") {\n        this.serializeStr(value);\n      } else if (value instanceof Uint8Array) {\n        if (len !== undefined) {\n          this.serializeFixedBytes(value);\n        } else {\n          this.serializeBytes(value);\n        }\n      } else {\n        value.serialize(this);\n      }\n    }\n  }\n\n  /**\n   * @deprecated use `serializeOption` instead.\n   * Serializes an optional string, supporting UTF8 encoding.\n   * The function encodes the existence of the string first, followed by the length and content if it exists.\n   *\n   * BCS layout for optional \"string\": 1 | string_length | string_content\n   * where string_length is a u32 integer encoded as a uleb128 integer, equal to the number of bytes in string_content.\n   * BCS layout for undefined: 0\n   *\n   * @param value - The optional string to serialize. If undefined, it will serialize as 0.\n   * @group Implementation\n   * @category BCS\n   */\n  serializeOptionStr(value?: string): void {\n    if (value === undefined) {\n      this.serializeU32AsUleb128(0);\n    } else {\n      this.serializeU32AsUleb128(1);\n      this.serializeStr(value);\n    }\n  }\n}\n\n/**\n * @group Implementation\n * @category BCS\n */\nexport function ensureBoolean(value: unknown): asserts value is boolean {\n  if (typeof value !== \"boolean\") {\n    throw new Error(`${value} is not a boolean value`);\n  }\n}\n/**\n * @group Implementation\n * @category BCS\n */\nexport const outOfRangeErrorMessage = (value: AnyNumber, min: AnyNumber, max: AnyNumber) =>\n  `${value} is out of range: [${min}, ${max}]`;\n\n/**\n * Validates that a given number is within a specified range.\n * This function throws an error if the value is outside the defined minimum and maximum bounds.\n *\n * @param value - The number to validate.\n * @param minValue - The minimum allowable value (inclusive).\n * @param maxValue - The maximum allowable value (inclusive).\n * @group Implementation\n * @category BCS\n */\nexport function validateNumberInRange<T extends AnyNumber>(value: T, minValue: T, maxValue: T) {\n  const valueBigInt = BigInt(value);\n  if (valueBigInt > BigInt(maxValue) || valueBigInt < BigInt(minValue)) {\n    throw new Error(outOfRangeErrorMessage(value, minValue, maxValue));\n  }\n}\n\n/**\n * A decorator that validates that the input argument for a function is within a specified range.\n * This ensures that the function is only called with valid input values, preventing potential errors.\n *\n * @param minValue - The input argument must be greater than or equal to this value.\n * @param maxValue - The input argument must be less than or equal to this value.\n * @group Implementation\n * @category BCS\n */\nfunction checkNumberRange<T extends AnyNumber>(minValue: T, maxValue: T) {\n  return (target: unknown, propertyKey: string, descriptor: PropertyDescriptor) => {\n    const childFunction = descriptor.value;\n    // eslint-disable-next-line no-param-reassign\n    descriptor.value = function deco(value: AnyNumber) {\n      validateNumberInRange(value, minValue, maxValue);\n      return childFunction.apply(this, [value]);\n    };\n\n    return descriptor;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}