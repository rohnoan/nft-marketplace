{"ast":null,"code":"import { a as x } from \"./chunk-ROT6S6BM.mjs\";\nimport { a as d } from \"./chunk-DPW6ELCQ.mjs\";\nimport { d as v, f as P, g as E, h as H, i as b, j as U } from \"./chunk-C3Q23D22.mjs\";\nimport { b as K } from \"./chunk-BYINW7I2.mjs\";\nimport { a as S } from \"./chunk-Z6KQX6VX.mjs\";\nimport { a as A } from \"./chunk-6PKBXYG3.mjs\";\nimport { a as p } from \"./chunk-NJN3EAOM.mjs\";\nimport { b as o } from \"./chunk-STY74NUA.mjs\";\nimport { ed25519 as y } from \"@noble/curves/ed25519\";\nvar m = [237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16];\nfunction T(I) {\n  let e = I.toUint8Array().slice(32);\n  for (let t = m.length - 1; t >= 0; t -= 1) {\n    if (e[t] < m[t]) return !0;\n    if (e[t] > m[t]) return !1;\n  }\n  return !1;\n}\nvar n = class n extends K {\n  constructor(e) {\n    super();\n    let t = o.fromHexInput(e);\n    if (t.toUint8Array().length !== n.LENGTH) throw new Error(`PublicKey length should be ${n.LENGTH}`);\n    this.key = t;\n  }\n  verifySignature(e) {\n    let {\n      message: t,\n      signature: i\n    } = e;\n    if (!T(i)) return !1;\n    let a = d(t),\n      u = o.fromHexInput(a).toUint8Array(),\n      c = i.toUint8Array(),\n      l = this.key.toUint8Array();\n    return y.verify(c, u, l);\n  }\n  async verifySignatureAsync(e) {\n    return this.verifySignature(e);\n  }\n  authKey() {\n    return A.fromSchemeAndBytes({\n      scheme: 0,\n      input: this.toUint8Array()\n    });\n  }\n  toUint8Array() {\n    return this.key.toUint8Array();\n  }\n  serialize(e) {\n    e.serializeBytes(this.key.toUint8Array());\n  }\n  static deserialize(e) {\n    let t = e.deserializeBytes();\n    return new n(t);\n  }\n  static isPublicKey(e) {\n    return e instanceof n;\n  }\n  static isInstance(e) {\n    return \"key\" in e && e.key?.data?.length === n.LENGTH;\n  }\n};\nn.LENGTH = 32;\nvar f = n,\n  r = class r extends p {\n    constructor(e, t) {\n      super();\n      let i = x.parseHexInput(e, \"ed25519\", t);\n      if (i.toUint8Array().length !== r.LENGTH) throw new Error(`PrivateKey length should be ${r.LENGTH}`);\n      this.signingKey = i;\n    }\n    static generate() {\n      let e = y.utils.randomPrivateKey();\n      return new r(e, !1);\n    }\n    static fromDerivationPath(e, t) {\n      if (!P(e)) throw new Error(`Invalid derivation path ${e}`);\n      return r.fromDerivationPathInner(e, U(t));\n    }\n    static fromDerivationPathInner(e, t, i = v) {\n      let {\n          key: a,\n          chainCode: u\n        } = E(r.SLIP_0010_SEED, t),\n        c = b(e).map(g => parseInt(g, 10)),\n        {\n          key: l\n        } = c.reduce((g, w) => H(g, w + i), {\n          key: a,\n          chainCode: u\n        });\n      return new r(l, !1);\n    }\n    publicKey() {\n      let e = y.getPublicKey(this.signingKey.toUint8Array());\n      return new f(e);\n    }\n    sign(e) {\n      let t = d(e),\n        i = o.fromHexInput(t).toUint8Array(),\n        a = y.sign(i, this.signingKey.toUint8Array());\n      return new h(a);\n    }\n    toUint8Array() {\n      return this.signingKey.toUint8Array();\n    }\n    toString() {\n      return this.toHexString();\n    }\n    toHexString() {\n      return this.signingKey.toString();\n    }\n    toAIP80String() {\n      return x.formatPrivateKey(this.signingKey.toString(), \"ed25519\");\n    }\n    serialize(e) {\n      e.serializeBytes(this.toUint8Array());\n    }\n    static deserialize(e) {\n      let t = e.deserializeBytes();\n      return new r(t, !1);\n    }\n    static isPrivateKey(e) {\n      return e instanceof r;\n    }\n  };\nr.LENGTH = 32, r.SLIP_0010_SEED = \"ed25519 seed\";\nvar z = r,\n  s = class s extends S {\n    constructor(e) {\n      super();\n      let t = o.fromHexInput(e);\n      if (t.toUint8Array().length !== s.LENGTH) throw new Error(`Signature length should be ${s.LENGTH}`);\n      this.data = t;\n    }\n    toUint8Array() {\n      return this.data.toUint8Array();\n    }\n    serialize(e) {\n      e.serializeBytes(this.data.toUint8Array());\n    }\n    static deserialize(e) {\n      let t = e.deserializeBytes();\n      return new s(t);\n    }\n  };\ns.LENGTH = 64;\nvar h = s;\nexport { T as a, f as b, z as c, h as d };","map":{"version":3,"names":["ed25519","y","m","T","I","e","toUint8Array","slice","t","length","n","K","constructor","o","fromHexInput","LENGTH","Error","key","verifySignature","message","signature","i","a","d","u","c","l","verify","verifySignatureAsync","authKey","A","fromSchemeAndBytes","scheme","input","serialize","serializeBytes","deserialize","deserializeBytes","isPublicKey","isInstance","data","f","r","p","x","parseHexInput","signingKey","generate","utils","randomPrivateKey","fromDerivationPath","P","fromDerivationPathInner","U","v","chainCode","E","SLIP_0010_SEED","b","map","g","parseInt","reduce","w","H","publicKey","getPublicKey","sign","h","toString","toHexString","toAIP80String","formatPrivateKey","isPrivateKey","z","s","S"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\ts-sdk\\src\\core\\crypto\\ed25519.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ed25519 } from \"@noble/curves/ed25519\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializable, Serializer } from \"../../bcs/serializer\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Hex } from \"../hex\";\nimport { HexInput, SigningScheme as AuthenticationKeyScheme, PrivateKeyVariants } from \"../../types\";\nimport { CKDPriv, deriveKey, HARDENED_OFFSET, isValidHardenedPath, mnemonicToSeed, splitPath } from \"./hdKey\";\nimport { PrivateKey } from \"./privateKey\";\nimport { AccountPublicKey, PublicKey, VerifySignatureArgs, VerifySignatureAsyncArgs } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { convertSigningMessage } from \"./utils\";\n\n/**\n * L is the value that greater than or equal to will produce a non-canonical signature, and must be rejected\n * @group Implementation\n * @category Serialization\n */\nconst L: number[] = [\n  0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0x00, 0x00, 0x00,\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\n];\n\n/**\n * Checks if an ED25519 signature is non-canonical.\n * This function helps determine the validity of a signature by verifying its canonical form.\n *\n * @param signature - The signature to be checked for canonicality.\n * @returns A boolean indicating whether the signature is non-canonical.\n *\n * Comes from Aptos Core\n * https://github.com/aptos-labs/aptos-core/blob/main/crates/aptos-crypto/src/ed25519/ed25519_sigs.rs#L47-L85\n * @group Implementation\n * @category Serialization\n */\nexport function isCanonicalEd25519Signature(signature: Signature): boolean {\n  const s = signature.toUint8Array().slice(32);\n  for (let i = L.length - 1; i >= 0; i -= 1) {\n    if (s[i] < L[i]) {\n      return true;\n    }\n    if (s[i] > L[i]) {\n      return false;\n    }\n  }\n  // As this stage S == L which implies a non-canonical S.\n  return false;\n}\n\n/**\n * Represents the public key of an Ed25519 key pair.\n *\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentication keys.\n *\n * Ed25519 scheme is represented in the SDK as `Legacy authentication key` and also\n * as `AnyPublicKey` that represents any `Unified authentication key`.\n * @group Implementation\n * @category Serialization\n */\nexport class Ed25519PublicKey extends AccountPublicKey {\n  /**\n   * Length of an Ed25519 public key\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * Bytes of the public key\n   * @private\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly key: Hex;\n\n  /**\n   * Creates an instance of the Ed25519Signature class from a hex input.\n   * This constructor validates the length of the signature to ensure it meets the required specifications.\n   *\n   * @param hexInput - The hex input representing the Ed25519 signature.\n   * @throws Error if the signature length is not equal to Ed25519Signature.LENGTH.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput) {\n    super();\n\n    const hex = Hex.fromHexInput(hexInput);\n    if (hex.toUint8Array().length !== Ed25519PublicKey.LENGTH) {\n      throw new Error(`PublicKey length should be ${Ed25519PublicKey.LENGTH}`);\n    }\n    this.key = hex;\n  }\n\n  // region AccountPublicKey\n\n  /**\n   * Verifies a signed message using a public key.\n   *\n   * @param args - The arguments for verification.\n   * @param args.message - A signed message as a Hex string or Uint8Array.\n   * @param args.signature - The signature of the message.\n   * @group Implementation\n   * @category Serialization\n   */\n  verifySignature(args: VerifySignatureArgs): boolean {\n    const { message, signature } = args;\n    // Verify malleability\n    if (!isCanonicalEd25519Signature(signature)) {\n      return false;\n    }\n\n    const messageToVerify = convertSigningMessage(message);\n    const messageBytes = Hex.fromHexInput(messageToVerify).toUint8Array();\n    const signatureBytes = signature.toUint8Array();\n    const publicKeyBytes = this.key.toUint8Array();\n    return ed25519.verify(signatureBytes, messageBytes, publicKeyBytes);\n  }\n\n  /**\n   * Note: Ed25519Signatures can be verified syncronously.\n   *\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by confirming that the signature is valid.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.aptosConfig - The configuration object for connecting to the Aptos network\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify, which must be an instance of Secp256k1Signature.\n   * @returns A boolean indicating whether the signature is valid for the given message.\n   * @group Implementation\n   * @category Serialization\n   */\n  async verifySignatureAsync(args: VerifySignatureAsyncArgs): Promise<boolean> {\n    return this.verifySignature(args);\n  }\n\n  /**\n   * Generates an authentication key from the public key using the Ed25519 scheme.\n   * This function is essential for creating a secure authentication key that can be used for further cryptographic operations.\n   *\n   * @returns {AuthenticationKey} The generated authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.Ed25519,\n      input: this.toUint8Array(),\n    });\n  }\n\n  /**\n   * Convert the internal data representation to a Uint8Array.\n   *\n   * @returns Uint8Array representation of the data.\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.key.toUint8Array();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  /**\n   * Serializes the data into a byte array using the provided serializer.\n   * This allows for the conversion of data into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.key.toUint8Array());\n  }\n\n  /**\n   * Deserialize bytes into an Ed25519Signature object.\n   * This function is used to convert serialized byte data into a usable Ed25519Signature instance.\n   *\n   * @param deserializer - The deserializer instance used to read the byte data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): Ed25519PublicKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519PublicKey(bytes);\n  }\n\n  // endregion\n\n  /**\n   * Determine if the provided public key is an instance of Ed25519PublicKey.\n   *\n   * @param publicKey - The public key to check.\n   * @returns True if the public key is an instance of Ed25519PublicKey, otherwise false.\n   * @deprecated use `instanceof Ed25519PublicKey` instead.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPublicKey(publicKey: AccountPublicKey): publicKey is Ed25519PublicKey {\n    return publicKey instanceof Ed25519PublicKey;\n  }\n\n  /**\n   * Determines if the provided public key is a valid Ed25519 public key.\n   * This function checks for the presence of the \"key\" property and verifies that its data length matches the expected length\n   * for Ed25519 public keys.\n   *\n   * @param publicKey - The public key to validate.\n   * @returns A boolean indicating whether the public key is a valid Ed25519 public key.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isInstance(publicKey: PublicKey): publicKey is Ed25519PublicKey {\n    return \"key\" in publicKey && (publicKey.key as any)?.data?.length === Ed25519PublicKey.LENGTH;\n  }\n}\n\n/**\n * Represents the private key of an Ed25519 key pair.\n * @group Implementation\n * @category Serialization\n */\nexport class Ed25519PrivateKey extends Serializable implements PrivateKey {\n  /**\n   * Length of an Ed25519 private key\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH: number = 32;\n\n  /**\n   * The Ed25519 key seed to use for BIP-32 compatibility\n   * See more {@link https://github.com/satoshilabs/slips/blob/master/slip-0010.md}\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly SLIP_0010_SEED = \"ed25519 seed\";\n\n  /**\n   * The Ed25519 signing key\n   * @private\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly signingKey: Hex;\n\n  // region Constructors\n\n  /**\n   * Create a new PrivateKey instance from a Uint8Array or String.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @param hexInput HexInput (string or Uint8Array)\n   * @param strict If true, private key must AIP-80 compliant.\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(hexInput: HexInput, strict?: boolean) {\n    super();\n\n    const privateKeyHex = PrivateKey.parseHexInput(hexInput, PrivateKeyVariants.Ed25519, strict);\n    if (privateKeyHex.toUint8Array().length !== Ed25519PrivateKey.LENGTH) {\n      throw new Error(`PrivateKey length should be ${Ed25519PrivateKey.LENGTH}`);\n    }\n\n    // Create keyPair from Private key in Uint8Array format\n    this.signingKey = privateKeyHex;\n  }\n\n  /**\n   * Generate a new random private key.\n   *\n   * @returns Ed25519PrivateKey A newly generated Ed25519 private key.\n   * @group Implementation\n   * @category Serialization\n   */\n  static generate(): Ed25519PrivateKey {\n    const keyPair = ed25519.utils.randomPrivateKey();\n    return new Ed25519PrivateKey(keyPair, false);\n  }\n\n  /**\n   * Derives a private key from a mnemonic seed phrase using a specified BIP44 path.\n   * To derive multiple keys from the same phrase, change the path\n   *\n   * IMPORTANT: Ed25519 supports hardened derivation only, as it lacks a key homomorphism, making non-hardened derivation impossible.\n   *\n   * @param path - The BIP44 path used for key derivation.\n   * @param mnemonics - The mnemonic seed phrase from which the key will be derived.\n   * @throws Error if the provided path is not a valid hardened path.\n   * @group Implementation\n   * @category Serialization\n   */\n  static fromDerivationPath(path: string, mnemonics: string): Ed25519PrivateKey {\n    if (!isValidHardenedPath(path)) {\n      throw new Error(`Invalid derivation path ${path}`);\n    }\n    return Ed25519PrivateKey.fromDerivationPathInner(path, mnemonicToSeed(mnemonics));\n  }\n\n  /**\n   * Derives a child private key from a given BIP44 path and seed.\n   * A private inner function so we can separate from the main fromDerivationPath() method\n   * to add tests to verify we create the keys correctly.\n   *\n   * @param path - The BIP44 path used for key derivation.\n   * @param seed - The seed phrase created by the mnemonics, represented as a Uint8Array.\n   * @param offset - The offset used for key derivation, defaults to HARDENED_OFFSET.\n   * @returns An instance of Ed25519PrivateKey derived from the specified path and seed.\n   * @group Implementation\n   * @category Serialization\n   */\n  private static fromDerivationPathInner(path: string, seed: Uint8Array, offset = HARDENED_OFFSET): Ed25519PrivateKey {\n    const { key, chainCode } = deriveKey(Ed25519PrivateKey.SLIP_0010_SEED, seed);\n\n    const segments = splitPath(path).map((el) => parseInt(el, 10));\n\n    // Derive the child key based on the path\n    const { key: privateKey } = segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {\n      key,\n      chainCode,\n    });\n    return new Ed25519PrivateKey(privateKey, false);\n  }\n\n  // endregion\n\n  // region PrivateKey\n\n  /**\n   * Derive the Ed25519PublicKey for this private key.\n   *\n   * @returns Ed25519PublicKey - The derived public key corresponding to the private key.\n   * @group Implementation\n   * @category Serialization\n   */\n  publicKey(): Ed25519PublicKey {\n    const bytes = ed25519.getPublicKey(this.signingKey.toUint8Array());\n    return new Ed25519PublicKey(bytes);\n  }\n\n  /**\n   * Sign the given message with the private key.\n   * This function generates a digital signature for the specified message, ensuring its authenticity and integrity.\n   *\n   * @param message - A message as a string or Uint8Array in HexInput format.\n   * @returns A digital signature for the provided message.\n   * @group Implementation\n   * @category Serialization\n   */\n  sign(message: HexInput): Ed25519Signature {\n    const messageToSign = convertSigningMessage(message);\n    const messageBytes = Hex.fromHexInput(messageToSign).toUint8Array();\n    const signatureBytes = ed25519.sign(messageBytes, this.signingKey.toUint8Array());\n    return new Ed25519Signature(signatureBytes);\n  }\n\n  /**\n   * Get the private key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the private key\n   * @group Implementation\n   * @category Serialization\n   */\n  toUint8Array(): Uint8Array {\n    return this.signingKey.toUint8Array();\n  }\n\n  /**\n   * Get the private key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the private key.\n   * @group Implementation\n   * @category Serialization\n   */\n  toString(): string {\n    return this.toHexString();\n  }\n\n  /**\n   * Get the private key as a hex string with the 0x prefix.\n   *\n   * @returns string representation of the private key.\n   */\n  toHexString(): string {\n    return this.signingKey.toString();\n  }\n\n  /**\n   * Get the private key as a AIP-80 compliant hex string.\n   *\n   * [Read about AIP-80](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-80.md)\n   *\n   * @returns AIP-80 compliant string representation of the private key.\n   */\n  toAIP80String(): string {\n    return PrivateKey.formatPrivateKey(this.signingKey.toString(), PrivateKeyVariants.Ed25519);\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519PrivateKey {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519PrivateKey(bytes, false);\n  }\n\n  // endregion\n\n  /**\n   * Determines if the provided private key is an instance of Ed25519PrivateKey.\n   *\n   * @param privateKey - The private key to check.\n   * @returns A boolean indicating whether the private key is an Ed25519PrivateKey.\n   *\n   * @deprecated Use `instanceof Ed25519PrivateKey` instead.\n   * @group Implementation\n   * @category Serialization\n   */\n  static isPrivateKey(privateKey: PrivateKey): privateKey is Ed25519PrivateKey {\n    return privateKey instanceof Ed25519PrivateKey;\n  }\n}\n\n/**\n * Represents a signature of a message signed using an Ed25519 private key.\n * @group Implementation\n * @category Serialization\n */\nexport class Ed25519Signature extends Signature {\n  /**\n   * Length of an Ed25519 signature, which is 64 bytes.\n   * @group Implementation\n   * @category Serialization\n   */\n  static readonly LENGTH = 64;\n\n  /**\n   * The signature bytes\n   * @private\n   * @group Implementation\n   * @category Serialization\n   */\n  private readonly data: Hex;\n\n  // region Constructors\n\n  constructor(hexInput: HexInput) {\n    super();\n    const data = Hex.fromHexInput(hexInput);\n    if (data.toUint8Array().length !== Ed25519Signature.LENGTH) {\n      throw new Error(`Signature length should be ${Ed25519Signature.LENGTH}`);\n    }\n    this.data = data;\n  }\n\n  // endregion\n\n  // region Signature\n\n  toUint8Array(): Uint8Array {\n    return this.data.toUint8Array();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeBytes(this.data.toUint8Array());\n  }\n\n  static deserialize(deserializer: Deserializer): Ed25519Signature {\n    const bytes = deserializer.deserializeBytes();\n    return new Ed25519Signature(bytes);\n  }\n\n  // endregion\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}