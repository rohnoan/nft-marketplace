{"ast":null,"code":"import { e as r } from \"./chunk-6Y6ZO7TS.mjs\";\nimport { a as d } from \"./chunk-L33JDCWL.mjs\";\nasync function A(s, u) {\n  let {\n      url: t,\n      method: n,\n      body: i,\n      contentType: a,\n      params: o,\n      overrides: e,\n      originMethod: R\n    } = s,\n    p = {\n      ...e?.HEADERS,\n      \"x-aptos-client\": `aptos-typescript-sdk/${d}`,\n      \"content-type\": a ?? \"application/json\",\n      \"x-aptos-typescript-sdk-origin-method\": R\n    };\n  return e?.AUTH_TOKEN && (p.Authorization = `Bearer ${e?.AUTH_TOKEN}`), e?.API_KEY && (p.Authorization = `Bearer ${e?.API_KEY}`), u.provider({\n    url: t,\n    method: n,\n    body: i,\n    params: o,\n    headers: p,\n    overrides: e\n  });\n}\nasync function P(s, u, t) {\n  let {\n      url: n,\n      path: i\n    } = s,\n    a = i ? `${n}/${i}` : n,\n    o = await A({\n      ...s,\n      url: a\n    }, u.client),\n    e = {\n      status: o.status,\n      statusText: o.statusText ?? \"No status text provided\",\n      data: o.data,\n      headers: o.headers,\n      config: o.config,\n      request: o.request,\n      url: a\n    };\n  if (e.status === 401) throw new r({\n    apiType: t,\n    aptosRequest: s,\n    aptosResponse: e\n  });\n  if (t === \"Indexer\") {\n    let R = e.data;\n    if (R.errors) throw new r({\n      apiType: t,\n      aptosRequest: s,\n      aptosResponse: e\n    });\n    e.data = R.data;\n  } else if ((t === \"Pepper\" || t === \"Prover\") && e.status >= 400) throw new r({\n    apiType: t,\n    aptosRequest: s,\n    aptosResponse: e\n  });\n  if (e.status >= 200 && e.status < 300) return e;\n  throw new r({\n    apiType: t,\n    aptosRequest: s,\n    aptosResponse: e\n  });\n}\nexport { A as a, P as b };","map":{"version":3,"names":["A","s","u","url","t","method","n","body","i","contentType","a","params","o","overrides","e","originMethod","R","p","HEADERS","d","AUTH_TOKEN","Authorization","API_KEY","provider","headers","P","path","client","status","statusText","data","config","request","r","apiType","aptosRequest","aptosResponse","errors","b"],"sources":["C:\\Users\\ROHAN\\Desktop\\projects\\nft-marketplace\\frontend\\node_modules\\@aptos-labs\\ts-sdk\\src\\client\\core.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { VERSION } from \"../version\";\nimport { AnyNumber, AptosRequest, AptosResponse, Client, ClientRequest, ClientResponse, MimeType } from \"../types\";\nimport { AptosApiType } from \"../utils\";\nimport { AptosApiError } from \"../errors\";\n\n/**\n * Sends a request using the specified options and returns the response.\n *\n * @param options - The options for the request.\n * @param options.url - The URL to send the request to.\n * @param options.method - The HTTP method to use for the request.\n * @param options.body - The body of the request.\n * @param options.contentType - The content type of the request.\n * @param options.params - The query parameters to include in the request.\n * @param options.overrides - Additional overrides for the request.\n * @param options.overrides.HEADERS - Custom headers to include in the request.\n * @param options.overrides.AUTH_TOKEN - The authorization token for the request.\n * @param options.overrides.API_KEY - The API key for the request.\n * @param options.originMethod - The origin method for the request.\n * @param client - The client used to make the request.\n *\n * @returns The response from the request.\n * @group Implementation\n * @category Client\n */\nexport async function request<Req, Res>(options: ClientRequest<Req>, client: Client): Promise<ClientResponse<Res>> {\n  const { url, method, body, contentType, params, overrides, originMethod } = options;\n  const headers: Record<string, string | AnyNumber | boolean | undefined> = {\n    ...overrides?.HEADERS,\n    \"x-aptos-client\": `aptos-typescript-sdk/${VERSION}`,\n    \"content-type\": contentType ?? MimeType.JSON,\n    \"x-aptos-typescript-sdk-origin-method\": originMethod,\n  };\n\n  if (overrides?.AUTH_TOKEN) {\n    headers.Authorization = `Bearer ${overrides?.AUTH_TOKEN}`;\n  }\n  if (overrides?.API_KEY) {\n    headers.Authorization = `Bearer ${overrides?.API_KEY}`;\n  }\n\n  /*\n   * make a call using the @aptos-labs/aptos-client package\n   * {@link https://www.npmjs.com/package/@aptos-labs/aptos-client}\n   */\n  return client.provider<Req, Res>({\n    url,\n    method,\n    body,\n    params,\n    headers,\n    overrides,\n  });\n}\n\n/**\n * The main function to use when making an API request, returning the response or throwing an AptosApiError on failure.\n *\n * @param aptosRequestOpts - Options for the Aptos request, including the URL and path.\n * @param aptosConfig - The configuration information for the SDK client instance.\n * @param apiType - The type of API being accessed, which determines how the response is handled.\n * @returns The response from the API request or throws an AptosApiError if the request fails.\n * @group Implementation\n * @category Client\n */\nexport async function aptosRequest<Req extends {}, Res extends {}>(\n  aptosRequestOpts: AptosRequest,\n  aptosConfig: AptosConfig,\n  apiType: AptosApiType,\n): Promise<AptosResponse<Req, Res>> {\n  const { url, path } = aptosRequestOpts;\n  const fullUrl = path ? `${url}/${path}` : url;\n  const clientResponse = await request<Req, Res>({ ...aptosRequestOpts, url: fullUrl }, aptosConfig.client);\n\n  const aptosResponse: AptosResponse<Req, Res> = {\n    status: clientResponse.status,\n    statusText: clientResponse.statusText ?? \"No status text provided\",\n    data: clientResponse.data,\n    headers: clientResponse.headers,\n    config: clientResponse.config,\n    request: clientResponse.request,\n    url: fullUrl,\n  };\n\n  // Handle case for `Unauthorized` error (i.e. API_KEY error)\n  if (aptosResponse.status === 401) {\n    throw new AptosApiError({ apiType, aptosRequest: aptosRequestOpts, aptosResponse });\n  }\n\n  // to support both fullnode and indexer responses,\n  // check if it is an indexer query, and adjust response.data\n  if (apiType === AptosApiType.INDEXER) {\n    const indexerResponse = aptosResponse.data as any;\n    // Handle Indexer general errors\n    if (indexerResponse.errors) {\n      throw new AptosApiError({\n        apiType,\n        aptosRequest: aptosRequestOpts,\n        aptosResponse,\n      });\n    }\n    aptosResponse.data = indexerResponse.data as Res;\n  } else if (apiType === AptosApiType.PEPPER || apiType === AptosApiType.PROVER) {\n    if (aptosResponse.status >= 400) {\n      throw new AptosApiError({ apiType, aptosRequest: aptosRequestOpts, aptosResponse });\n    }\n  }\n\n  if (aptosResponse.status >= 200 && aptosResponse.status < 300) {\n    return aptosResponse;\n  }\n\n  // We have to explicitly check for all request types, because if the error is a non-indexer error, but\n  // comes from an indexer request (e.g. 404), we'll need to mention it appropriately\n  throw new AptosApiError({ apiType, aptosRequest: aptosRequestOpts, aptosResponse });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}